<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[CF915E] Physical Education Lessons</title>
      <link href="/is-zxy.github.io/2020/06/13/%5BCF915E%5D-Physical-Education-Lessons/"/>
      <url>/is-zxy.github.io/2020/06/13/%5BCF915E%5D-Physical-Education-Lessons/</url>
      
        <content type="html"><![CDATA[<p>Alex高中毕业了，他现在是大学新生。虽然他学习编程，但他还是要上体育课，这对他来说完全是一个意外。快要期末了，但是不幸的Alex的体育学分还是零蛋！</p><p>Alex可不希望被开除，他想知道到期末还有多少天的工作日，这样他就能在这些日子里修体育学分。但是在这里计算工作日可不是件容易的事情：</p><p>从现在到学期结束还有 $n$ 天(从 $1$ 到 $n$ 编号)，他们一开始都是工作日。接下来学校的工作人员会<strong>依次</strong>发出 $q$ 个指令，每个指令可以用三个参数 $l,r,k$ 描述：</p><ul><li>如果 $k=1$，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成<strong>非</strong>工作日。</li><li>如果 $k=2$，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成<strong>工作日</strong>。</li></ul><p>帮助Alex统计每个指令下发后，剩余的工作日天数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 10^9$</p><p>$1\le q\le 3\times 10^5$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF915E" target="_blank" rel="noopener">CF915E Physical Education Lessons</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然可以线段树解决。</p><p>不过.. $n\le 10^9$？</p><p>轮到刚学的动态开点出场啦。</p><p>不过数组大小十分玄学，试出来的。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Log 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> lson[N*Log],rson[N*Log],sum[N*Log],lazy[N*Log],tot=<span class="number">1</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) lson[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) rson[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s(x) sum[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) lazy[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  s(p)=s(ls(p))+s(rs(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!l(p)) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(!ls(p)) ls(p)=++tot;</span><br><span class="line">  s(ls(p))=(mid-l+<span class="number">1</span>)*(l(p)&amp;<span class="number">1</span>);</span><br><span class="line">  l(ls(p))=l(p);</span><br><span class="line">  <span class="keyword">if</span>(!rs(p)) rs(p)=++tot;</span><br><span class="line">  s(rs(p))=(r-mid)*(l(p)&amp;<span class="number">1</span>);</span><br><span class="line">  l(rs(p))=l(p);</span><br><span class="line">  l(p)=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(!p) p=++tot;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">  s(p)=(r-l+<span class="number">1</span>)*(x&amp;<span class="number">1</span>);</span><br><span class="line">  l(p)=x;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  spread(p,l,r);</span><br><span class="line">change(ls(p),l,mid,L,R,x);</span><br><span class="line">  change(rs(p),mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">  update(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> s(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">tree.change(root,<span class="number">1</span>,n,l,r,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-tree.ask());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 动态开点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树进阶之动态开点学习笔记</title>
      <link href="/is-zxy.github.io/2020/06/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/06/12/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线段树的空间复杂度为 $O(4\times N)$。若 $N$ 很大的话，可能会爆空间。这时便可以考虑动态开点了。</p><p>前置知识：线段树</p><a id="more"></a><h1 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h1><p>有的时候，线段树需要维护的区间很大，但是实际用到的节点却十分的少，这就造成了空间的浪费。</p><p>于是考虑：是否可以用到一个节点再开点呢？</p><p>是可以的。</p><p>一开始，只有一个根节点。</p><p>此时由于节点 $p$ 的子节点编号并不为 $2\times p$ 和 $2\times p +1$了，因此需要开两个数组记录每个节点的左右节点的编号。</p><p>同样的操作。递归进入左右儿子，如果要用新点就开。</p><p>这样空间复杂度可以降到 $O(N\log N)$。</p><p>具体代码实现见例题。</p><h2 id="例题-洛谷P1908-逆序对"><a href="#例题-洛谷P1908-逆序对" class="headerlink" title="例题 [洛谷P1908] 逆序对"></a>例题 [洛谷P1908] 逆序对</h2><p>给定一有 $n$ 个数的序列，求该序列中的逆序对个数。</p><p>本题中逆序对定义为 $a_i&gt;a_j$ 且 $i&lt;j$ 的有序对。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$n\le 5\times 10^5$</p><p>$a_i\le 10^9$</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P1908" target="_blank" rel="noopener">P1908 逆序对</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先这题显然可以离散化后线段树/树状数组解决。</p><p>动态开点也是可以的，而且不用离散化了。</p><p>首先只有一个根节点。</p><p>定义 $lson[x],rson[x]$ 分别表示 $x$ 节点的左右节点，若为 $0$ 说明不存在。</p><p>其实与普通线段树就多了个开点的操作。若用到新的节点，就开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;x||r&lt;x) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(!p) p=++tot;<span class="comment">//开新点</span></span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">  s(p)++;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  change(l(p),l,mid,x);</span><br><span class="line">  change(r(p),mid+<span class="number">1</span>,r,x);</span><br><span class="line">  update(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他与普通线段树差不多。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Log 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> lson[N*Log],rson[N*Log],tot=<span class="number">1</span>;</span><br><span class="line">ll sum[N*Log];</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> s(x) sum[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mid (l+r&gt;&gt;1)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) lson[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> r(x) rson[x]</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  s(p)=s(l(p))+s(r(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;x||r&lt;x) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(!p) p=++tot;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">  s(p)++;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  change(l(p),l,mid,x);</span><br><span class="line">  change(r(p),mid+<span class="number">1</span>,r,x);</span><br><span class="line">  update(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p||l&gt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> s(p);</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> ask(l(p),l,mid,x);</span><br><span class="line">  <span class="keyword">return</span> s(l(p))+ask(r(p),mid+<span class="number">1</span>,r,x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">tree.change(root,<span class="number">1</span>,MAXN,a[i]);</span><br><span class="line">ans+=tree.ask(<span class="number">1</span>,<span class="number">1</span>,MAXN,a[i]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-洛谷P5490-【模板】扫描线"><a href="#例题-洛谷P5490-【模板】扫描线" class="headerlink" title="例题 [洛谷P5490] 【模板】扫描线"></a>例题 [洛谷P5490] 【模板】扫描线</h2><p>求 $n$ 个矩形的面积并。</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le n\le 10^5$</p><p>坐标为 $0\sim 10^9$ 之间的整数。</p><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P5490" target="_blank" rel="noopener">P5490 【模板】扫描线</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>之前用的离散化。</p><p>当然也可以动态开点解决。</p><p>没啥思路，直接套233。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Log 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ltot=<span class="number">0</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll x,y_1,y_2,k;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">node():x(),y_1(),y_2(),k()&#123;&#125;</span><br><span class="line">node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y_1,<span class="keyword">int</span> _y_2,<span class="keyword">int</span> _k):x(_x),y_1(_y_1),y_2(_y_2),k(_k)&#123;&#125;</span><br><span class="line">&#125;line[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> lson[N*Log],rson[N*Log],cnt[N*Log],tot=<span class="number">1</span>;</span><br><span class="line">ll len[N*Log];</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) lson[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) rson[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> c(x) cnt[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) len[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c(p)&gt;<span class="number">0</span>) l(p)=r-l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> l(p)=l(ls(p))+l(rs(p));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(!p) p=++tot;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">  c(p)+=x;</span><br><span class="line">  update(p,l,r);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  change(ls(p),l,mid,L,R,x);</span><br><span class="line">  change(rs(p),mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">  update(p,l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> l(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x_1,x_2,y_1,y_2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x_1&gt;&gt;y_1&gt;&gt;x_2&gt;&gt;y_2;</span><br><span class="line">line[++ltot]=node(x_1,y_1,y_2,<span class="number">1</span>);</span><br><span class="line">line[++ltot]=node(x_2,y_1,y_2,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sort(line+<span class="number">1</span>,line+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">tree.change(root,<span class="number">1</span>,MAXN,line[i].y_1,line[i].y_2<span class="number">-1</span>,line[i].k);</span><br><span class="line">ans+=(line[i+<span class="number">1</span>].x-line[i].x)*tree.ask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不难理解。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 动态开点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描线学习笔记</title>
      <link href="/is-zxy.github.io/2020/06/10/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/06/10/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>扫描线可以用来求面积并与周长并。</p><p>前置知识：线段树</p><a id="more"></a><p>直接上题吧。</p><h2 id="Vijos1056-图形面积"><a href="#Vijos1056-图形面积" class="headerlink" title="[Vijos1056] 图形面积"></a>[Vijos1056] 图形面积</h2><p>桌面上放了 $N$ 个平行于坐标轴的矩形，这 $N$ 个矩形可能有互相覆盖的部分，求它们组成的图形的面积。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N\le 100$，坐标范围为 $-10^8\sim 10^8$ 之间的整数。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://vijos.org/p/1056" target="_blank" rel="noopener">图形面积</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做标记暴力求解？抱歉，坐标范围不允许。</p><p>于是引入“扫描线”这个方法。</p><p>看以下的图。</p><p><img src="https://wx2.sbimg.cn/2020/06/11/1a1c86922121d850d.png" alt="1a1c86922121d850d.png"></p><p>如何求这个的面积并呢？</p><p>试想一下，如果用一个竖直的直线从左到右扫，那么直线在整个图形内的长度只有在每个矩形的左右边界才会发生变化。由于有 $N$ 个矩形，也就是说有 $2\times N$ 个左右边界，因此<strong>整个图形</strong>被分为了 $2\times N $ 段。每一段在直线上覆盖的长度 $L$ 是固定的，因此该段的面积即为 $L\times$ 该段的宽度，总的并集面积即为各段的面积之和。这就是扫描线这个方法名字的由来。</p><p>既然如此，那么要想办法存下每段的边界，也就是每个矩形的左右边界。考虑到边界的位置，长度，以及为左边界还是右边界，因此可以想到用一个四元组存下一个边界。若一个矩形的左下角为 $(x_1,y_1)$，右上角为 $(x_2,y_2)$，那么便存下两个边界，一个为 $(x_1,y_1,y_2,1)$，另一个为 $(x_2,y_1,y_2,-1)$。第四元的用法稍后会讲到。</p><p>从左到右扫，因此将 $2\times N$ 个四元组按照 $x$ 递增排序，如下图。</p><p><a href="https://sbimg.cn/image/00zid" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/06/11/18209aa44d11b1bb1.png" alt="18209aa44d11b1bb1.png"></a></p><p>本题的 $y$ 坐标范围较大，但实际上最多只有 $100$ 个矩形，因此可以考虑将 $y$ 坐标离散化。可以建立一个<code>map</code> $val[y]$ 表示 $y$ 被离散化后映射到的整数值， $raw[i]$ 表示整数值 $i$ 对应的原始的 $y$ 坐标值。</p><p>离散化后若有 $t$ 个不同的 $y$ 坐标，那么<strong>扫描线</strong>至多被分为 $t-1$ 段，其中第 $i$ 段为 $\bigg[raw[i+1],raw[i]\bigg]$。</p><p>考虑上面说到的思路</p><blockquote><p>直线在整个图形内的长度只有在每个矩形的左右边界才会发生变化。</p></blockquote><p>因此需要维护直线在整个图形内的长度。</p><p>所以建立一个数组 $c$，记录扫描线上的各段被覆盖的次数。初值均为 $0$。</p><p>这样一系列都预处理完后，便可以进行求解操作了。</p><p>注意扫描排序后的 $2N$ 个四元组，设当前的四元组为 $(x,y_1,y_2,k)$。这样，扫描线上第 $val[y_1]$ 到 $val[y_2]-1$ 段均被覆盖了 $k$ 次，因此将 $c\big[val[y_1]\big],c\big[val[y_1]+1\big],\dots,c\big[val[y_2]-1\big]$ 均加上 $k$。</p><p>然后进行下一步操作。此时若下一个四元组的横坐标为 $x_2$，则扫描线从 $x$ 扫到 $x_2$ 的过程中，被覆盖的长度均不变，为</p><script type="math/tex; mode=display">\sum_{c[i]>0}\big(raw[i+1]-raw[i]\big)</script><p>此即为至少被覆盖一次的段的总长度。</p><p>于是，最终答案 $ans$ 累加上</p><script type="math/tex; mode=display">(x_2-x)\times \sum_{c[i]>0}\big(raw[i+1]-raw[i]\big)</script><p>这样对 $2N$ 个四元组均操作完毕后， $ans$ 即为最终结果。</p><p>这样暴力修改的话，时间复杂度为 $O(N^2)$，可以通过本题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,ztot=<span class="number">0</span>,t,c[N&lt;&lt;<span class="number">1</span>],ord[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll raw[N&lt;&lt;<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll x,y_1,y_2,k;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">node():x(),y_1(),y_2(),k()&#123;&#125;</span><br><span class="line">node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y_1,<span class="keyword">int</span> _y_2,<span class="keyword">int</span> _k):x(_x),y_1(_y_1),y_2(_y_2),k(_k)&#123;&#125;</span><br><span class="line">&#125;line[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(ord+<span class="number">1</span>,ord+ztot+<span class="number">1</span>);</span><br><span class="line">t=unique(ord+<span class="number">1</span>,ord+ztot+<span class="number">1</span>)-ord<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ztot;i++) &#123;</span><br><span class="line">val[ord[i]]=lower_bound(ord+<span class="number">1</span>,ord+t+<span class="number">1</span>,ord[i])-ord;</span><br><span class="line">raw[val[ord[i]]]=ord[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x_1,x_2,y_1,y_2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x_1&gt;&gt;y_1&gt;&gt;x_2&gt;&gt;y_2;</span><br><span class="line">line[++tot]=node(x_1,y_1,y_2,<span class="number">1</span>);</span><br><span class="line">line[++tot]=node(x_2,y_1,y_2,<span class="number">-1</span>);</span><br><span class="line">ord[++ztot]=y_1,ord[++ztot]=y_2;</span><br><span class="line">&#125;</span><br><span class="line">n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sort(line+<span class="number">1</span>,line+tot+<span class="number">1</span>);</span><br><span class="line">discrete();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> valy_1=val[line[i].y_1],valy_2=val[line[i].y_2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=valy_1;j&lt;valy_2;j++) c[j]+=line[i].k;</span><br><span class="line">ll l=line[i+<span class="number">1</span>].x-line[i].x,h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;t;j++) <span class="keyword">if</span>(c[j]&gt;<span class="number">0</span>) h+=raw[j+<span class="number">1</span>]-raw[j];</span><br><span class="line">ans+=l*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>若把矩形的个数从 $10^2$ 增加到 $10^5$ 呢？</p><h2 id="洛谷P5490-【模板】扫描线"><a href="#洛谷P5490-【模板】扫描线" class="headerlink" title="[洛谷P5490]【模板】扫描线"></a>[洛谷P5490]【模板】扫描线</h2><p>桌面上放了 $N$ 个平行于坐标轴的矩形，这 $N$ 个矩形可能有互相覆盖的部分，求它们组成的图形的面积。</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N\le 10^5$，坐标范围为 $0\sim 10^9$ 之间的整数。</p><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P5490" target="_blank" rel="noopener">P5490 【模板】扫描线</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>此时 $O(N^2)$ 的算法显然过不了了。</p><p>上面的算法主要的麻烦部分在于段区间的暴力修改。</p><p>说到区间修改，那么有什么方法进行优化呢？</p><p>线段树！</p><p>我们以离散后的 $y$ 所对应的整数为基准建立线段树，直接对其进行修改即可！</p><p>用线段树维护 $len$ 与 $cnt$，其中 $len$ 表示该区间内的扫描线被覆盖的长度， $cnt$ 表示该区间被覆盖了多少次。</p><p>这样，在更新点 $p$ 的时候，若 $p$ 的 $cnt$ 大于 $0$，那么对应的 $len$ 就是 $p$ 的区间长度；反之则为左右节点的 $len$ 之和。</p><p>时间复杂度 $O(N\log N)$。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,ztot=<span class="number">0</span>,t,c[N&lt;&lt;<span class="number">1</span>],ord[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll raw[N&lt;&lt;<span class="number">1</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll x,y_1,y_2,k;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">node():x(),y_1(),y_2(),k()&#123;&#125;</span><br><span class="line">node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y_1,<span class="keyword">int</span> _y_2,<span class="keyword">int</span> _k):x(_x),y_1(_y_1),y_2(_y_2),k(_k)&#123;&#125;</span><br><span class="line">&#125;line[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  ll cnt[N&lt;&lt;<span class="number">4</span>],len[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> c(x) cnt[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) len[x]</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mid (l+r&gt;&gt;1)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c(p)&gt;<span class="number">0</span>) l(p)=raw[r+<span class="number">1</span>]-raw[l];</span><br><span class="line">  <span class="keyword">else</span> l(p)=l(ls)+l(rs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  c(p)=<span class="number">0</span>,l(p)=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">  build(ls,l,mid);</span><br><span class="line">  build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">  c(p)+=x;</span><br><span class="line">  update(p,l,r);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  change(ls,l,mid,L,R,x);</span><br><span class="line">  change(rs,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">  update(p,l,r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ll <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> len[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discrete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(ord+<span class="number">1</span>,ord+ztot+<span class="number">1</span>);</span><br><span class="line">t=unique(ord+<span class="number">1</span>,ord+ztot+<span class="number">1</span>)-ord<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ztot;i++) &#123;</span><br><span class="line">val[ord[i]]=lower_bound(ord+<span class="number">1</span>,ord+t+<span class="number">1</span>,ord[i])-ord;</span><br><span class="line">raw[val[ord[i]]]=ord[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x_1,x_2,y_1,y_2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x_1&gt;&gt;y_1&gt;&gt;x_2&gt;&gt;y_2;</span><br><span class="line">line[++tot]=node(x_1,y_1,y_2,<span class="number">1</span>);</span><br><span class="line">line[++tot]=node(x_2,y_1,y_2,<span class="number">-1</span>);</span><br><span class="line">ord[++ztot]=y_1,ord[++ztot]=y_2;</span><br><span class="line">&#125;</span><br><span class="line">n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sort(line+<span class="number">1</span>,line+tot+<span class="number">1</span>);</span><br><span class="line">discrete();</span><br><span class="line">tree.build(<span class="number">1</span>,<span class="number">1</span>,t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> valy_1=val[line[i].y_1],valy_2=val[line[i].y_2];</span><br><span class="line">tree.change(<span class="number">1</span>,<span class="number">1</span>,t,valy_1,valy_2<span class="number">-1</span>,line[i].k);</span><br><span class="line">ans+=tree.ask()*(line[i+<span class="number">1</span>].x-line[i].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>题目名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="http://poj.org/problem?id=1151" target="_blank" rel="noopener">[POJ1151]Atlantis</a></td><td>×</td></tr><tr><td><a href="http://poj.org/problem?id=2482" target="_blank" rel="noopener">[POJ2482]Stars in Your Window</a></td><td>×</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后借洛谷 <a href="https://www.luogu.com.cn/user/36908" target="_blank" rel="noopener">Gu_Pigeon</a> 的动图一用。</p><p><img src="https://wx1.sbimg.cn/2020/06/12/eTuDjP.gif" alt="eTuDjP.gif"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《算法竞赛进阶指南》</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO13NOV] Pogo-Cows</title>
      <link href="/is-zxy.github.io/2020/06/09/%5BUSACO13NOV%5D-Pogo-Cows/"/>
      <url>/is-zxy.github.io/2020/06/09/%5BUSACO13NOV%5D-Pogo-Cows/</url>
      
        <content type="html"><![CDATA[<p>FJ给奶牛贝西的脚安装上了弹簧，使它可以在农场里快速地跳跃，但是它还没有学会如何降低速度。</p><p>FJ觉得让贝西在一条直线的一维线路上进行练习，他在不同的目标点放置了 $N(1 \le N \le 1000)$ 个目标点，目标点 $i$ 在目标点 $x(i)$，该点得分为 $p(i)$。贝西开始时可以选择站在一个目标点上，只允许朝一个方向跳跃，从一目标点跳到另外一个目标点，每次跳跃的距离至少和上一次跳跃的距离相等，并且必须跳到一个目标点。</p><p>每跳到一个目标点，贝西可以拿到该点的得分，请计算他的最大可能得分。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3089" target="_blank" rel="noopener">[USACO13NOV]Pogo-Cow S</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义 $dp[i][j]$ 表示到达了第 $i$ 个目标点，由第 $j$ 个目标点跳来的最大得分。</p><p>显然 </p><script type="math/tex; mode=display">dp[i][j]=\max\{dp[j][k]+score[i]\},x[i]-x[j]\ge x[j]-x[k]</script><p>初始化 $dp[i][i]=score[i]$。</p><p>由于朝向未定，正反两次 DP。</p><p>这样可以得到以下的 $O(n^3)$ 的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N][N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,score;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a) &#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=g[i].score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(g[i],g[n-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>((g[i].x-g[j].x)*f&lt;(g[j].x-g[k].x)*f) <span class="keyword">continue</span>;</span><br><span class="line">dp[i][j]=max(dp[i][j],dp[j][k]+g[i].score);</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;g[i].x&gt;&gt;g[i].score;</span><br><span class="line"></span><br><span class="line">sort(g+<span class="number">1</span>,g+n+<span class="number">1</span>);</span><br><span class="line">init();</span><br><span class="line">DP(<span class="number">1</span>);</span><br><span class="line">flip();</span><br><span class="line">init();</span><br><span class="line">DP(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，该形式可单调队列优化，优化到 $O(n^2)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N][N],ans=<span class="number">0</span>,last[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,score;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;g[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][i]=g[i].score,q[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(g[i],g[n-i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">q[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">last[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">last[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">while</span>(last[j]&amp;&amp;f*(g[i].x-g[j].x)&gt;=f*(g[j].x-g[last[j]].x)) &#123;</span><br><span class="line"><span class="keyword">while</span>(!q[j].empty()&amp;&amp;dp[j][last[j]]&gt;dp[j][q[j].back()]) q[j].pop_back();</span><br><span class="line">q[j].push_back(last[j]);</span><br><span class="line">last[j]--;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j]=dp[j][q[j].front()]+g[i].score;</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;g[i].x&gt;&gt;g[i].score;</span><br><span class="line"></span><br><span class="line">sort(g+<span class="number">1</span>,g+n+<span class="number">1</span>);</span><br><span class="line">init();</span><br><span class="line">DP(<span class="number">1</span>);</span><br><span class="line">flip();</span><br><span class="line">init();</span><br><span class="line">DP(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USACO </tag>
            
            <tag> 单调队列优化DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO05OPEN] Disease Manangement</title>
      <link href="/is-zxy.github.io/2020/06/08/%5BUSACO05OPEN%5D-Disease-Manangement/"/>
      <url>/is-zxy.github.io/2020/06/08/%5BUSACO05OPEN%5D-Disease-Manangement/</url>
      
        <content type="html"><![CDATA[<p>有 $N$ 牛，它们可能患有 $D$ 种病,现在从这些牛中选出若干头来，但选出来的牛患病的集合中不过超过 $K$ 种病。</p><p>求最多能选出多少头牛。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le D\le 15$</p><p>$1\le N\le 1000$</p><p>$1\le K\le D$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://darkbzoj.tk/problem/1688" target="_blank" rel="noopener">[USACO2005OPEN]Disease Manangement 疾病管理</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据病的种数，考虑对病进行状压。</p><p>于是可以预处理出每头牛的状态 $cow[i]$。</p><p>定义 $dp[state]$ 表示已选的牛状态为 $state$，最多选择的牛数。</p><p>那么显然</p><script type="math/tex; mode=display">dp[state|cow[i]]=\max(dp[state|cow[i]],dp[state]+1)</script><p>注意状态枚举从后向前（这种写法），避免重复选取。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN (1&lt;&lt;15)+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,k,cow[N],dp[MAXN],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) x-=lowbit(x),ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num,state=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">state|=(<span class="number">1</span>&lt;&lt;x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cow[i]=state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=tot<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) dp[j|cow[i]]=max(dp[j|cow[i]],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(get(i)&lt;=k) ans=max(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF327E] Axis Walking</title>
      <link href="/is-zxy.github.io/2020/06/07/%5BCF327E%5D-Axis-Walking/"/>
      <url>/is-zxy.github.io/2020/06/07/%5BCF327E%5D-Axis-Walking/</url>
      
        <content type="html"><![CDATA[<p>给你一个长度为 $n(1&lt;=n&lt;=24)$ 的正整数序列 $S$，再有 $k(0\le k\le 2)$ 个正整数。</p><p>求有多少种 $S$ 的排列方式使得其前缀和不会成为那 $k$ 个数里的任意一个。 答案对 $1e9+7$ 取模。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le a_i\le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF327E" target="_blank" rel="noopener">CF327E Axis Walking</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算是比较好想的状压DP了。</p><p>定义 $dp[state]$ 表示达到状态 $state$ 的方案数。</p><p>那么显然</p><script type="math/tex; mode=display">dp[state|2^j]=\sum_{j}\big(dp[state]+dp[2^j]\big)</script><p>于是可以得到这样的DP过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line">sum[i|(<span class="number">1</span>&lt;&lt;j)]=sum[i]+sum[<span class="number">1</span>&lt;&lt;j];</span><br><span class="line"><span class="keyword">if</span>(sum[i|(<span class="number">1</span>&lt;&lt;j)]==u[<span class="number">1</span>]||sum[i|(<span class="number">1</span>&lt;&lt;j)]==u[<span class="number">2</span>]) <span class="keyword">continue</span>;</span><br><span class="line">(dp[i|(<span class="number">1</span>&lt;&lt;j)]+=dp[i])%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交上去，TLE。</p><p>这个的时间复杂度为 $O(n2^n)$ 。</p><p>那么有没有办法优化点呢？</p><p>是有的。</p><p>这时不再采用这种“用目前推后面”的方式，而采用“用前面推目前”，这样就是枚举目前状态的子集，可以用<code>lowbit</code>达到 $\log n$实现，这样的时间复杂度 $O(2^n\log n)$。</p><p>然后再加上各种玄学卡常，开O2就过了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N+<span class="number">10</span>],u[<span class="number">3</span>],sum[(<span class="number">1</span>&lt;&lt;N)+<span class="number">10</span>],dp[(<span class="number">1</span>&lt;&lt;N)+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[<span class="number">1</span>&lt;&lt;i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;u[i];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line">sum[i]=sum[i&amp;~lowbit(i)]+sum[lowbit(i)];</span><br><span class="line"><span class="keyword">if</span>(sum[i]==u[<span class="number">1</span>]||sum[i]==u[<span class="number">2</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j-=lowbit(j)) dp[i]=(dp[i]+dp[i&amp;~lowbit(j)])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[tot<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/P2396" target="_blank" rel="noopener">[洛谷P2396] yyy loves Maths VII</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO13NOV] No Change G</title>
      <link href="/is-zxy.github.io/2020/06/07/%5BUSACO13NOV%5D-No-Change-G/"/>
      <url>/is-zxy.github.io/2020/06/07/%5BUSACO13NOV%5D-No-Change-G/</url>
      
        <content type="html"><![CDATA[<p>约翰到商场购物，他的钱包里有 $K(1 \le K \le 16)$ 个硬币，面值的范围是 $1\dots 100,000,000$。</p><p>约翰想按顺序买 $N$ 个物品 $(1 \le N \le 100,000)$，第 $i$ 个物品需要花费 $c(i)$ 块钱，$(1 \le c(i) \le 10,000)$。</p><p>在依次进行的购买 $N$ 个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。</p><p>请计算出在购买完 $N$ 个物品后，约翰最多剩下多少钱。如果无法完成购买，输出 $-1$。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3092" target="_blank" rel="noopener">[USACO13NOV]No Change G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题的状态设计有些巧妙。</p><p>定义 $dp[state]$ 表示在状态 $state$ 下，可以达到的最远的物品位置。其中状态即为硬币是否用过。</p><p>状态设计完之后，本题就比较好做了。显然</p><script type="math/tex; mode=display">dp[state|2^j]=\max\{dp[state]+maxn\}</script><p>其中 $maxn$ 为在 $dp[state]$ 之后的位置，用第 $j$ 个硬币最多能购买的物品数，这个显然可以前缀和+二分解决。</p><p>最后对于所有满足 $dp[state]=n$ 的状态中，取该状态下剩余硬币总面额最多的方案即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;K)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K,n,c[N],dp[MAXN],sum[MAXN],cost[MAXN],ans=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;i)&lt;tot) &#123;</span><br><span class="line"><span class="keyword">if</span>(!((<span class="number">1</span>&lt;&lt;i)&amp;x)) ans+=c[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;K&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;cost[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+cost[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;K;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=upper_bound(sum+<span class="number">1</span>,sum+n+<span class="number">1</span>,sum[dp[i]]+c[j])-sum<span class="number">-1</span>;</span><br><span class="line">dp[i|(<span class="number">1</span>&lt;&lt;j)]=max(dp[i|(<span class="number">1</span>&lt;&lt;j)],tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) <span class="keyword">if</span>(dp[i]==n) ans=max(ans,get(i));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SQOI2017] 小Q的棋盘</title>
      <link href="/is-zxy.github.io/2020/06/06/%5BSQOI2017%5D-%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98/"/>
      <url>/is-zxy.github.io/2020/06/06/%5BSQOI2017%5D-%E5%B0%8FQ%E7%9A%84%E6%A3%8B%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>小 Q 正在设计一种棋类游戏。</p><p>在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 $V$ 个格点，编号为 $0,1,2,\dots, V− 1$，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。</p><p>小 Q 现在想知道，当棋子从格点 $0$ 出发，移动 $N$ 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N,V\le 100$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3698" target="_blank" rel="noopener">[CQOI2017]小Q的棋盘</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>十分显然的贪心。</p><p>步数不够走最长链就走最长链，此时能经过 $N+1$ 个结点。</p><p>步数够走最长链，则先走其他链，然后<strong>走完</strong>最长链，这是很显然的，因为其他链上的边要走两次，一来一回，于是便可以考虑其他链上能走几个点。这样就是能经过 $V$ 与 $maxn+\dfrac{m-manx+1}{2}$ 的较小值。这里的式子意义为，先走其他链上的 $\dfrac{m-maxn+1}{2}$ 个点，然后再走最长链。但该式值可能大于 $V$ ，因此取 $\min$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],maxn=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">maxn=max(depth,maxn);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];~i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(m+<span class="number">1</span>&lt;=maxn) <span class="built_in">cout</span>&lt;&lt;m+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;min(n,maxn+(m-maxn+<span class="number">1</span>)/<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> SQOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2009] 毛毛虫</title>
      <link href="/is-zxy.github.io/2020/06/06/%5BHAOI2009%5D-%E6%AF%9B%E6%AF%9B%E8%99%AB/"/>
      <url>/is-zxy.github.io/2020/06/06/%5BHAOI2009%5D-%E6%AF%9B%E6%AF%9B%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p>对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。</p><p>现给定一棵 $N$ 个节点的树，求出最大的毛毛虫大小。</p><p><img src="https://wx2.sbimg.cn/2020/06/06/7967.jpg" alt="7967.jpg"></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 300000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3174" target="_blank" rel="noopener">[HAOI2009]毛毛虫</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>探索毛毛虫的节点该如何求。</p><p>模拟一番，可以发现如果毛毛虫的链上有 $x$ 个节点，这 $x$ 个节点的度之和为 $sum$，那么该毛毛虫的大小即为 $sum-x+2$。</p><p>于是可以转化为一个树的直径问题，只不过边权变为了点的度数。</p><p>两次 dfs 即可。</p><p>由于不知链上有多少个节点，可以将入度均初始化为 $-1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],maxn=<span class="number">0</span>,p,in[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;maxn) maxn=sum,p=root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].v!=f) dfs(edge[i].v,root,sum+in[edge[i].v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(in,<span class="number">-1</span>,<span class="keyword">sizeof</span>(in));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">in[u]++,in[v]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>,in[<span class="number">1</span>]);</span><br><span class="line">dfs(p,p,in[p]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m) <span class="built_in">cout</span>&lt;&lt;maxn+<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAOI </tag>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF855C] Helga Hufflepuff&#39;s Cup</title>
      <link href="/is-zxy.github.io/2020/06/03/%5BCF855C%5D-Helga-Hufflepuff-s-Cup/"/>
      <url>/is-zxy.github.io/2020/06/03/%5BCF855C%5D-Helga-Hufflepuff-s-Cup/</url>
      
        <content type="html"><![CDATA[<p>给出一棵节点数为 $n$ 的树，有 $m$ 种颜色，第 $k$ 种颜色是特殊颜色，树上最多有 $x$ 个特殊颜色点。</p><p>你需要把整个树染色，且保证特殊颜色节点以下条件：</p><ol><li><p>与其相连的不能有特殊颜色节点。</p></li><li><p>与其相连的节点的颜色序号必须小于 $k$。</p></li></ol><p>问有多少种满足要求的树。</p><p>答案 $\bmod 10^9+7$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 10^5$</p><p>$1\le m\le 10^9$</p><p>$1\le k\le m$</p><p>$1\le x\le 10$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF855C" target="_blank" rel="noopener">CF855C Helga Hufflepuff’s Cup</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实实际上颜色只分为三种</p><ol><li>能与 $k$ 连接，即比 $k$ 小。</li><li>等于 $k$。</li><li>不能与 $k$ 连接，即大于 $k$。</li></ol><p>于是便可以据此定义出状态。</p><p>定义 $dp[root][j][state]$ 表示以 $root$ 为根的子树中，有 $j$ 个颜色为 $k$ 的节点，节点 $root$ 的状态为 $state$ 的总方案数，其中 $state=0,1,2$，分别对应了上述三种情况。</p><p>于是显然</p><script type="math/tex; mode=display">dp[root][j][state]=\left\{\begin{aligned}&\sum_{v\in son(root)}(dp[v][l][0]+dp[v][l][1]+dp[v][l][2])\times dp[root][j-l][0] & &{state=0}\\&\sum_{v\in son(root)}dp[v][l][0]\times dp[root][j-l][1] & &{state=1}\\&\sum_{v\in son(root)}(dp[v][l][0]+dp[v][l][2])\times dp[root][j-l][2] & &{state=2}\end{aligned}\right.</script><p>为保证正确计数，需另开个 $tmp$ 数组用来转移，最终赋进 $dp$ 数组中。</p><p>最终答案即为（我选取了节点 $1$ 为整个树的根）</p><script type="math/tex; mode=display">\sum_{i=0}^x\sum_{j=0}^2dp[1][i][j]</script><p>注意取模与<code>long long</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,x,tot=<span class="number">0</span>,head[N],cnt[N];</span><br><span class="line">ll dp[N][<span class="number">20</span>][<span class="number">3</span>],tmp[<span class="number">20</span>][<span class="number">3</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">dp[root][<span class="number">0</span>][<span class="number">0</span>]=k<span class="number">-1</span>;</span><br><span class="line">dp[root][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dp[root][<span class="number">0</span>][<span class="number">2</span>]=m-k;</span><br><span class="line">cnt[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">cnt[root]=min(cnt[v]+cnt[root],x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[root];j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=min(j,cnt[v]);l++) &#123;</span><br><span class="line">(tmp[j][<span class="number">0</span>]+=(dp[v][l][<span class="number">0</span>]+dp[v][l][<span class="number">1</span>]+dp[v][l][<span class="number">2</span>])%mod*dp[root][j-l][<span class="number">0</span>]%mod)%=mod;</span><br><span class="line">(tmp[j][<span class="number">1</span>]+=dp[v][l][<span class="number">0</span>]%mod*dp[root][j-l][<span class="number">1</span>]%mod)%=mod;</span><br><span class="line">(tmp[j][<span class="number">2</span>]+=(dp[v][l][<span class="number">0</span>]+dp[v][l][<span class="number">2</span>])%mod*dp[root][j-l][<span class="number">2</span>]%mod)%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cnt[root];j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++) dp[root][j][l]=tmp[j][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cnt[<span class="number">1</span>];i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) (ans+=dp[<span class="number">1</span>][i][j])%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF161D] Distance in Tree</title>
      <link href="/is-zxy.github.io/2020/06/03/%5BCF161D%5D-Distance-in-Tree/"/>
      <url>/is-zxy.github.io/2020/06/03/%5BCF161D%5D-Distance-in-Tree/</url>
      
        <content type="html"><![CDATA[<p>给出一棵节点数为 $n$ 的树，每条边边权为 $1$，求两点之间路径长度为 $k$ 的点对数量。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50000$</p><p>$1\le k\le 500$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF161D" target="_blank" rel="noopener">CF161D Distance in Tree</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DP思路与<a href="https://www.luogu.com.cn/problem/P3047" target="_blank" rel="noopener">[USACO12FEB]Nearby Cows G</a>较为类似。</p><p>以节点 $1$ 为根进行DP。</p><p>定义 $dp[root][k]$ 表示以 $root$ 为根的子树中，距离 $root$ 为 $k$ 的点的数量。</p><p>易得</p><script type="math/tex; mode=display">dp[root][k]=\sum_{v\in son(root)}dp[v][k-1]</script><p>这个预处理完后，直接求每个点距离其长为 $k$ 的点的个数即可。</p><p>那么考虑如何算出这个数量。</p><p>对于一个点 $v$，定义其第 $i$ 个祖先为 $root_i$，那么答案即为，除以 $2$ 的原因为每个点都被算了两次。</p><script type="math/tex; mode=display">\dfrac{dp[1][k]+\sum_{v=1}^n\sum_{i=1}^d\Big(dp[root_i][k-i]-dp[v][k-d-1]\Big)}{2}</script><p>注意特判 $k-d-1&lt;0$ 的情况，此时直接加 $dp[root_i][k-i]$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,tot=<span class="number">0</span>,head[N],fa[N];</span><br><span class="line">ll dp[N][<span class="number">510</span>],df[N][<span class="number">510</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">dp[root][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">fa[root]=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) dp[root][j]+=dp[v][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ans+=dp[<span class="number">1</span>][k];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ans+=dp[i][k];</span><br><span class="line"><span class="keyword">int</span> root=fa[i],v=i,d=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(root!=<span class="number">0</span>&amp;&amp;k&gt;=d) &#123;</span><br><span class="line">ans+=dp[root][k-d]-(k-d==<span class="number">0</span>?<span class="number">0</span>:dp[v][k-d<span class="number">-1</span>]);</span><br><span class="line">v=root;</span><br><span class="line">root=fa[root];</span><br><span class="line">d++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans/=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Baltic2003] Gem</title>
      <link href="/is-zxy.github.io/2020/06/02/%5BBaltic2003%5D-Gem/"/>
      <url>/is-zxy.github.io/2020/06/02/%5BBaltic2003%5D-Gem/</url>
      
        <content type="html"><![CDATA[<p>给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数，唯一的限制条件是相临的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 10000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://darkbzoj.tk/problem/1369" target="_blank" rel="noopener">[Baltic2003]Gem</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很好想的DP。但是权值的最大取值不知。</p><p>随便开到了 $15$ 过了。</p><p>然后看了题解，有一个结论：节点数为 $n$的树，对其染色使相邻节点颜色不同，且总颜色权值最小，所需的颜色数量是 $O(\log n)$ 的。但是并没有看到有证明。</p><p>定义 $dp[root][i]$ 表示以 $root$ 为根的子树，当 $root$ 的权值为 $i$ 时，该子树的最小总价值。</p><p>显然 </p><script type="math/tex; mode=display">dp[root][i]=\sum_{v\in son(root)}\min_{j=1,j\not=i}^{\log n}\{dp[v][j]\}</script><p>直接搞就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,head[N],dp[N][<span class="number">20</span>],ans=INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++) dp[root][i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> minn=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">15</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">minn=min(minn,dp[v][j]);</span><br><span class="line">&#125;</span><br><span class="line">dp[root][i]+=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++) ans=min(ans,dp[<span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Baltic </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO12FEB] Nearby Cows G</title>
      <link href="/is-zxy.github.io/2020/05/31/%5BUSACO12FEB%5D-Nearby-Cows-G/"/>
      <url>/is-zxy.github.io/2020/05/31/%5BUSACO12FEB%5D-Nearby-Cows-G/</url>
      
        <content type="html"><![CDATA[<p>给你一棵 $n$ 个点的树，每个点 $i$ 带权 $c_i$，对于每个节点求出距离它不超过 $k$ 的所有节点权值和 $m_i$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n \le 10^5$</p><p>$1\le k\le 20$</p><p>$0\le c_i\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3047" target="_blank" rel="noopener">[USACO12FEB]Nearby Cows G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然的换根解决嘛。</p><p>定义 $dp[root][j]$ 表示以 $root$ 为根的子树中距离 $root$ 不超过 $j$ 的所有点权值之和。</p><p>易得</p><script type="math/tex; mode=display">dp[root][j]=\sum_{v\in son(root)}dp[v][j-1]</script><p>其中</p><script type="math/tex; mode=display">dp[root][0]=c[root]</script><p>定义 $df[root][j]$ 表示<strong>整棵树</strong>上距离点 $root$ 不超过 $j$ 的所有点权值之和。</p><p>对于点 $root$ 的每个子节点 $v$ 显然有</p><script type="math/tex; mode=display">df[v][j]=dp[v][j]+df[root][j-1]-dp[v][j-2]</script><p>其中</p><script type="math/tex; mode=display">df[v][0]=c[v] \\df[v][1]=dp[v][1]+c[root]</script><p>最后输出每个点 $i$ 的 $df[i][k]$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,c[N],head[N],tot=<span class="number">0</span>,dp[N][<span class="number">25</span>],df[N][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_first</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) dp[root][i]=c[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs_first(v,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) dp[root][j]+=dp[v][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_second</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">df[v][<span class="number">0</span>]=dp[v][<span class="number">0</span>];</span><br><span class="line">df[v][<span class="number">1</span>]=dp[v][<span class="number">1</span>]+c[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++) df[v][j]=dp[v][j]+df[root][j<span class="number">-1</span>]-dp[v][j<span class="number">-2</span>];</span><br><span class="line">dfs_second(v,root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"></span><br><span class="line">dfs_first(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) df[<span class="number">1</span>][i]=dp[<span class="number">1</span>][i];</span><br><span class="line">dfs_second(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;df[i][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 二次扫描与换根法 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO10MAR]Great Cow Gathering G</title>
      <link href="/is-zxy.github.io/2020/05/30/%5BUSACO10MAR%5D-Great-Cow-Gathering-G/"/>
      <url>/is-zxy.github.io/2020/05/30/%5BUSACO10MAR%5D-Great-Cow-Gathering-G/</url>
      
        <content type="html"><![CDATA[<p>Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。</p><p>每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。</p><p>在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 10^5$</p><p>$1\le A_i\le B_i\le N$</p><p>$0\le C_i,L_i\le 10^3$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2986" target="_blank" rel="noopener">Great Cow Gathering G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二次扫描与换根法。</p><p>先任意选一根。</p><p>定义 $dp[root]$ 表示以 $root$ 为根的子树中所有的奶牛到达点 $root$ 的总路程。</p><p>显然</p><script type="math/tex; mode=display">dp[root]=\sum_{j\in son(root)}dp[v]+cnt[v]\times w(root,v)</script><p>其中 $cnt[v]$ 表示以 $v$ 为根的子树的奶牛数。</p><p>接下来考虑如何推出其他点作为整个树的根时的总路程。</p><p>定义 $dis[root]$ 表示点 $root$ 作为整个树的根时的总路程。</p><p>动手模拟模拟，易推得对于 $root$ 的子节点 $v$，有</p><script type="math/tex; mode=display">dis[v]=dis[root]-cnt[v]\times w(root,v)+(num-cnt[v])\times w(root,v)</script><p>其中 $num$ 表示奶牛的总数量。</p><p>据此求出 $dis$ 后，输出</p><script type="math/tex; mode=display">\min_{i=1}^Ndis[i]</script><p>即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,tot=<span class="number">0</span>,head[N];</span><br><span class="line">ll c[N],dp[N],cnt[N],dis[N],ans,num=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line">ll v,next;</span><br><span class="line">ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_first</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">cnt[root]=c[root];</span><br><span class="line">num+=c[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs_first(v,root);</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line">dp[root]+=dp[v]+cnt[v]*w;</span><br><span class="line">cnt[root]+=cnt[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_second</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">ans=min(ans,dis[root]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line">dis[v]=dis[root]-cnt[v]*w+(num-cnt[v])*w;</span><br><span class="line">dfs_second(v,root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">ll w;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs_first(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ans=dis[<span class="number">1</span>]=dp[<span class="number">1</span>];</span><br><span class="line">dfs_second(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 二次扫描与换根法 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2008] STA-Station</title>
      <link href="/is-zxy.github.io/2020/05/30/%5BPOI2008%5D-STA-Station/"/>
      <url>/is-zxy.github.io/2020/05/30/%5BPOI2008%5D-STA-Station/</url>
      
        <content type="html"><![CDATA[<p>给出一个 $N$ 个点的树，找出一个点来，以这个点为根的树时，所有点的深度之和最大。</p><p>当有多个点满足条件时，输出最小的那个点。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N\le 10^6$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3478" target="_blank" rel="noopener">[POI2008]STA-Station</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然可以用二次扫描与换根法解决。</p><p>定义 $dp[root]$ 表示以 $root$ 为根的子树上的所有点的深度之和。</p><p>先以节点 $1$ 为根，预处理每个点 $i$ 的深度 $depth[i]$ 以及 以点 $i$ 为根的子树的节点个数 $cnt[i]$。</p><p>于是我们易得</p><script type="math/tex; mode=display">dp[root]=detph[root]+\sum_{v\in son(root)}dp[v]</script><p>定义 $df[root]$ 表示以 $root$ 为根的<strong>整个树</strong>上所有点的深度之和。</p><p>对于每个点 $root$ 的子节点 $v$，可以将这整个树拆分成两部分来看：</p><ol><li>节点 $v$ 上面的部分。</li><li>节点 $v$ 以及节点 $v$ 下面的部分。</li></ol><p>第二部分在以 $v$ 为根时的深度之和是很好求的，显然为</p><script type="math/tex; mode=display">dp[v]-cnt[v]\times depth[v]</script><p>第一部分就得思考思考了。不过仔细推推的话，可以推出为</p><script type="math/tex; mode=display">df[root]-\big(dp[v]-cnt[v]\times detph[root]\big)+n-cnt[v]</script><p>思路可以从以 $root$ 为根的<strong>整个树</strong>，减去以 $v$ 为根的<strong>子树</strong>，剩余的部分上进行考虑。</p><p>那么</p><script type="math/tex; mode=display">\begin{align}df[v]&= dp[v]-cnt[v]\times depth[v]+df[root]-\big(dp[v]-cnt[v]\times depth[root]\big)+n-cnt[v] \\&= cnt[v]\times\big(depth[root]-depth[v]\big)+df[root]+n-cnt[v] \\&= df[root]+n-2\times cnt[v]\end{align}</script><p>据此转移即可。</p><p>答案 $ans$ 即为</p><script type="math/tex; mode=display">\max_{i=1}^N df[ans]</script><p>但注意多解时输出最小的节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>,head[N];</span><br><span class="line">ll depth[N],dp[N],cnt[N],df[N],maxn=<span class="number">0</span>,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_first</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">cnt[root]=<span class="number">1</span>;</span><br><span class="line">depth[root]=depth[f]+<span class="number">1</span>;</span><br><span class="line">dp[root]=depth[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs_first(v,root);</span><br><span class="line">cnt[root]+=cnt[v];</span><br><span class="line">dp[root]+=dp[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_second</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(df[root]&gt;maxn||(df[root]==maxn&amp;&amp;root&lt;ans)) maxn=df[root],ans=root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">df[v]=df[root]+n<span class="number">-2</span>*cnt[v];</span><br><span class="line">dfs_second(v,root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs_first(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">df[<span class="number">1</span>]=dp[<span class="number">1</span>];</span><br><span class="line">dfs_second(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> POI </tag>
            
            <tag> 二次扫描与换根法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ3585] Accumulation Degree</title>
      <link href="/is-zxy.github.io/2020/05/29/%5BPOJ3585%5D-Accumulation%20Degree/"/>
      <url>/is-zxy.github.io/2020/05/29/%5BPOJ3585%5D-Accumulation%20Degree/</url>
      
        <content type="html"><![CDATA[<p>有一个树形的水系，由 $N-1$ 条河道和 $N$ 个交叉点组成。</p><p>我们可以把交叉点看作树中的节点，编号为 $1\sim N$，河道则看作树中的无向边。</p><p>每条河道都有一个容量，连接 $x$ 与 $y$ 的河道的容量记为 $c(x,y)$。</p><p>河道中单位时间流过的水量不能超过河道的容量。</p><p>有一个节点是整个水系的发源地，可以源源不断地流出水，我们称之为源点。</p><p>除了源点之外，树中所有度数为 $1$ 的节点都是入海口，可以吸收无限多的水，我们称之为汇点。</p><p>也就是说，水系中的水从源点出发，沿着每条河道，最终流向各个汇点。</p><p>在整个水系稳定时，每条河道中的水都以单位时间固定的水量流向固定的方向。</p><p>除源点和汇点之外，其余各点不贮存水，也就是流入该点的河道水量之和等于从该点流出的河道水量之和。</p><p>整个水系的流量就定义为源点单位时间发出的水量。</p><p>在流量不超过河道容量的前提下，求哪个点作为源点时，整个水系的流量最大，输出这个最大值。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N\le 2\times 10^5$ </p><p>$Ans\le 2^{31}-1$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://poj.org/problem?id=2228" target="_blank" rel="noopener"><strong>Accumulation Degree</strong></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义 $dp[root]$ 表示以 $root$ 为根的子树，$root$ 的最大出水量。</p><p>对于 $root$ 的一个子节点 $v$，易得</p><script type="math/tex; mode=display">\begin{equation}dp[root]=\sum_{v\in son(root)}\left\{\begin{aligned}&\min\left(dp[v],c(root,v)\right)& & {v的度大于1}\\&c(root,v)& & {v的度等于1}\end{aligned}\right.\end{equation}</script><p>这样就可以求出我们所选定的 $root$ 的最大流量。</p><p>但题目的根是不定的，且对于每个根，最大流量都不同。</p><p>于是显然有一个 $O(N^2)$ 的算法，即对每个点都将其作为根进行一次DP。</p><p>考虑优化。</p><p>有没有办法，只进行一次DP，而由这一次的DP值，推出其他点作为根的最大流量呢？</p><p>是有的。</p><p>定义 $f[root]$ 表示整个树以 $root$ 为根的最大流量。</p><p>显然，对于第一次DP选择根 $r$，有 </p><script type="math/tex; mode=display">f[r]=dp[r]</script><p>观察这样的一颗树，第一次选择以节点 $1$ 为根来进行DP（边权未画出）。</p><p><img src="https://wx1.sbimg.cn/2020/05/30/graph.png" alt="graph.png"></p><p>那么要求节点 $2$ 为根的最大流量，可以想象一下，把树转过来</p><p><img src="https://wx1.sbimg.cn/2020/05/30/graph-1.png" alt="graph-1.png"></p><p>有三个子树，分别以节点 $5,6,1$ 为根。根节点分管到以 $5,6$ 节点为根的子树时的最大流量是已知的，即为 $dp[2]$。因此这个树被分为了两部分</p><p><img src="https://wx2.sbimg.cn/2020/05/30/graph-1_WPS.png" alt="graph-1_WPS.png"></p><p>那么要求出 $f[2]$，可以类比上面DP的状态转移方程，即求出以 $1$ 为根的<strong>子树</strong>的最大流量，这个也是很好求的，即为</p><script type="math/tex; mode=display">f[1]-\min(dp[2],c(1,2))</script><p>那么</p><script type="math/tex; mode=display">f[2]=dp[2]+\min\bigg(f[1]-\min\big(dp[2],c(1,2)\big),c(1,2)\ \bigg)</script><p>根据此思路推得其他节点的 $f$ 值即可，注意要考虑特殊情况——其父节点 $root$ 的度为 $1$。</p><script type="math/tex; mode=display">\begin{equation}f[v]=dp[v]+\left\{\begin{aligned}&\min\bigg(f[root]-\min\big(dp[v],c(root,v)\big),c(root,v)\bigg)& & {v的度大于1}\\&c(root,v)& & {v的度等于1}\end{aligned}\right.\end{equation}</script><p>答案即为</p><script type="math/tex; mode=display">\max_{i=1}^nf[i]</script><p>此法名曰：二次扫描与换根法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,head[N],tot,cnt[N];</span><br><span class="line">ll dp[N],f[N],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_first</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line">cnt[root]++;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs_first(v,root);</span><br><span class="line">&#125;</span><br><span class="line">dp[root]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(cnt[v]==<span class="number">1</span>) dp[root]+=w;</span><br><span class="line"><span class="keyword">else</span> dp[root]+=min(dp[v],w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_second</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">ans=max(ans,f[root]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(cnt[root]==<span class="number">1</span>) f[v]=dp[v]+w;</span><br><span class="line"><span class="keyword">else</span> f[v]=dp[v]+min(f[root]-min(dp[v],w),w);</span><br><span class="line">dfs_second(v,root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line">ll w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs_first(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">f[<span class="number">1</span>]=dp[<span class="number">1</span>];</span><br><span class="line">dfs_second(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 二次扫描与换根法 </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2003] 加分二叉树</title>
      <link href="/is-zxy.github.io/2020/05/29/%5BNOIP2003%5D-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/is-zxy.github.io/2020/05/29/%5BNOIP2003%5D-%E5%8A%A0%E5%88%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>设一个 $n$ 个节点的二叉树 $tree$ 的中序遍历为 $(1,2,3,\dots,n)$，其中数字 $1,2,3,\dots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$, $tree$ 及它的每个子树都有一个加分，任一棵子树 $subtree$（也包含 $tree$ 本身）的加分计算方法如下：</p><p>$subtree$ 的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。</p><p>若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p><p>试求一棵符合中序遍历为 $(1,2,3,\dots,n)$ 且加分最高的二叉树 $tree$。要求输出；</p><p>（1）$tree$ 的最高加分</p><p>（2）$tree$ 的前序遍历</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 30$</p><p>$Ans\le 4,000,000,000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1040" target="_blank" rel="noopener">加分二叉树</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题目要求，很容易想到如何定义状态。</p><p>定义 $dp[l][r]$ 表示包含第 $l$ 个到第 $r$ 个点的子树的最大加分。</p><p>由中序遍历的性质，容易想到枚举根节点，因而转化为一个区间DP问题。</p><p>即</p><script type="math/tex; mode=display">dp[l][r]=\max\{dp[l][k-1]\times dp[k+1][r]+score[k]\},k\in[l,r]</script><p>初始化 $dp$ 为 $1$，$dp[i][i]=1$。</p><p>这样，最终答案即为 $dp[1][n]$。</p><p>于是subtask1就解决了。</p><p>考虑subtask2，想到可以在DP过程中记录最优的转移点 $g[l][r]=k$，即 $k$ 点为 $l$ 点到 $r$ 点这个子树的根。</p><p>然后据此递归输出前序遍历即可。</p><p>注意初始化 $g[i][i]=i$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll score[N],dp[N][N],g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n+<span class="number">1</span>;j++) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=score[i],g[i][i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> root=g[l][r];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=root<span class="number">-1</span>) print(l,root<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(root+<span class="number">1</span>&lt;=r) print(root+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;score[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]&lt;dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+score[k]) dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+score[k],g[i][j]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">print(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通#1772] 动漫排序</title>
      <link href="/is-zxy.github.io/2020/05/28/%5B%E4%B8%80%E6%9C%AC%E9%80%9A-1772%5D-%E5%8A%A8%E6%BC%AB%E6%8E%92%E5%BA%8F/"/>
      <url>/is-zxy.github.io/2020/05/28/%5B%E4%B8%80%E6%9C%AC%E9%80%9A-1772%5D-%E5%8A%A8%E6%BC%AB%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>小 $W$ 最近迷上了日本动漫，每天都有无数部动漫的更新等着他去看，所以他必须将所有的动漫排个顺序，当然，虽然有无数部动漫，但除了 $1$ 号动漫，每部动漫都有且仅有一部动漫是它的前传（父亲），也就是说，所有的动漫形成一个树形结构。而动漫的顺序必须满足以下两个限制：</p><p>①一部动漫的所有后继（子孙）都必须排在它的后面。</p><p>②对于同一部动漫的续集（孩子），小 $W$ 喜爱度高的须排在前面。</p><p>光排序小 $W$ 还不爽，他想知道一共有多少种排序方案，并且输出它 $\mod10007$的答案。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1772" target="_blank" rel="noopener">[一本通#1772]动漫排序</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><del>这其实是个组合数学题</del></p><p>定义 $dp[root]$ 表示以 $root$ 为根的子树的排序数。</p><p>定义 $cnt[i]$ 表示以 $i$ 为根的子树的节点数量。</p><p>考虑 $root$ 的第一个儿子 $son_1$。</p><p>除去点 $root$ 与点 $son_1$（$son_1$ 位置固定了，因为只有 $son_1$ 被选中，其子树才有可能被选中），则该子树剩余的 $cnt[son_1]-1$ 个节点在总序列中的位置有</p><script type="math/tex; mode=display">\binom{cnt[root]-2}{cnt[son]-1}</script><p>种</p><p>那么由乘法原理可得</p><script type="math/tex; mode=display">dp[root]*=dp[son_1]*\binom{cnt[root]-2}{cnt[son]-1}</script><p>考虑 $root$ 的第二个儿子 $son_2$。</p><p>除去点 $root$ 与 $son_1$ 为根的子树与 $son_2$，则该子树剩余的 $cnt[son_2]-1$ 个节点在总序列中的位置有</p><script type="math/tex; mode=display">\binom{cnt[root]-cnt[son_1]-2}{cnt[son_2]-1}</script><p>种</p><p>那么同理由乘法原理可得</p><script type="math/tex; mode=display">dp[root]*=dp[son_2]*\binom{cnt[root]-cnt[son_1]-2}{cnt[son_2]-1}</script><p>………………………………</p><p>据此，可得</p><script type="math/tex; mode=display">dp[root]=\prod_{i=1}^{tot_{root}}dp[son_i]\times\binom{cnt[root]-2-\sum_\limits{j=1}^{i-1}cnt[j]}{cnt[son_i]-1}</script><p>因此预处理组合数后直接DP即可。</p><p><del>不取模见祖宗</del>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 10007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,cnt[N];</span><br><span class="line">ll dp[N],C[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++) C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">dp[root]=cnt[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> size=son[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">dfs(son[root][i]);</span><br><span class="line">cnt[root]+=cnt[son[root][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num=cnt[root]<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">(dp[root]*=(dp[son[root][i]]*C[num][cnt[son[root][i]]<span class="number">-1</span>])%p)%=p;</span><br><span class="line">num-=cnt[son[root][i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">son[i].clear();</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tot;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">son[i].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 一本通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2015] 树上染色</title>
      <link href="/is-zxy.github.io/2020/05/27/%5BHAOI2015%5D-%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/"/>
      <url>/is-zxy.github.io/2020/05/27/%5BHAOI2015%5D-%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将染成黑色，并将其他 的 $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$0\le n,k\le 2000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3177" target="_blank" rel="noopener">[HAOI2015]树上染色</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始的想法是定义 $dp[root][i]$ 表示以 $root$ 为根的子树，选择 $i$ 个点染成黑色的最大受益值。</p><p>然后……发现不好转移。</p><p>然后……就不会做了，毫无头绪。</p><p>然后……就打开了题解。</p><p>发现了这题与NOI ONLINE第二场提高组的T2的思想是相似的。</p><p>由于求的是<strong>所有同色点两两之间的距离和</strong>，于是想到计算每条边的<strong>贡献</strong>。</p><p>显然，对于每条边的贡献 $val$，其值为一边的子树上白点个数 $w_1$，黑点个数 $b_1$，另一边子树上白点个数 $w_2$，黑点个数 $b_2$，$val=(w_1<em>w_2+b_1</em>b_2)*W$，其中 $W$ 为边权值。</p><p>于是定义 $dp[root][i]$ 表示以 $root$ 为根的子树，选择 $i$ 个点染成黑色的对答案的<strong>最大贡献</strong>。</p><p>于是就转化为一个树上背包问题，即</p><script type="math/tex; mode=display">dp[root][i]=\max\{dp[v][j]+dp[root][i-j]+val\},v\in son(root)</script><p>定义以 $v$ 为根的子树的节点数为 $cnt[v]$。</p><p>那么该式子中的 $val$ 即为 $\left[j\times (k-j)+(cnt[v]-j)\times(n-k-cnt[v]+j)\right]\times W$，$W$ 为边权。</p><p>初始化 $dp$ 为 $-1$，对于每个点 $root$， $dp[root][0]=dp[root][1]=0$。</p><p>不合法状态不能用来转移，因此需要判断是否为 $-1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,tot=<span class="number">0</span>,head[N],cnt[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">cnt[root]=<span class="number">1</span>;</span><br><span class="line">dp[root][<span class="number">0</span>]=dp[root][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];~i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v,w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line">cnt[root]+=cnt[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=min(cnt[root],p);j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(cnt[v],j);k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[root][j-k]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">ll val=(ll)(k*(p-k)+(cnt[v]-k)*(ll)(n-cnt[v]-p+k))*(ll)w;</span><br><span class="line">dp[root][j]=max(dp[root][j],dp[root][j-k]+dp[v][k]+val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;p);</span><br><span class="line"><span class="keyword">if</span>(p&gt;n-p) p=n-p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[<span class="number">1</span>][p]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这个代码过不了最新添加的一个数据。</p><p><a href="https://sbimg.cn/image/kCK91" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/05/29/1.png" alt="1.png"></a></p><p>于是将 <code>dfs</code> 函数改成以下形式即可完美AC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">cnt[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=cnt[root];j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=cnt[v];k&gt;=<span class="number">0</span>;k--) &#123;</span><br><span class="line">ll val=(p-k)*k*w+(n-p+k-cnt[v])*(cnt[v]-k)*w;</span><br><span class="line">dp[root][j+k]=max(dp[root][j+k],dp[root][j]+dp[v][k]+val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cnt[root]+=cnt[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,tot=<span class="number">0</span>,head[N],cnt[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">cnt[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line">ll w=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=cnt[root];j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=cnt[v];k&gt;=<span class="number">0</span>;k--) &#123;</span><br><span class="line">ll val=(p-k)*k*w+(n-p+k-cnt[v])*(cnt[v]-k)*w;</span><br><span class="line">dp[root][j+k]=max(dp[root][j+k],dp[root][j]+dp[v][k]+val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cnt[root]+=cnt[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;p);</span><br><span class="line"><span class="keyword">if</span>(p&gt;n-p) p=n-p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[<span class="number">1</span>][p]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> HAOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO17DEC] Barn Painting G</title>
      <link href="/is-zxy.github.io/2020/05/27/%5BUSACO17DEC%5D-Barn-Painting-G/"/>
      <url>/is-zxy.github.io/2020/05/27/%5BUSACO17DEC%5D-Barn-Painting-G/</url>
      
        <content type="html"><![CDATA[<p>给定一颗 $N$ 个节点组成的树，$3$ 种颜色，其中 $K$ 个节点已染色，要求任意两相邻节点颜色不同，求合法染色方案数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le K\le N\le 10^5$</p><p>颜色用 $1,2,3$ 表示。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4084" target="_blank" rel="noopener">Barn Painting G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动手模拟一遍，便会发现其实就是一个简单的组合问题，加乘法原理嘛。</p><p>定义 $dp[root][color]$ 表示以 $root$ 节点为根，$root$节点颜色为 $color$ 时，该树的总染色方案数。</p><p>显然</p><script type="math/tex; mode=display">dp[root][color]=\prod_{v\in son(root)}\sum_{j=1}^3dp[v][j](j\not=color)</script><p>对于所有的节点 $i$，其初值赋为$dp[i][1]=dp[i][2]=dp[i][3]=1$。</p><p>但是题目中提前将 $K$ 个节点染好了颜色 $color_i$，因此这 $K$ 个节点除了 $dp[i][color_i]=1$，其余均为 $0$。</p><p>DP的过程中也需要注意，如果子节点已经被染好了色 $color$，则父节点对应的 $dp[root][color]$ 要归零，因为<strong>任意两相邻节点颜色不同</strong>。</p><p><del>不取模不开<code>long long</code>见祖宗</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,tot=<span class="number">0</span>,head[N],color[N];</span><br><span class="line">ll dp[N][<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i]) &#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dp[i][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">dp[i][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[i][color[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">if</span>(color[v]) dp[root][color[v]]=<span class="number">0</span>;</span><br><span class="line">(dp[root][<span class="number">1</span>]*=(dp[v][<span class="number">2</span>]+dp[v][<span class="number">3</span>])%mod)%=mod;</span><br><span class="line">(dp[root][<span class="number">2</span>]*=(dp[v][<span class="number">1</span>]+dp[v][<span class="number">3</span>])%mod)%=mod;</span><br><span class="line">(dp[root][<span class="number">3</span>]*=(dp[v][<span class="number">1</span>]+dp[v][<span class="number">2</span>])%mod)%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p&gt;&gt;c;</span><br><span class="line">color[p]=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((dp[<span class="number">1</span>][<span class="number">1</span>]+dp[<span class="number">1</span>][<span class="number">2</span>])%mod+dp[<span class="number">1</span>][<span class="number">3</span>])%mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ2631] Roads in the North</title>
      <link href="/is-zxy.github.io/2020/05/27/%5BPOJ2631%5D-Roads-in-the-North/"/>
      <url>/is-zxy.github.io/2020/05/27/%5BPOJ2631%5D-Roads-in-the-North/</url>
      
        <content type="html"><![CDATA[<p>输入一棵带边权的树，求这棵树的直径。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>节点数不超过 $10000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://vjudge.net/problem/POJ-2631/origin" target="_blank" rel="noopener"><strong>Roads in the North</strong></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的直径板子。</p><p>有两种方法。</p><ol><li>两次搜索。第一次随便找一点 $S$，从 $S$ 开始搜索，搜出距离 $S$ 最远的点 $P$。第二次从 $P$ 开始搜，搜出距离 $P$ 最远的点 $Q$。$PQ$ 的距离即为树的直径。</li><li>树形DP。距离根最远的点为 $P$，次远的点为 $Q$，$PQ$即为经过该根的最长链。因此用DP搞出以每个点为根的最远距离与次远距离，求经过每个点的最长链取最大值即可。</li></ol><h3 id="代码（搜索）"><a href="#代码（搜索）" class="headerlink" title="代码（搜索）"></a>代码（搜索）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v,w,tot=<span class="number">0</span>,head[N],ans=<span class="number">0</span>,dis[N],fn=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[root]&gt;ans) &#123;</span><br><span class="line">ans=dis[root];</span><br><span class="line">fn=root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v==f) <span class="keyword">continue</span>;</span><br><span class="line">dis[edge[i].v]=dis[root]+edge[i].w;</span><br><span class="line">dfs(edge[i].v,root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dis[fn]=<span class="number">0</span>;</span><br><span class="line">dfs(fn,fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w) &#123;</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find();</span><br><span class="line">find();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（树形DP）"><a href="#代码（树形DP）" class="headerlink" title="代码（树形DP）"></a>代码（树形DP）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v,w,tot=<span class="number">0</span>,head[N],dp[N][<span class="number">2</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].v,w=edge[i].w;</span><br><span class="line">dfs(v,root);</span><br><span class="line"><span class="keyword">if</span>(dp[root][<span class="number">0</span>]&lt;dp[v][<span class="number">0</span>]+w) dp[root][<span class="number">1</span>]=dp[root][<span class="number">0</span>],dp[root][<span class="number">0</span>]=dp[v][<span class="number">0</span>]+w;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dp[root][<span class="number">1</span>]&lt;dp[v][<span class="number">0</span>]+w) dp[root][<span class="number">1</span>]=dp[v][<span class="number">0</span>]+w;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,dp[root][<span class="number">1</span>]+dp[root][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w) &#123;</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 树的直径 </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CTSC1997] 选课</title>
      <link href="/is-zxy.github.io/2020/05/25/%5BCTSC1997%5D-%E9%80%89%E8%AF%BE/"/>
      <url>/is-zxy.github.io/2020/05/25/%5BCTSC1997%5D-%E9%80%89%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 300$</p><p>$1\le M\le 300$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2014" target="_blank" rel="noopener">[CTSC1997]选课</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，本题所有的课程构成了一个森林，因为每个课程最多只有一个先修课。</p><p>于是可以构造一个“虚根”0，这样把森林转化为一颗树，就可以像普通的树形dp那样搞了。</p><p>定义 $dp[root][i]$ 表示以 $root$ 节点为根的子树中，选择 $i$ 个课程的最大学分。</p><p>实际上就是一个树上的分组背包。</p><script type="math/tex; mode=display">dp[root][i]=\max\limits_{s\in son_{root}}\{dp[root][j-k]+dp[s][k]\},j\in[0,m],k\le j</script><p>不过最后还需要加上目前的根的学分，即倒序，然后 $dp[root][i]=dp[root][i-1]+score[root]$。</p><p>最后输出 $dp[0][m]$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,score[N],dp[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=son[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">dfs(son[root][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=j;k++) &#123;</span><br><span class="line">dp[root][j]=max(dp[root][j],dp[root][j-k]+dp[son[root][i]][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root) <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--) dp[root][i]=dp[root][i<span class="number">-1</span>]+score[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">son[x].push_back(i);</span><br><span class="line">score[i]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> CTSC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IOI2007]Miners 矿工配餐</title>
      <link href="/is-zxy.github.io/2020/05/24/%5BIOI2007%5D-Miners-%E7%9F%BF%E5%B7%A5%E9%85%8D%E9%A4%90/"/>
      <url>/is-zxy.github.io/2020/05/24/%5BIOI2007%5D-Miners-%E7%9F%BF%E5%B7%A5%E9%85%8D%E9%A4%90/</url>
      
        <content type="html"><![CDATA[<p>现有两个煤矿，每个煤矿都雇用一组矿工。采煤工作很辛苦，所以矿工们需要良好饮食。每当一辆食品车到达煤矿时，矿工们便会产出一定数量的煤。</p><p>有三种类型的食品车：肉车，鱼车和面包车。 矿工们喜欢变化的食谱。如果提供的食品能够不断变化，他们的产煤量将会增加。每当一个新的食品车到达煤矿时，矿工们就会比较这种新的食品和前两次（或者少于两次，如果前面运送食品的次数不足两次）的食品，并且：</p><ul><li>如果这几次食品车都是同一类型的食品，则矿工们产出一个单位的煤。</li><li>如果这几次食品车中有两种不同类型的食品，则矿工们产出两个单位的煤。</li><li>如果这几次食品车中有三种不同类型的食品，则矿工们产出三个单位的煤。</li></ul><p>预先已知食品车的类型及其被配送的顺序。通过确定哪车食品送到哪个煤矿可以影响产煤量。食品车不能被拆分，每个食品车必须被全部送到一个或另一个煤矿。两个煤矿也并不要求接收相同数量的食品车（事实上，也允许将所有食品车都送到一个煤矿）。</p><p>给出食品车的类型及其被配送的顺序，要求你写一个程序，确定哪个食品车应被送到煤矿1，哪个食品车应被送到煤矿2，以使得两个煤矿的产煤量的总和最大。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4401" target="_blank" rel="noopener">[IOI2007]Miners 矿工配餐</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以dp解决。</p><p>由于与前两个位置的食品种类有关，因此需开多维记录前两个位置的食品种类。</p><p>令<code>MBF</code>字符分别对应<code>123</code>。</p><p>定义 $dp[i][a][b][c][d]$ 表示目前正在处理第 $i$ 辆食品车，煤矿1目前后两个食品种类为<code>ab</code>，煤矿2目前后两个食品种类为<code>cd</code>。</p><p>这个转移思想是十分显然的，状态转移方程见代码吧。</p><p>需要初始将其全赋为 $-1$，以表示此状态不存在。然后初始化 $dp[0][0][0][0][0]$为 $0$。</p><p>转移过程中判断被转移的状态是否存在，即是否等于 $-1$。</p><p>显然可以滚动数组优化，只需保存两行即可，每次用另一行进行转移。</p><p>具体细节见代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">2</span>][<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>],maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> food[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="string">'M'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="string">'B'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">v</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x) x=z;</span><br><span class="line"><span class="keyword">if</span>(!y) y=z;</span><br><span class="line"><span class="keyword">if</span>(x==y&amp;&amp;y==z) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x!=y&amp;&amp;y!=z&amp;&amp;x!=z) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;food[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp[i%<span class="number">2</span>],<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp[i%<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=<span class="number">3</span>;a++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;=<span class="number">3</span>;b++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=<span class="number">3</span>;c++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">3</span>;d++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i%<span class="number">2</span>^<span class="number">1</span>][a][b][c][d]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">dp[i%<span class="number">2</span>][b][f(food[i])][c][d]=max(dp[i%<span class="number">2</span>][b][f(food[i])][c][d],dp[i%<span class="number">2</span>^<span class="number">1</span>][a][b][c][d]+v(a,b,f(food[i])));</span><br><span class="line">dp[i%<span class="number">2</span>][a][b][d][f(food[i])]=max(dp[i%<span class="number">2</span>][a][b][d][f(food[i])],dp[i%<span class="number">2</span>^<span class="number">1</span>][a][b][c][d]+v(c,d,f(food[i])));</span><br><span class="line">maxn=max(maxn,max(dp[i%<span class="number">2</span>][b][f(food[i])][c][d],dp[i%<span class="number">2</span>][a][b][d][f(food[i])]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维动态规划 </tag>
            
            <tag> IOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1868] 饥饿的奶牛</title>
      <link href="/is-zxy.github.io/2020/05/23/%5B%E6%B4%9B%E8%B0%B7P1868%5D-%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B/"/>
      <url>/is-zxy.github.io/2020/05/23/%5B%E6%B4%9B%E8%B0%B7P1868%5D-%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B/</url>
      
        <content type="html"><![CDATA[<p>有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。</p><p>现用汉语翻译为：</p><p>有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。</p><p>对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 150000$</p><p>$0\le x\le y\le 3000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1868" target="_blank" rel="noopener">P1868 饥饿的奶牛</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将区间按照左端点从小到大排序。</p><p>设 $dp[n]$ 前 $n$ 个区间中，选择了第 $n$ 个区间，所能获得的最长的区间长度。</p><p>显然</p><script type="math/tex; mode=display">dp[i]=\max\{dp[j]+r[i]-l[i]+1\},r[j]<l[i],j\in [0,i)</script><p>这样就很容易打出个 $O(n^2)$ 的暴力（$150000$ 的数据过了九个点..）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N],maxn=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;grass[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;grass[i].l&gt;&gt;grass[i].r;</span><br><span class="line"></span><br><span class="line">sort(grass+<span class="number">1</span>,grass+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(grass[j].r&lt;grass[i].l) dp[i]=max(dp[i],dp[j]+grass[i].r-grass[i].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">maxn=max(maxn,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后想如何对这种方法进行优化。</p><p>单调队列优化？右端点的大小是无序的，所以应该不能。</p><p>由于是取右端点小于 $i$ 左端点的最大值，想到可以用线段树优化。</p><p>根据区间端点建立权值线段树即可，时间复杂度 $O(M\log M)$，其中 $M$ 为最大的区间右端点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N],maxn=<span class="number">0</span>,q[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">&#125;grass[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,maxn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m(x) tree[x].maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">m(p)=max(m(ls),m(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">m(p)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;x||r(p)&lt;x) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">m(p)=max(m(p),y);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">change(ls,x,y);</span><br><span class="line">change(rs,x,y);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(r(p)&lt;=x) <span class="keyword">return</span> m(p);</span><br><span class="line"><span class="keyword">return</span> max(ask(ls,x),ask(rs,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;grass[i].l&gt;&gt;grass[i].r;</span><br><span class="line">maxn=max(maxn,grass[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(grass+<span class="number">1</span>,grass+n+<span class="number">1</span>,cmp);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,maxn);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[i]=ask(<span class="number">1</span>,grass[i].l<span class="number">-1</span>)+grass[i].r-grass[i].l+<span class="number">1</span>;</span><br><span class="line">change(<span class="number">1</span>,grass[i].r,dp[i]);</span><br><span class="line">ans=max(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/P2439" target="_blank" rel="noopener">[SDOI2005]阶梯教室设备利用</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> SDOI </tag>
            
            <tag> 数据结构优化DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO06DEC] The Fewest Coins G</title>
      <link href="/is-zxy.github.io/2020/05/22/%5BUSACO06DEC%5D-The-Fewest-Coins-G/"/>
      <url>/is-zxy.github.io/2020/05/22/%5BUSACO06DEC%5D-The-Fewest-Coins-G/</url>
      
        <content type="html"><![CDATA[<p>农夫John想到镇上买些补给。为了高效地完成任务，他想使硬币的转手次数最少。即使他交付的硬币数与找零得到的的硬币数最少。</p><p>John想要买价值为 $T$ 的东西。有 $N(1\le N\le 100)$ 种货币参与流通，面值分别为 $V_1,V_2..V_N (1\le V_i\le 120)$。John有 $C_i$ 个面值为 $V_i$ 的硬币 $(0&lt;=C_i&lt;=10000)$。</p><p>我们假设店主有无限多的硬币， 并总按最优方案找零。<strong>注意无解输出-1。</strong></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$T\le 10000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2851" target="_blank" rel="noopener">[USACO06DEC]The Fewest Coins G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找零，相当于将货币的面额变为其相反数。</p><p>于是转化为一个混合背包问题，对正值面额进行多重背包，负值进行完全背包（因为店主有无限多的硬币）。</p><p>注意对正值面额进行的多重背包需要二进制优化。</p><p>过程中货币的最大面额比较难确定，于是看了题解，用抽屉原理，将其取到了 $T+V_{max}^2$。</p><p>确定后直接搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t,v[N],c[N],dp[MAXN],maxn=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">v[i+n]=-v[i];</span><br><span class="line">maxn=max(maxn,v[i]*v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">sum+=c[i]*v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> num=min(c[i],(t+maxn)/v[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;num&gt;<span class="number">0</span>;k&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(k&gt;num) k=num;</span><br><span class="line">num-=k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=t+maxn;j&gt;=k*v[i];j--) dp[j]=min(dp[j],dp[j-k*v[i]]+k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=t+maxn+v[i];j++) dp[j]=min(dp[j],dp[j-v[i]]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[t]!=<span class="number">0x3f3f3f3f</span>) <span class="built_in">cout</span>&lt;&lt;dp[t]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1278] 单词游戏</title>
      <link href="/is-zxy.github.io/2020/05/16/%5B%E6%B4%9B%E8%B0%B7P1278%5D-%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/"/>
      <url>/is-zxy.github.io/2020/05/16/%5B%E6%B4%9B%E8%B0%B7P1278%5D-%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>Io和Ao在玩一个单词游戏。</p><p>他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。</p><p>游戏可以从任何一个单词开始。</p><p>任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。</p><p>游戏的复杂度定义为游戏中所使用的单词长度总和。</p><p>编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N\le 16$</p><p>每一个单词是由A、E、I、O、U组成的一个字符串，长度小于等于 $100$，每个单词都不一样。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1278" target="_blank" rel="noopener">P1278 单词游戏</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>搜索题单里的一题<del>结果先想到了状压DP</del>。</p><p>数据范围显然状压可行。</p><p>定义 $dp[i][j]$ 表示状态 $i$ 下，末尾字母是第 $j$ 个字母的最长长度。</p><p>显然</p><script type="math/tex; mode=display">dp[i][s[j][s[j].size()-1]]=\max\{dp[i][s[j][0]]+s[j].size()\}</script><p>前提是 $i$ 状态中 $j$ 并没有被选。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">1</span>&lt;&lt;N][<span class="number">30</span>],bits[<span class="number">1</span>&lt;&lt;N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[<span class="number">1</span>&lt;&lt;i][s[i][s[i].size()<span class="number">-1</span>]-<span class="string">'A'</span>]=s[i].size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i) <span class="keyword">continue</span>;</span><br><span class="line">dp[i|(<span class="number">1</span>&lt;&lt;j)][s[j][s[j].size()<span class="number">-1</span>]]=max(dp[i|(<span class="number">1</span>&lt;&lt;j)][s[j][s[j].size()<span class="number">-1</span>]],dp[i][s[j][<span class="number">0</span>]]+(<span class="keyword">int</span>)s[j].size());</span><br><span class="line">ans=max(ans,dp[i|(<span class="number">1</span>&lt;&lt;j)][s[j][s[j].size()<span class="number">-1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI1999] 生日蛋糕</title>
      <link href="/is-zxy.github.io/2020/05/16/%5BNOI1999%5D-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/"/>
      <url>/is-zxy.github.io/2020/05/16/%5BNOI1999%5D-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
      
        <content type="html"><![CDATA[<p>7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 $N\pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。</p><p>设从下往上数第 $i(1 \leq i \leq M)$ 层蛋糕是半径为 $R_i$，高度为 $H_i$ 的圆柱。当 $i \lt M$ 时，要求 $R_i \gt R_{i+1}$ 且 $H_i \gt H_{i+1}$。</p><p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。</p><p>请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $R_i$ 和 $H_i$ 的值），使 $S=\dfrac{Q}{\pi}$ 最小。</p><p>（除 $Q$ 外，以上所有数据皆为正整数）</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N\le 2\times 10^4$。</p><p>$M\le 15$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1731" target="_blank" rel="noopener">[NOI1999]生日蛋糕</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>即求满足条件的</p><script type="math/tex; mode=display">\sum_{i=1}^MR_i^2\cdot H_i=N</script><p>使得</p><script type="math/tex; mode=display">S=\sum_{i=1}^M2R_i\cdot H_i+R_1^2</script><p>$S$最小。</p><p>于是很容易写出以下的<del>加了最优化剪枝的</del>暴搜，30分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> S,<span class="keyword">int</span> l,<span class="keyword">int</span> lastR,<span class="keyword">int</span> lastH)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S&gt;ans||l&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(x&gt;m) &#123;</span><br><span class="line"><span class="keyword">if</span>(!l) ans=min(ans,S+R[<span class="number">1</span>]*R[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=m-x+<span class="number">1</span>;r&lt;lastR;r++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=m-x+<span class="number">1</span>;h&lt;lastH;h++) &#123;</span><br><span class="line">R[x]=r,H[x]=h;</span><br><span class="line">dfs(x+<span class="number">1</span>,S+<span class="number">2</span>*r*h,l-r*r*h,r,h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是考虑在此基础上优化。</p><ul><li><p>搜小搜索范围</p><p>该暴搜中枚举的 $r$ 范围为 $[1,lastR]$，枚举的 $h$ 范围为 $[1,lastH]$，考虑将这俩范围缩小。</p><p>则对于每层 $x$（从下到上），考虑一种特殊情况来限定出 $r$ 与 $h$ 的范围——剩余体积全被该层给占了。</p><p>则</p><script type="math/tex; mode=display">r^2\cdot h=l</script><p>由于全为正整数，所以当 $h$ 为 $1$ 时，$r$ 有最大值 $\left\lfloor\sqrt{l}\right\rfloor$。那么 $r$ 的枚举范围可以优化到</p><script type="math/tex; mode=display">\left[M-x+1,\min\left(\left\lfloor\sqrt{l}\right\rfloor,lastR-1\right)\right]</script><p>对于每次枚举的 $r$，其 $h$ 的最大值都为 $\left\lfloor\dfrac{l}{r^2}\right\rfloor$。那么 $h$ 的枚举范围可以优化到</p><script type="math/tex; mode=display">\left[M-x+1,\min\left(\left\lfloor\dfrac{l}{r^2}\right\rfloor,lastH-1\right)\right]</script><p>加上上下界剪枝后，40分。</p></li><li><p>倒序枚举，50分。</p></li><li><p>可行性剪枝：当前正在处理第 $x$ 层，剩余体积为 $l$，那么如果第 $x+1$ 层到 $M$ 层的最小体积大于 $l$，则直接剪掉该分支。显然，从上往下的第 $1$ 层到第 $n$ 层，其最小体积即为第 $i$ 层的底面半径为 $i$，高为 $i$ 的情况。即为$\sum\limits_{i=1}^ni^3=\left[\dfrac{(n+1)n}{2}\right]^2$。加上该剪枝50分。</p></li><li><p>最优化剪枝：若目前的侧面积加上 $x+1$ 层到 $M$ 层的最小侧面积大于 $ans$，则直接剪掉。从上到下数的第 $1$ 层到第 $n$ 层的最小侧面积为$\sum\limits_{i=1}^n2i^2=\dfrac{n(n+1)(2n+1)}{3}$。加上该剪枝70分。</p><p>上述两个直接求出最小侧面积与最小体积的式子貌似常数过大，反而不如直接预处理出来。</p></li><li><p>最难想也是最关键的一个最优化剪枝：目前正在搜第 $x$ 层。则$x+1\sim M$ 层的体积即为 $l$，即</p><script type="math/tex; mode=display">\sum\limits_{i=x+1}^Mr[i]^2\cdot h[i]=l</script><p>第 $x+1\sim M$ 层的侧面积为</p><script type="math/tex; mode=display">2\sum\limits_{i=x}^Mr[i]\cdot h[i]</script><p>而</p><script type="math/tex; mode=display">2\sum\limits_{i=x}^Mr[i]\cdot h[i]=\dfrac{2}{r[x]}\sum\limits_{i=x}^Mr[i]\cdot h[i]\cdot r[x]\ge \dfrac{2}{r[x]}\sum\limits_{i=x}^Mr[i]^2\cdot h[i]\ge \dfrac{2l}{r[x]}</script><p>所以当 $\dfrac{2l}{r[x]}+S+R[1]^2\ge ans$时，直接剪掉。加上该剪枝100分，且时间为88ms。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,R[N],H[N],ans=INF,v[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+<span class="number">2</span>*i*i;</span><br><span class="line">v[i]=v[i<span class="number">-1</span>]+i*i*i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> S,<span class="keyword">int</span> l,<span class="keyword">int</span> lastR,<span class="keyword">int</span> lastH)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S&gt;ans||l&lt;<span class="number">0</span>||S+s[m-x+<span class="number">1</span>]+R[<span class="number">1</span>]*R[<span class="number">1</span>]&gt;ans||v[m-x+<span class="number">1</span>]&gt;l||<span class="number">2</span>*l/lastR+S+R[<span class="number">1</span>]*R[<span class="number">1</span>]&gt;=ans) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(x&gt;m) &#123;</span><br><span class="line"><span class="keyword">if</span>(!l) ans=min(ans,S+R[<span class="number">1</span>]*R[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=min((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(l),lastR<span class="number">-1</span>);r&gt;=m-x+<span class="number">1</span>;r--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=min(l/r/r,lastH<span class="number">-1</span>);h&gt;=m-x+<span class="number">1</span>;h--) &#123;</span><br><span class="line">R[x]=r,H[x]=h;</span><br><span class="line">dfs(x+<span class="number">1</span>,S+<span class="number">2</span>*r*h,l-r*r*h,r,h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>,n,n,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOI </tag>
            
            <tag> DFS </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1120] 小木棍 [ 数据加强版 ]</title>
      <link href="/is-zxy.github.io/2020/05/14/%5B%E6%B4%9B%E8%B0%B7P1120%5D-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
      <url>/is-zxy.github.io/2020/05/14/%5B%E6%B4%9B%E8%B0%B7P1120%5D-%E5%B0%8F%E6%9C%A8%E6%A3%8D-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。</p><p>现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。</p><p>给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N \le 65$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1120" target="_blank" rel="noopener">P1120 小木棍 ［数据加强版］</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用 $(x,num)$ 表示状态为目前在处理第 $x$ 个小木棍，前 $x-1$ 个小木棍拼接成了 $num$ 个长棍。</p><p>那么显然由 $(x,num)$ 可以转移到 $(x+1,num)$ 与 $(x+1,num+1)$ ，即第 $x$ 个小木棍可以与 $num$ 个长棍中的一个拼接在一起，也可以一个都不拼接。搜完最后一个小木棍，判断目前的 $num$ 个长棍是否每个长度都相等，若相等则记录最小值。</p><p>显然，可以对其最优化剪枝，可得21分。</p><p>然后发现这个方法貌似不太好剪枝了…</p><p>于是考虑换一种思路搜索。</p><p>显然，答案的范围是可以确定的。</p><p>那么干脆直接枚举答案！判断当前枚举的答案是否可行，答案从小到大枚举，这样第一个搜完的一定是最优解。</p><p>用 $(l,left,len)$ 表示当前的长棍还剩下 $l$ 的长度需要拼接，还有 $left$ 个小木棍可以拼接，目前枚举判断是否可行的答案为 $len$ 。然后类似选数，对其搜索即可。</p><p>于是开始对这个方法进行优化。</p><ol><li>显然，答案一定是小木棍总长度的因数。那么答案直接从因数中枚举。加上该优化，30分。</li><li>最少扩展点优化，将小木棍长度从大到小排序。加上该剪枝，36分。</li><li>排除等效冗余：向目前的长棍，先拼接长为 $x$ 的小木棍再拼接长为 $y$ 的小木棍与先拼接长为 $y$ 的小木棍再拼接长为 $x$ 的小木棍是等效的。因此可以使拼接的小木棍长度递减。加上该剪枝，36分。</li><li>又是排除等效冗余：如果选择拼接长为 $x$ 的小木棍，最终返回<code>flase</code>，那么对于所有长度为 $x$ 的小木棍，其都是不可行的。因此跳到下一个长不为 $x$ 的小木棍，对其进行搜索。加上该剪枝，45分。</li><li>还是是排除等效冗余：如果一个长棍放入的第一个小木棍就返回<code>false</code>的话，证明该答案是不可行的，直接返回<code>false</code>。因为之后所有的长棍都放不入该小木棍。加上该剪枝，78分。</li><li>仍然是排除等效冗余：如果一个长棍还剩下的长度与目前放入的小木棍长度相等，且放入该小木棍返回<code>false</code>，那么证明该答案是不可行的，直接返回<code>false</code>。因为剩下的小木棍无法拼接成数个答案长度的长棍，将其中的几个换成之前已经拼成的长棍中的某个小木棍的长度，其和不变，仍然无法拼接成数个答案长度的长棍，反倒还降低了小木棍拼接的灵活度。加上该剪枝，AC。</li></ol><p>本题中的剪枝包含了很多搜索题常用的剪枝，应深入理解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],tot=<span class="number">0</span>,s[N],minn=INF,sum=<span class="number">0</span>,ans;</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> left,<span class="keyword">int</span> pos,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!l&amp;&amp;!left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!l) &#123;</span><br><span class="line">l=len;</span><br><span class="line">pos=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[i]||l&lt;a[i]) <span class="keyword">continue</span>;</span><br><span class="line">vh[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(l-a[i],left<span class="number">-1</span>,i+<span class="number">1</span>,len)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">vh[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==len||a[i]==l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(a[i]==a[i+<span class="number">1</span>]) i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=<span class="number">50</span>) a[++tot]=x,sum+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sum%i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(i,tot,<span class="number">1</span>,i)) &#123;</span><br><span class="line">ans=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2011] Mayan游戏</title>
      <link href="/is-zxy.github.io/2020/05/13/%5BNOIP2011%5D-Mayan%E6%B8%B8%E6%88%8F/"/>
      <url>/is-zxy.github.io/2020/05/13/%5BNOIP2011%5D-Mayan%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><code>Mayan puzzle</code>是最近流行起来的一个游戏。游戏界面是一个 $7$ 行 $\times 5$ 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下：</p><ol><li>每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 $6$ 到图 $7$ ）；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空，参见下面图 $1$ 和图 $2$）；</li></ol><p><img src="https://s1.ax1x.com/2020/05/13/YwtOKS.jpg" alt=""></p><ol><li>任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则它们将立即被消除（参见图 $1$ 到图 $3$）。</li></ol><p><img src="https://s1.ax1x.com/2020/05/13/YwNS5n.png" alt="img"></p><p>注意：</p><ul><li><p>如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 $4$，三个颜色为 $1$ 的方块和三个颜色为 $2$ 的方块会同时被消除，最后剩下一个颜色为 $2$ 的方块）。</p></li><li><p>当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图$5$所示的情形，$5$ 个方块会同时被消除）。</p></li></ul><ol><li><p>方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。</p><p>上面图 $1$ 到图 $3$ 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为 $(0,0)$，将位于 $(3,3)$ 的方块向左移动之后，游戏界面从图 $1$ 变成图 $2$ 所示的状态，此时在一竖列上有连续三块颜色为 $4$ 的方块，满足消除条件，消除连续 $3$ 块颜色为 $4$ 的方块后，上方的颜色为 $3$ 的方块掉落，形成图 $3$ 所示的局面。</p></li></ol><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $30\%$ 的数据，初始棋盘上的方块都在棋盘的最下面一行；</p><p>对于 $100\%$ 的数据，$0 &lt; n≤5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1312" target="_blank" rel="noopener">Mayan游戏</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道很考验代码实现能力的模拟搜索题。</p><p>第一次做时没动脑子，上来打了个宽搜。在打出一大堆错误，调试未果后，果断放弃，打算重构。</p><p>仔细思考了一下，我觉得这题是很难用宽搜实现的。</p><p>每个方块都有两个移动方向，那么初次就能拓展出 $2$ 倍的非 $0$ 方块数的状态，之后又大致呈指数递增，空间是十分大的。</p><p>于是用深搜。</p><p>根据题意，要写几个子函数。</p><ul><li><p>复制函数<code>copy</code>，其用来深搜记录当前这一步的状态，便于之后回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) s[x][i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回溯函数<code>flash_back</code>，回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flash_back</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) a[i][j]=s[x][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下落函数<code>down</code>，每次移动后或消除后会有方块悬空，需要将其往下降。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> js=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!a[i][j]) js++;</span><br><span class="line"><span class="keyword">else</span> swap(a[i][j],a[i][j-js]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消除函数<code>eli</code>，注意题目中指的是<code>在一横行或者竖列上</code>，因此不需要什么花里胡哨的<code>dfs</code>求最多连续数字（我第一次就这么瞎搞的，没看清题意），直接扫两边即可。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool eli() &#123;</span><br><span class="line">bool flag=<span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=<span class="number">5</span>;<span class="built_in">i</span>++) &#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=<span class="number">7</span>;<span class="built_in">j</span>++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">i</span>&lt;<span class="number">5</span>&amp;&amp;a[<span class="built_in">i</span>][<span class="built_in">j</span>]&amp;&amp;a[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]==a[<span class="built_in">i</span>][<span class="built_in">j</span>]&amp;&amp;a[<span class="built_in">i</span>+<span class="number">1</span>][<span class="built_in">j</span>]==a[<span class="built_in">i</span>][<span class="built_in">j</span>]) e[<span class="built_in">i</span><span class="number">-1</span>][<span class="built_in">j</span>]=e[<span class="built_in">i</span>][<span class="built_in">j</span>]=e[<span class="built_in">i</span>+<span class="number">1</span>][<span class="built_in">j</span>]=<span class="number">1</span>,flag=<span class="built_in">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">j</span>&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">j</span>&lt;<span class="number">7</span>&amp;&amp;a[<span class="built_in">i</span>][<span class="built_in">j</span>]&amp;&amp;a[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]==a[<span class="built_in">i</span>][<span class="built_in">j</span>]&amp;&amp;a[<span class="built_in">i</span>][<span class="built_in">j</span>+<span class="number">1</span>]==a[<span class="built_in">i</span>][<span class="built_in">j</span>]) e[<span class="built_in">i</span>][<span class="built_in">j</span><span class="number">-1</span>]=e[<span class="built_in">i</span>][<span class="built_in">j</span>]=e[<span class="built_in">i</span>][<span class="built_in">j</span>+<span class="number">1</span>]=<span class="number">1</span>,flag=<span class="built_in">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;=<span class="number">5</span>;<span class="built_in">i</span>++) &#123;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=<span class="number">7</span>;<span class="built_in">j</span>++) &#123;</span><br><span class="line"><span class="keyword">if</span>(e[<span class="built_in">i</span>][<span class="built_in">j</span>]) e[<span class="built_in">i</span>][<span class="built_in">j</span>]=a[<span class="built_in">i</span>][<span class="built_in">j</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移动函数<code>move</code>，由于移动，下落后，可能仍有方块可以消除，消除后再下落，又有方块可以消除……因此需要用<code>while</code>判断何时不需消除下降，这也是上面的<code>eli</code>函数定义成<code>bool</code>类型的原因。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void move(int <span class="meta">x</span>,int y,int dir) &#123;</span><br><span class="line">swap(a[<span class="meta">x</span>][y],a[<span class="meta">x</span>+dir][y]);</span><br><span class="line"><span class="meta">do</span><span class="meta">wn(</span>);</span><br><span class="line"><span class="meta">while</span>(eli()) <span class="meta">do</span><span class="meta">wn(</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>check</code>函数，判断是否出解，这很好写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) <span class="keyword">if</span>(a[i][<span class="number">1</span>]) <span class="keyword">return</span> ;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接下来愉快的<code>dfs</code>即可。注意一些边界条件。</p><p>需要剪枝。</p><p>加了两个剪枝。</p><p>第一个是被移动的两个方块不能相同。</p><p>第二个是若一个方块左边有方块，那么就不对此方块进行左移操作。因为对此方块进行左移操作后的状态是和对此方块左面的方块进行右移后的状态是一样的，而题目有要求以右移优先。</p><p>事实上，第一个剪枝是不正确的。但是加上也能通过本题<del>说明本题数据过水</del>。</p><p>因为题目中的 $n$ 为“要求游戏通关的步数”，那么浪费步数以求达到规定步数是可行的，所以可以通过移动两个相同颜色的方块来“浪费步数”。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N][N],s[N][N][N],e[N][N],ans[N][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) s[x][i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flash_back</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) a[i][j]=s[x][i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> js=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!a[i][j]) js++;</span><br><span class="line"><span class="keyword">else</span> swap(a[i][j],a[i][j-js]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eli</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;i&lt;<span class="number">5</span>&amp;&amp;a[i][j]&amp;&amp;a[i<span class="number">-1</span>][j]==a[i][j]&amp;&amp;a[i+<span class="number">1</span>][j]==a[i][j]) e[i<span class="number">-1</span>][j]=e[i][j]=e[i+<span class="number">1</span>][j]=<span class="number">1</span>,flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>&amp;&amp;j&lt;<span class="number">7</span>&amp;&amp;a[i][j]&amp;&amp;a[i][j<span class="number">-1</span>]==a[i][j]&amp;&amp;a[i][j+<span class="number">1</span>]==a[i][j]) e[i][j<span class="number">-1</span>]=e[i][j]=e[i][j+<span class="number">1</span>]=<span class="number">1</span>,flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">7</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]) e[i][j]=a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">swap(a[x][y],a[x+dir][y]);</span><br><span class="line">down();</span><br><span class="line"><span class="keyword">while</span>(eli()) down();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) <span class="keyword">if</span>(a[i][<span class="number">1</span>]) <span class="keyword">return</span> ;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;n) &#123;</span><br><span class="line">check();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">copy(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">5</span>&amp;&amp;a[i][j]&amp;&amp;a[i][j]!=a[i+<span class="number">1</span>][j]) &#123;</span><br><span class="line">move(i,j,<span class="number">1</span>);</span><br><span class="line">ans[x][<span class="number">1</span>]=i<span class="number">-1</span>,ans[x][<span class="number">2</span>]=j<span class="number">-1</span>,ans[x][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">dfs(x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">flash_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;a[i][j]&amp;&amp;a[i][j]!=a[i<span class="number">-1</span>][j]&amp;&amp;!a[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">move(i,j,<span class="number">-1</span>);</span><br><span class="line">ans[x][<span class="number">1</span>]=i<span class="number">-1</span>,ans[x][<span class="number">2</span>]=j<span class="number">-1</span>,ans[x][<span class="number">3</span>]=<span class="number">-1</span>;</span><br><span class="line">dfs(x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">flash_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(!a[i][j]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i][<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[i][<span class="number">2</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[i][<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题体现了我薄弱的程序实现能力，以及思考问题时的一些恶习，思考不够深入，做事太着急。</p><p>然后因为一个小错误查了近一个半小时——<code>down</code>函数中<code>int js=0</code>放在了内层循环中，于是<code>down</code>函数相当于一点用都没有。</p><p>查出后提交，又错了。下载数据，发现输入一行可能为 $8$ 个，即这一列是满的，最后也要以 $0$ 结尾。这是没有仔细阅读题目而造成的。这一些些小错误，在比赛时是致命的。</p><p>还得练啊。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> NOIP </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2009] 靶形数独</title>
      <link href="/is-zxy.github.io/2020/05/10/%5BNOIP2009%5D-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC/"/>
      <url>/is-zxy.github.io/2020/05/10/%5BNOIP2009%5D-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<p>小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。</p><p>靶形数独的方格同普通数独一样，在 $9$ 格宽且 $9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽且 $3$ 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）</p><p><img src="https://wx2.sbimg.cn/2020/05/30/1.png" alt="1.png"></p><p>上图具体的分值分布是：最里面一格（黄色区域）为 $10$ 分，黄色区域外面的一圈（红色区域）每个格子为 $9$ 分，再外面一圈（蓝色区域）每个格子为 $8$ 分，蓝色区域外面一圈（棕色区域）每个格子为 $7$ 分，最外面一圈（白色区域）每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和</p><p>总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$。游戏规定，将以总分数的高低决出胜负。</p><p><img src="https://wx1.sbimg.cn/2020/05/30/18a5d1db5ebaa246c.png" alt="18a5d1db5ebaa246c.png"></p><p>由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul><li>对于 $40\%$ 的数据，数独中非 $0$ 数的个数不少于 $30$；</li><li>对于 $80\%$ 的数据，数独中非 $0$ 数的个数不少于 $26$；</li><li>对于 $100\%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1074" target="_blank" rel="noopener">[NOIP2009]靶形数独</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>常规的数独加点优化。</p><p>由于要求最高分数，所以每种可行状态都要搜一遍。</p><p>所以要使得搜索树尽可能的小。</p><p>可以想到从能填的数最少的格子开始填起，减少分叉，使得搜索树减小。</p><p>这里我用的位运算实现，好写一点，但有个点有点卡，或许常规数组标记会更快些。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y):x(_x),y(_y) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a[N][N],r[N],c[N],p[N],mp[<span class="number">1</span>&lt;&lt;N],num[N][N],tot,ans[N][N],maxn=<span class="number">-1</span>,score=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; tbs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gets</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||y==<span class="number">1</span>||x==<span class="number">9</span>||y==<span class="number">9</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">2</span>||y==<span class="number">2</span>||x==<span class="number">8</span>||y==<span class="number">8</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">3</span>||y==<span class="number">3</span>||x==<span class="number">7</span>||y==<span class="number">7</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">4</span>||y==<span class="number">4</span>||x==<span class="number">6</span>||y==<span class="number">6</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x<span class="number">-1</span>)/<span class="number">3</span>*<span class="number">3</span>+(y<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) <span class="keyword">if</span>(a[i][j]) r[i]^=<span class="number">1</span>&lt;&lt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) <span class="keyword">if</span>(a[i][j]) c[j]^=<span class="number">1</span>&lt;&lt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) <span class="keyword">if</span>(a[i][j]) p[getp(i,j)]^=<span class="number">1</span>&lt;&lt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">tot=tbs.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">r[x]^=<span class="number">1</span>&lt;&lt;z;</span><br><span class="line">c[y]^=<span class="number">1</span>&lt;&lt;z;</span><br><span class="line">p[getp(x,y)]^=<span class="number">1</span>&lt;&lt;z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x,js=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;t;t-=lowbit(t)) js++;</span><br><span class="line"><span class="keyword">return</span> js;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(score+(tot-x)*<span class="number">90</span>&lt;=maxn) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=tot) &#123;</span><br><span class="line">maxn=max(maxn,score);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minn=(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)<span class="number">-1</span>,minx,miny;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tbs.size();i++) &#123;</span><br><span class="line"><span class="keyword">int</span> h=tbs[i].first,l=tbs[i].second;</span><br><span class="line"><span class="keyword">if</span>(ans[h][l]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> t=r[h]&amp;c[l]&amp;p[getp(h,l)];</span><br><span class="line"><span class="keyword">if</span>(get(t)&lt;get(minn)) minx=h,miny=l,minn=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;minn;minn-=lowbit(minn)) &#123;</span><br><span class="line">change(minx,miny,mp[lowbit(minn)]);</span><br><span class="line">ans[minx][miny]=mp[lowbit(minn)];</span><br><span class="line">score+=gets(minx,miny)*mp[lowbit(minn)];</span><br><span class="line">dfs(x+<span class="number">1</span>);</span><br><span class="line">change(minx,miny,mp[lowbit(minn)]);</span><br><span class="line">ans[minx][miny]=<span class="number">0</span>;</span><br><span class="line">score-=gets(minx,miny)*mp[lowbit(minn)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line">mp[<span class="number">1</span>&lt;&lt;i]=i;</span><br><span class="line">r[i]=c[i]=p[i]=(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">ans[i][j]=a[i][j];</span><br><span class="line"><span class="keyword">if</span>(!a[i][j]) tbs.push_back(make_pair(i,j));</span><br><span class="line">score+=gets(i,j)*a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 搜索次序优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4168] [Violet]蒲公英</title>
      <link href="/is-zxy.github.io/2020/05/07/%5B%E6%B4%9B%E8%B0%B7P4168-Violet%5D-%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
      <url>/is-zxy.github.io/2020/05/07/%5B%E6%B4%9B%E8%B0%B7P4168-Violet%5D-%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
      
        <content type="html"><![CDATA[<p>在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。</p><p>为了简化起见，我们把所有的蒲公英看成一个长度为n的序列 $(a_1,a_2..a_n)$，其中 $a_i$ 为一个正整数，表示第 $i$ 棵蒲公英的种类编号。</p><p>而每次询问一个区间 $[l,r]$，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。</p><p>注意，你的算法必须是在线的。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n \le 40000,1\le m \le 50000,1\le a_i\le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4168" target="_blank" rel="noopener">P4168 [Violet]蒲公英</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实和[LOJ#6285] 数列分块入门 9是一样的。</p><p>但是当时的思路没咋认真写。</p><p>首先离散化，由于本题只关注数的个数，所以没必要用平常的二分离散化，采用一种映射的方式即可。</p><p>分块，分成$\sqrt N$块</p><p>假设有两个集合$A,B$，那么集合$A\cup B$的众数一定是集合$A$的众数或集合$B$中的数，这个很显然。</p><p>那么根据这个性质可以 $O(N^{1.5}\log N)$ 预处理出以块端点为区间端点的区间的众数。</p><p>对每个数值建立个<code>vector</code>，将数值出现的位置插入其中，这样当我们想求一个区间内的该数值的个数时，可二分求出。</p><p>对于每个询问，还是根据上面的性质来求：</p><ul><li>若左右端点处于同一块，则直接暴力二分求该区间内每个数出现个数以求区间内的众数。</li><li>若不处于同一块，则先将区间众数定为中间整块的区间众数，然后暴力求两个非整块中的每个数在区间中的个数，以求出该区间的众数。</li></ul><p>这样每次询问时间复杂度为 $O(\sqrt N \log N)$。</p><p>那么总时间复杂度为 $O\left((N+Q)\sqrt N \log N \right)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 40010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqrtN 2010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,blo,m,size,id,v[N],pos[N],val[N],cnt[N],L[sqrtN],R[sqrtN],f[sqrtN][sqrtN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">'9'</span> || c&lt;<span class="string">'0'</span>) c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size=<span class="number">30</span>;</span><br><span class="line">blo=n/size;</span><br><span class="line"><span class="keyword">if</span>(!blo) blo=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) L[i]=(i<span class="number">-1</span>)*size+<span class="number">1</span>,R[i]=i*size;</span><br><span class="line">R[blo]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line">pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>,maxs;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=n;j++) &#123;</span><br><span class="line">cnt[v[j]]++;</span><br><span class="line"><span class="keyword">if</span>(cnt[v[j]]&gt;maxn||(cnt[v[j]]==maxn&amp;&amp;val[v[j]]&lt;val[maxs])) maxs=v[j],maxn=cnt[v[j]];</span><br><span class="line">f[i][pos[j]]=maxs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> upper_bound(ve[x].begin(),ve[x].end(),r)-lower_bound(ve[x].begin(),ve[x].end(),l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxn,maxs,p=pos[l],q=pos[r];</span><br><span class="line">maxs=f[p+<span class="number">1</span>][q<span class="number">-1</span>];</span><br><span class="line">maxn=query(l,r,maxs);</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">v[i]=read();</span><br><span class="line"><span class="keyword">if</span>(!mp[v[i]]) &#123;</span><br><span class="line">mp[v[i]]=++id;</span><br><span class="line">val[id]=v[i];</span><br><span class="line">&#125;</span><br><span class="line">v[i]=mp[v[i]];</span><br><span class="line">ve[v[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">l=read(),r=read();</span><br><span class="line">l=(l+x<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">r=(r+x<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x=val[ask(l,r)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SCOI2009] 粉刷匠</title>
      <link href="/is-zxy.github.io/2020/05/06/%5BSCOI2009%5D-%E7%B2%89%E5%88%B7%E5%8C%A0/"/>
      <url>/is-zxy.github.io/2020/05/06/%5BSCOI2009%5D-%E7%B2%89%E5%88%B7%E5%8C%A0/</url>
      
        <content type="html"><![CDATA[<p>windy有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。</p><p>windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。</p><p>如果windy只能粉刷 $T$ 次，他最多能正确粉刷多少格子？</p><p>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$30\%$ 的数据，满足 $1 &lt;= N,M &lt;= 10$ ； $0 &lt;= T &lt;= 100$ 。</p><p>$100\%$ 的数据，满足 $1 &lt;= N,M &lt;= 50$ ； $0 &lt;= T &lt;= 2500$ 。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4158" target="_blank" rel="noopener">[SCOI2009]粉刷匠</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每块木板，刷不同次数，能正确粉刷的格子数量不同。共能刷 $T$ 次，那么显然这题整体是个分组背包，即把 $T$ 次看成背包的容量，每块木板看成每个物品组，每块木板刷不同次数能正确粉刷的格子数量看成物品。</p><p>那么现在要处理的就是每块木板刷不同次数能正确粉刷的格子数量。</p><p>定义 $dp_b(i,j,k)$ 表示第 $i$ 块木板刷了 $j$ 次，且第 $j$ 次刷到了该木板的第 $k$ 格时能正确粉刷的格子数量。</p><p>显然，对于每一块木板 $i$ ，有</p><script type="math/tex; mode=display">dp_p(i,j,k)=\max\{dp(i,j-1,l)+\max\left(sum_0\left(l+1,k\right),sum_1\left(l+1,k\right)\right)\},l\in[0,k)</script><p>其中 $sum_0(l,r)$ 与 $sum_1(l,r)$ 分别表示从 $l$ 格到 $r$ 格内$0$的数量与$1$的数量。</p><p>搞出 $dp_p$ 后，直接用其分组背包即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500+5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,T,sum_1[N][N],sum_0[N][N],dpb[N][N][N],dp[MAXN];</span><br><span class="line"><span class="built_in">string</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">sum_1[i][j+<span class="number">1</span>]=sum_1[i][j];</span><br><span class="line">sum_0[i][j+<span class="number">1</span>]=sum_0[i][j];</span><br><span class="line"><span class="keyword">if</span>(w[i][j]==<span class="string">'0'</span>) sum_0[i][j+<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span> sum_1[i][j+<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;T;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(T,m);j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;k;l++) dpb[i][j][k]=max(dpb[i][j][k],dpb[i][j<span class="number">-1</span>][l]+max(sum_0[i][k]-sum_0[i][l],sum_1[i][k]-sum_1[i][l]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=T;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=min(j,m);k++) &#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-k]+dpb[i][k][m]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[T]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包 </tag>
            
            <tag> SCOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对拍学习笔记</title>
      <link href="/is-zxy.github.io/2020/05/06/%E5%AF%B9%E6%8B%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/05/06/%E5%AF%B9%E6%8B%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>日常做题时，总会遇到些错误，而且查不出来。</p><p>更艹蛋的是，OJ还不公开数据。</p><p>这时候就需要对拍了。</p><a id="more"></a><p>首先，需要编写一个生成数据的文件。</p><h2 id="随机数据生成"><a href="#随机数据生成" class="headerlink" title="随机数据生成"></a>随机数据生成</h2><p>了解三个东西：<code>RAND_MAX</code>、<code>rand()</code>、<code>srand(seed)</code>。</p><p><code>RAND_MAX</code>是一个不小于$32767$的整数常量，它的值与操作系统环境、编译器环境有关。</p><p><code>rand()</code>函数返回一个 $0\sim RAND_MAX$ 之间的随机整数$int$。</p><p><code>srand(seed)</code>函数接受<code>unsigned int</code>类型的参数<code>seed</code>，以<code>seed</code>为“随机种子”。</p><p>当种子确定后，接下来产生的随机数列就是固定的。因此，一般在随机数据生成程序<code>main</code>函数的开头，用当前系统时间作为随机种子。<code>time(0)</code>可以返回从$1970$年$1$月$1$日$0$时$0$分$0$秒到现在的秒数。执行 <code>srand((unsigned)time(0))</code> 即可初始化随机种子。</p><p>以下提供一个大概的随机数据生成模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)rand()*rand()%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//具体内容……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据题目要求，生成数据。</p><h1 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h1><p>现在编好了随机数据生成的程序<code>data.cpp</code>，该程序生成数据到<code>data.in</code>中。</p><p>还需两个程序：一个正解或暴力程序<code>cor.cpp</code>，该程序从<code>data.in</code>中读取数据，输出答案到<code>data.ans</code>中；一个自己的待测程序<code>sol.cpp</code>，该程序从<code>data.in</code>中读取数据，输出答案到<code>data.out</code>中。</p><p>将这三个程序编译后，在$\mathrm{Windows}$系统下可得到三个文件<code>data.exe</code>、<code>cor.exe</code>、<code>sol.exe</code>。</p><p>接下来需要编写一个脚本<code>对拍.bat</code>。</p><ul><li><p>新建一个记事本。</p></li><li><p>在其中输入以下代码</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off//关闭回显</span><br><span class="line">:loop//执行循环</span><br><span class="line">data.exe//执行data.exe</span><br><span class="line">cor.exe//执行cor.exe</span><br><span class="line">sol.exe//执行sol.exe</span><br><span class="line">fc data.out data.ans//对比data.out与data.ans是否一致</span><br><span class="line">if not errorlevel 1 goto loop//若一致继续循环</span><br><span class="line">pause//若不一致暂停程序，显示出错结果</span><br><span class="line">:<span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将记事本的扩展名改为<code>.bat</code>。</p></li></ul><p>执行<code>对拍.bat</code>，便开始对拍了。</p><p>遇到错误会停止，显示出错的结果。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>拿一道题举个例子吧。</p><p>如 <a href="https://www.luogu.com.cn/problem/P1968" target="_blank" rel="noopener">[洛谷P1968] 美元汇率</a>。</p><p>一开始打了一份这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N],f[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) f[i]=max(f[i],g[j]/a[i]*<span class="number">100</span>),g[i]=max(g[i],f[j]/<span class="number">100</span>*a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交后……华丽的50分呢！</p><p><img src="https://wx1.sbimg.cn/2020/05/20/1674ac55fc8e361f2.png" alt="Y7xOQP.png"></p><p>于是从从题解里蒯一个正解下来命名为<code>cor.cpp</code>（这里我用的是自己的正解），也可以是自己打的暴力，当然，如果是比赛的话，那只能是自己打的暴力了。</p><p><img src="https://wx2.sbimg.cn/2020/05/20/1cb00b16bdbf30439.png" alt="1cb00b16bdbf30439.png"></p><p>然后是自己的待测代码</p><p><img src="https://wx1.sbimg.cn/2020/05/20/228512eaac405f59a.png" alt="228512eaac405f59a.png"></p><p>还有一个数据生成代码</p><p><img src="https://wx2.sbimg.cn/2020/05/20/17c792a0995b27228.png" alt="17c792a0995b27228.png"></p><p>然后在它们的目录中建立一个<code>对拍.bat</code></p><p><img src="https://wx2.sbimg.cn/2020/05/20/1a058f7dc24ea94c8.png" alt="1a058f7dc24ea94c8.png"></p><p>更改后缀名。</p><p><img src="https://wx1.sbimg.cn/2020/05/20/1163707cb8dd622b0.png" alt="1163707cb8dd622b0.png"></p><p>然后执行</p><p>就能发现错误的啦！</p><p><img src="https://wx1.sbimg.cn/2020/05/20/135fdb22264e49f9f.png" alt="135fdb22264e49f9f.png"></p><p>根据生成的数据来纠错即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《算法竞赛进阶指南》</p><p><a href="https://www.cnblogs.com/CXYscxy/p/11158900.html" target="_blank" rel="noopener">[详解—对拍]</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当做题提交出错，而OJ不开放数据时，可以将别人的正解代码或自己的暴力拿来对拍。</p><p>当比赛时，可以打个暴力，然后将自己打的“自认为正解”与暴力进行对拍。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 常用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI Online #2 提高组] 子序列问题</title>
      <link href="/is-zxy.github.io/2020/05/04/%5BNOI-Online-2-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/is-zxy.github.io/2020/05/04/%5BNOI-Online-2-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 $n$ 的正整数序列 $A_1, A_2,\cdots⋯, A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。</p><p>现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；</p><p>对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；</p><p>对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；</p><p>对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；</p><p>对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6477" target="_blank" rel="noopener">[NOI Online #2 提高组]子序列问题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用map可写出个$O(n^2\log n)$的暴力。</p><p>枚举左端点，即$\sum\limits_{l=1}^rf^2(l,r)$。</p><p>那么将数一个一个加入其中，每次<code>r++​</code>，然后答案累加目前的$\sum\limits_{l=1}^rf^2(l,r)$即可。</p><p>那么考虑每次加入一个数后，如何求出$\sum\limits_{l=1}^rf^2(l,r)$。</p><p>用线段树维护，线段树中的单点$i$即表示$f(i,r)$的信息，区间即为区间内点的信息和。</p><p>如若要维护区间平方和的话，则需要用线段树维护区间和与区间平方和，这个很容易想。</p><p>那么每次的$\sum\limits_{l=1}^rf^2(l,r)$即为线段树根记录的区间平方和值。</p><p>现在只剩下，如何解决每次加入一个数的问题。</p><p>考虑用一个数组$rec[x]$表示数$x$出现的上一个位置在哪里（初始化为$0$）。每次加入第$r$个数$x$时，将区间$[rec[x]+1,r]$内每个$f(i,r)$的值加$1$，并维护区间平方和（因为这区间内的$[i,r]$间数$x$只有$1$个，而其之前出现过，因此对$i\in[1,rec[x]]$的$f(i,r)$没有贡献）。这样就可以保证加入一个数后，线段树所维护的信息由$f(i,r-1)$变为$f(i,r)$。</p><p>当然，数大小 $10^9$，先要离散化。</p><p>时间复杂度$O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,b[N],a[N],rec[N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,sos,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss(x) tree[x].sos</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">a[i]=lower_bound(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">ss(p)=ss(ls)+ss(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">s(p)=ss(p)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line">ss(ls)+=<span class="number">2</span>*s(ls)*lazy(p)+(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">s(ls)+=(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">lazy(ls)+=lazy(p);</span><br><span class="line">ss(rs)+=<span class="number">2</span>*s(rs)*lazy(p)+(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">s(rs)+=(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">lazy(rs)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r(p)&lt;l||l(p)&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">ss(p)+=<span class="number">2</span>*s(p)*x+(r(p)-l(p)+<span class="number">1</span>)*x*x;</span><br><span class="line">s(p)+=(r(p)-l(p)+<span class="number">1</span>)*x;</span><br><span class="line">lazy(p)+=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(rec,<span class="number">0</span>,<span class="keyword">sizeof</span>(rec));</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">discre();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">change(<span class="number">1</span>,rec[a[i]]+<span class="number">1</span>,i,<span class="number">1</span>);</span><br><span class="line">rec[a[i]]=i;</span><br><span class="line">ans+=ss(<span class="number">1</span>);</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，由于线段树常数过大，各种玄学优化后，不开O2的话也只能在很玄学的情况下很玄学地只T了一个点。</p><p>事实上，我这种写法，观察可发现对于维护的区间平方和，只用到了根节点的信息，其所有的子区间的区间平方和都没有用到。</p><p>于是考虑优化。每一次区间修改后的整体平方和是可以由前一次推来的。设前一次整体平方和为$sos_{i-1}$，那么区间修改后的整体平方和$sos_i=sos_{i-1}+2\times sum(l,r)+(r-l+1)$，其中$l$与$r$表示本次被修改的区间的左右端点，这个很好推。</p><p>那么就没有必要维护区间平方和，仅需维护区间和。然而用常数大的线段树的话，多了一个查询操作，时间复杂度可能更大了。</p><p>仅需维护区间和的话，那么就考虑用常数小的树状数组来维护。由于区间修改，则用两个树状数组维护即可，时间复杂度$O(n\log n)$。</p><p>不加任何优化能AC。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],rec[N];</span><br><span class="line">ll d[N],s[N],ans=<span class="number">0</span>,sos=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=lower_bound(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ll t=x;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) d[x]+=y,s[x]+=t*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=(t+<span class="number">1</span>)*d[x]-s[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">b[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(rec,<span class="number">0</span>,<span class="keyword">sizeof</span>(rec));</span><br><span class="line">discre();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">sos+=<span class="number">2</span>*(ask(i)-ask(rec[a[i]]))+i-rec[a[i]];</span><br><span class="line">ans+=sos;</span><br><span class="line">ans%=mod;</span><br><span class="line">update(rec[a[i]]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">update(i+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">rec[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> NOI Online </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI Online #2 提高组] 涂色游戏</title>
      <link href="/is-zxy.github.io/2020/05/02/%5BNOI-Online-2-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E6%B6%82%E8%89%B2%E6%B8%B8%E6%88%8F/"/>
      <url>/is-zxy.github.io/2020/05/02/%5BNOI-Online-2-%E6%8F%90%E9%AB%98%E7%BB%84%5D-%E6%B6%82%E8%89%B2%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>你有 $10^{20}$ 个格子，它们从 $0$ 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色：</p><ol><li>编号是 $p_1$ 倍数的格子（包括 $0$ 号格子，下同）染成红色。</li><li>编号是 $p_2$ 倍数的格子染成蓝色。</li><li>编号既是 $p_1$ 倍数又是 $p_2$ 倍数的格子，你可以选择染成红色或者蓝色。</li></ol><p>其中 $p_1$ 和 $p_2$ 是给定的整数，若格子编号是 $p_1$ 或 $p_2$ 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 $k$ 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 $p_1$, $p_2$, $k$，你想知道是否有一种染色方案不是无聊的。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><div class="table-container"><table><thead><tr><th style="text-align:left">测试点编号</th><th style="text-align:left">$p_1,p_2 \leq$</th><th style="text-align:left">$k \leq$</th><th style="text-align:left">$T \leq$</th></tr></thead><tbody><tr><td style="text-align:left">$1 \sim 3$</td><td style="text-align:left">$15$</td><td style="text-align:left">$15$</td><td style="text-align:left">$3375$</td></tr><tr><td style="text-align:left">$4 \sim 6$</td><td style="text-align:left">$10^3$</td><td style="text-align:left">$10^3$</td><td style="text-align:left">$10^4$</td></tr><tr><td style="text-align:left">$7 \sim 8$</td><td style="text-align:left">$10^3$</td><td style="text-align:left">$10^3$</td><td style="text-align:left">$10$</td></tr><tr><td style="text-align:left">$9 \sim 10$</td><td style="text-align:left">$10^5$</td><td style="text-align:left">$10^3$</td><td style="text-align:left">$10^3$</td></tr><tr><td style="text-align:left">$11 \sim 12$</td><td style="text-align:left">$10^5$</td><td style="text-align:left">$5 \times 10^5$</td><td style="text-align:left">$10$</td></tr><tr><td style="text-align:left">$13 \sim 14$</td><td style="text-align:left">$10^5$</td><td style="text-align:left">$5 \times 10^5$</td><td style="text-align:left">$10^5$</td></tr><tr><td style="text-align:left">$15$</td><td style="text-align:left">$10^9$</td><td style="text-align:left">$10^9$</td><td style="text-align:left">$10$</td></tr><tr><td style="text-align:left">$16 \sim 20$</td><td style="text-align:left">$10^9$</td><td style="text-align:left">$10^9$</td><td style="text-align:left">$10^6$</td></tr></tbody></table></div><p>对于所有测试点：$1 \leq T\leq 10^6$，$1\leq p_1,p_2,k\le 10^9$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6476" target="_blank" rel="noopener">[NOI Online #2 提高组]涂色游戏</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不妨令$p_2\ge p_1$。</p><p>如若有连续$k$个相同色的话，考虑为两个$p_2$的倍数中间，有$k$个$p_1$的倍数。</p><p>两个$p_2$的倍数中间最多有$\dfrac{p_2-2}{p_1}+1$个$p_1$的倍数。</p><p>于是比较$\dfrac{p_2-2}{p_1}+1$与$k$的大小即可。</p><p>由于有$10^{20}$个格子，$p_1,p_2\le 10^9$，易得一个循环的长度为$\mathrm{lcm}(p_1,p_2)$，其显然小于$10^{20}$，于是直接比较即可，无须判断是否超出$10^{20}$格。</p><p>坑点，特判$k=1$的情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !y?x:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">ll p,q,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;p,&amp;q,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p&gt;q) swap(p,q);</span><br><span class="line">ll GCD=gcd(p,q);</span><br><span class="line">p/=GCD;</span><br><span class="line">q/=GCD;</span><br><span class="line">(q&gt;<span class="number">2</span>)&amp;&amp;((q<span class="number">-2</span>)/p+<span class="number">1</span>&gt;=k)?<span class="built_in">printf</span>(<span class="string">"NO\n"</span>):<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> NOI Online </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1126] 机器人搬重物</title>
      <link href="/is-zxy.github.io/2020/05/02/%5B%E6%B4%9B%E8%B0%B7P1126%5D-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9/"/>
      <url>/is-zxy.github.io/2020/05/02/%5B%E6%B4%9B%E8%B0%B7P1126%5D-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AC%E9%87%8D%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>机器人移动学会（<code>RMI</code>）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N \times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动 $1$ 步（<code>Creep</code>）；向前移动 $2$ 步（<code>Walk</code>）；向前移动 $3$ 步（<code>Run</code>）；向左转（<code>Left</code>）；向右转（<code>Right</code>）。每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/39.png" alt="img"></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N,M\le 50$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1126" target="_blank" rel="noopener">P1126 机器人搬重物</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>观察图可发现，机器人在点上，而障碍却在格子上。</p><p>可以将格子障碍转化为点障碍，即一个障碍提供四个点障碍。</p><p>据此处理完后直接当迷宫问题bfs即可。</p><p>一个坑点，机器人为一个直径 $1.6$ 米的球，那么就不能在边界走。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N][N],sx,sy,ex,ey,sdir,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> vh[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="built_in">string</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,step,dir;</span><br><span class="line">node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _step,<span class="keyword">int</span> _dir):x(_x),y(_y),step(_step),dir(_dir)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dir,<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dir==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y+s&gt;=m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(vh[x][y+s][dir]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) <span class="keyword">if</span>(a[x][y+i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dir==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x+s&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(vh[x+s][y][dir]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) <span class="keyword">if</span>(a[x+i][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dir==<span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(vh[x][y-s][dir]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) <span class="keyword">if</span>(a[x][y-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dir==<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(vh[x-s][y][dir]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) <span class="keyword">if</span>(a[x-i][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">q.push(node(sx,sy,<span class="number">0</span>,sdir));</span><br><span class="line">vh[sx][sy][sdir]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sx==ex&amp;&amp;sy==ey) &#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">node head=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(head.dir&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[head.x][head.y][<span class="number">2</span>]) q.push(node(head.x,head.y,head.step+<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="keyword">if</span>(!vh[head.x][head.y][<span class="number">4</span>]) q.push(node(head.x,head.y,head.step+<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">vh[head.x][head.y][<span class="number">2</span>]=vh[head.x][head.y][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[head.x][head.y][<span class="number">1</span>]) q.push(node(head.x,head.y,head.step+<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(!vh[head.x][head.y][<span class="number">3</span>]) q.push(node(head.x,head.y,head.step+<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">vh[head.x][head.y][<span class="number">1</span>]=vh[head.x][head.y][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(check(head.x,head.y,head.dir,i)) &#123;</span><br><span class="line"><span class="keyword">if</span>(head.dir==<span class="number">1</span>) &#123;</span><br><span class="line">vh[head.x][head.y+i][head.dir]=<span class="number">1</span>;</span><br><span class="line">q.push(node(head.x,head.y+i,head.step+<span class="number">1</span>,head.dir));</span><br><span class="line"><span class="keyword">if</span>(head.x==ex&amp;&amp;head.y+i==ey) &#123;</span><br><span class="line">ans=head.step+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.dir==<span class="number">2</span>) &#123;</span><br><span class="line">vh[head.x+i][head.y][head.dir]=<span class="number">1</span>;</span><br><span class="line">q.push(node(head.x+i,head.y,head.step+<span class="number">1</span>,head.dir));</span><br><span class="line"><span class="keyword">if</span>(head.x+i==ex&amp;&amp;head.y==ey) &#123;</span><br><span class="line">ans=head.step+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.dir==<span class="number">3</span>) &#123;</span><br><span class="line">vh[head.x][head.y-i][head.dir]=<span class="number">1</span>;</span><br><span class="line">q.push(node(head.x,head.y-i,head.step+<span class="number">1</span>,head.dir));</span><br><span class="line"><span class="keyword">if</span>(head.x==ex&amp;&amp;head.y-i==ey) &#123;</span><br><span class="line">ans=head.step+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.dir==<span class="number">4</span>) &#123;</span><br><span class="line">vh[head.x-i][head.y][head.dir]=<span class="number">1</span>;</span><br><span class="line">q.push(node(head.x-i,head.y,head.step+<span class="number">1</span>,head.dir));</span><br><span class="line"><span class="keyword">if</span>(head.x-i==ex&amp;&amp;head.y==ey) &#123;</span><br><span class="line">ans=head.step+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(x) a[i][j]=a[i][j+<span class="number">1</span>]=a[i+<span class="number">1</span>][j]=a[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey&gt;&gt;d;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="string">"E"</span>) sdir=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="string">"S"</span>) sdir=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="string">"W"</span>) sdir=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="string">"N"</span>) sdir=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1441] 砝码称重</title>
      <link href="/is-zxy.github.io/2020/05/01/%5B%E6%B4%9B%E8%B0%B7P1441%5D-%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D/"/>
      <url>/is-zxy.github.io/2020/05/01/%5B%E6%B4%9B%E8%B0%B7P1441%5D-%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>现有 $n$ 个砝码，重量分别为 $a_i$，在去掉 $m$ 个砝码后，问最多能称量出多少不同的重量（不包括 $0$）。</p><p>请注意，砝码只能放在其中一边。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $20\%$ 的数据，$m=0$。</p><p>对于 $50\%$ 的数据，$m\leq 1$。</p><p>对于 $50\%$ 的数据，$n\leq 10$。</p><p>对于 $100\%$ 的数据，$n\leq 20$， $m\leq 4$，$m &lt; n$，$a_i\leq 100$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1441" target="_blank" rel="noopener">P1441 砝码称重</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不考虑去砝码的话就是个背包。</p><p>考虑去砝码，还是个背包，只需要枚举选了$n-m$个砝码的所有情况，对每个情况都背包即可。</p><p>时间复杂度$O(C_n^m\times m\times a_{tot})$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N],dp[MAXN],sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> js)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(js==n-m) &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;js;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=chosen[i];j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[j]||!dp[j-chosen[i]]) <span class="keyword">continue</span>;</span><br><span class="line">dp[j]=dp[j-chosen[i]];</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,tmp);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">chosen.push_back(a[x]);</span><br><span class="line">sum+=a[x];</span><br><span class="line">dfs(x+<span class="number">1</span>,js+<span class="number">1</span>);</span><br><span class="line">chosen.pop_back();</span><br><span class="line">sum-=a[x];</span><br><span class="line">dfs(x+<span class="number">1</span>,js);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> DFS </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1156] 垃圾陷阱</title>
      <link href="/is-zxy.github.io/2020/04/29/%5B%E6%B4%9B%E8%B0%B7P1156%5D-%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1/"/>
      <url>/is-zxy.github.io/2020/04/29/%5B%E6%B4%9B%E8%B0%B7P1156%5D-%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为$D(2 \le D \le 100)$英尺。</p><p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p><p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p><p>假设卡门预先知道了每个垃圾扔下的时间$t(0&lt; t \le 1000)$，以及每个垃圾堆放的高度$h(1 \le h \le 25)$和吃进该垃圾能维持生命的时间$f(1 \le f \le 30)$，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续$10$小时的能量，如果卡门$10$小时内没有进食，卡门就将饿死。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1156" target="_blank" rel="noopener">P1156 垃圾陷阱</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始题意理解错，虐了我好长时间。后来傻逼错误数组开小，又好长时间才查出来。。</p><p>定义状态$(pos,l,h)$表示目前正在对第$pos$个垃圾进行操作，奶牛能活到时间$l$，目前所在高度为$h$。</p><p>显然对于第$pos$个垃圾，可以吃也可以堆，状态变为$(pos+1,l+r_{pos},h)$或$(pos+1,l,h+h_{pos})$。</p><p>于是可以写出个暴搜来，然后加个记忆化可以过。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d,g,ft=<span class="number">10</span>,dp[N][<span class="number">3010</span>][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,f,h;</span><br><span class="line">&#125;r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.t&lt;y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&gt;g||l&lt;r[pos].t) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(h+r[pos].h&gt;=d) <span class="keyword">return</span> r[pos].t;</span><br><span class="line"><span class="keyword">if</span>(dp[pos][l][h]) <span class="keyword">return</span> dp[pos][l][h];</span><br><span class="line"><span class="keyword">return</span> dp[pos][l][h]=min(dfs(pos+<span class="number">1</span>,l+r[pos].f,h),dfs(pos+<span class="number">1</span>,l,h+r[pos].h));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;d&gt;&gt;g;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++) <span class="built_in">cin</span>&gt;&gt;r[i].t&gt;&gt;r[i].f&gt;&gt;r[i].h;</span><br><span class="line"></span><br><span class="line">sort(r+<span class="number">1</span>,r+g+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ft&lt;r[i].t) <span class="keyword">break</span>;</span><br><span class="line">ft+=r[i].f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dfs(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0</span>)!=INF) <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][<span class="number">10</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ft&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CQOI2011] 动态逆序对</title>
      <link href="/is-zxy.github.io/2020/04/26/%5BCQOI2011%5D-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/is-zxy.github.io/2020/04/26/%5BCQOI2011%5D-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<p>对于序列 $a$，它的逆序对数定义为集合</p><script type="math/tex; mode=display">\{(i,j)| i<j \wedge a_i > a_j \}</script><p>中的元素个数。</p><p>现在给出 $1\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，你的任务是在每次删除一个元素<strong>之前</strong>统计整个序列的逆序对数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 10^5$</p><p>$1\le m \le 50000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3157" target="_blank" rel="noopener">[CQOI2011]动态逆序对</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>太菜只会分块。</p><p>极其暴力。</p><p>先归并排序求出原序列逆序对个数$ans$。</p><p>每次删除数$x$，设其属于块$q$，则在第$1\sim q-1$块中二分找比$x$大的数的个数，在$q+1\sim t$（其中$t$表示总块数）中二分找比$x$小的数的个数，在第$q$块内，数$x$前后找逆序对个数。用$ans$减去这些个数即可。</p><p>删除可二分找地址，用<code>vector</code>的<code>erase</code>操作。</p><p>时间复杂度$O(\sqrt n \log\sqrt n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N],p[N],L[N],R[N],pos[N],tmp1[N],tmp2[N],t;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;l) MergeSort(l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;r) MergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> k=l,t1=l,t2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t1&lt;=mid&amp;&amp;t2&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp1[t1]&lt;=tmp1[t2])&#123;</span><br><span class="line">            tmp2[k++]=tmp1[t1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans+=(mid-t1+<span class="number">1</span>);</span><br><span class="line">            tmp2[k++]=tmp1[t2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t1&lt;=mid) tmp2[k++]=tmp1[t1++];</span><br><span class="line">    <span class="keyword">while</span>(t2&lt;=r) tmp2[k++]=tmp1[t2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) tmp1[i]=tmp2[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line">pos[j]=i;</span><br><span class="line">b[i].push_back(a[j]);</span><br><span class="line">&#125;</span><br><span class="line">sort(b[i].begin(),b[i].end());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=pos[x];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=lower_bound(b[q].begin(),b[q].end(),a[x]);</span><br><span class="line">b[q].erase(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=pos[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;q;i++) ans-=b[i].end()-upper_bound(b[i].begin(),b[i].end(),a[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;x;i++) ans-=(a[i]&gt;a[x]&amp;&amp;!vh[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;=R[q];i++) ans-=(a[i]&lt;a[x]&amp;&amp;!vh[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=q+<span class="number">1</span>;i&lt;=t;i++) ans-=lower_bound(b[i].begin(),b[i].end(),a[x])-b[i].begin();</span><br><span class="line">vh[x]=<span class="number">1</span>;</span><br><span class="line">reset(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">p[a[i]]=i;</span><br><span class="line">tmp1[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">MergeSort(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">solve(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CQOI </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BZOJ#2252] 矩阵距离</title>
      <link href="/is-zxy.github.io/2020/04/22/%5BBZOJ-2252%5D-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB/"/>
      <url>/is-zxy.github.io/2020/04/22/%5BBZOJ-2252%5D-%E7%9F%A9%E9%98%B5%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>给定一个$N$行$M$列的$01$矩阵$A$。</p><p>定义$dist(A[i][j],A[k][l])=|i-k|+|j-l|$。</p><p>输出一个$N$行$M$列的整数矩阵$B$，其中：</p><script type="math/tex; mode=display">B[i][j]=\min_{1\le x\le N,1\le y\le M,A[x][y]=1}\{dist(A[i][j],A[x][y])\}</script><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N,M\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://darkbzoj.tk/problem/2252" target="_blank" rel="noopener">#2252. [2010Beijing wc]矩阵距离</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>若$A$中一个位置本来就为$1$，显然对应的在$B$中位置为$0$。</p><p>其余$A$中非$1$的位置，即由$1$位置扩展来，可以看成一个多源点的求到每格的最小步数问题。</p><p>因此bfs瞎搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> d[N][N],n,m;</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"><span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j]==<span class="string">'1'</span>) q.push(make_pair(i,j+<span class="number">1</span>)),d[i][j+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; head=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; next(head.first+dx[i],head.second+dy[i]);</span><br><span class="line"><span class="keyword">if</span>(next.first&lt;<span class="number">1</span>||next.second&lt;<span class="number">1</span>||next.first&gt;n||next.second&gt;m||d[next.first][next.second]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">d[next.first][next.second]=d[head.first][head.second]+<span class="number">1</span>;</span><br><span class="line">q.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">cout</span>&lt;&lt;d[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[国家集训队] 排队</title>
      <link href="/is-zxy.github.io/2020/04/20/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D-%E6%8E%92%E9%98%9F/"/>
      <url>/is-zxy.github.io/2020/04/20/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D-%E6%8E%92%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>排排坐，吃果果，生果甜嗦嗦，大家笑呵呵。你一个，我一个，大的分给你，小的留给我，吃完果果唱支歌，大家乐和和。</p><p>红星幼儿园的小朋友们排起了长长地队伍，准备吃果果。不过因为小朋友们的身高有所区别，排成的队伍高低错乱，极不美观。设第 $i$ 个小朋友的身高为 $h_i$。</p><p>幼儿园阿姨每次会选出两个小朋友，交换他们的位置，请你帮忙计算出每次交换后，序列的逆序对数。为方便幼儿园阿姨统计，在未进行任何交换操作时，你也应该输出该序列的逆序对数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于 $15\%$ 的数据，$n,m \le 15$；<br>对于 $30\%$ 的数据，$n,m \le 200$；<br>另有 $15\%$ 的数据，$h_i$​ 各不相同；<br>另有 $15\%$ 的数据，$110 \le h_i \le 160$；<br>以上两类数据交集为空。</p><p>对于 $100\%$ 的数据，$1 \le m \le 2\times 10^3$，$1 \le n \le 2 \times 10^4$，$1 \le h_i \le 10^9$，$a_i \ne b_i$，$1 \le a_i,b_i \le n$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1975" target="_blank" rel="noopener">[国家集训队]排队</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><del>我喜欢暴力数据结构，所以我就用暴力分块解决了本题。</del></p><p>先归并排序求出原本序列的逆序对数。之后每次操作都在其基础上进行加减即可。</p><p>假设交换了$x$与$y$位置上的数$h[x]$与$h[y],(x&lt; y)$，则在区间$(x,y)$内，一个数大于$h[x]$或小于$h[y]$则逆序对数增加一对，反之则减少一对。</p><p>据此，分块维护，二分查询块内与大于或小于$h[x]$以及$h[y]$的数的数量，更改当前序列内逆序对数即可。</p><p>应该都是分块的基本操作。</p><p>当然还有<del>我不会的</del>更高效的树套树啥的解法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,h[N],L[N],R[N],tmp[N],p[N],pos[N],t,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;l) MergeSort(l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;r) MergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> k=l,t1=l,t2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t1&lt;=mid&amp;&amp;t2&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[t1]&lt;=tmp[t2])&#123;</span><br><span class="line">            p[k++]=tmp[t1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans+=mid-t1+<span class="number">1</span>;</span><br><span class="line">            p[k++]=tmp[t2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t1&lt;=mid) p[k++]=tmp[t1++];</span><br><span class="line">    <span class="keyword">while</span>(t2&lt;=r) p[k++]=tmp[t2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) tmp[i]=p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line">pos[j]=i;</span><br><span class="line">b[i].push_back(h[j]);</span><br><span class="line">&#125;</span><br><span class="line">sort(b[i].begin(),b[i].end());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">b[x].clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) b[x].push_back(h[i]);</span><br><span class="line">sort(b[x].begin(),b[x].end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_one</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">l+=(l==x);</span><br><span class="line">r-=(r==y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line">ans+=(h[x]&lt;h[i]);</span><br><span class="line">ans+=(h[y]&gt;h[i]);</span><br><span class="line">ans-=(h[x]&gt;h[i]);</span><br><span class="line">ans-=(h[y]&lt;h[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_block</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>;i&lt;r;i++) &#123;</span><br><span class="line">ans+=b[i].end()-upper_bound(b[i].begin(),b[i].end(),h[x]);</span><br><span class="line">ans-=lower_bound(b[i].begin(),b[i].end(),h[x])-b[i].begin();</span><br><span class="line">ans+=lower_bound(b[i].begin(),b[i].end(),h[y])-b[i].begin();</span><br><span class="line">ans-=b[i].end()-upper_bound(b[i].begin(),b[i].end(),h[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[x],q=pos[y];</span><br><span class="line">ans+=(h[x]&lt;h[y]);</span><br><span class="line">ans-=(h[x]&gt;h[y]);</span><br><span class="line"><span class="keyword">if</span>(p==q) solve_one(x,y,x,y);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">solve_one(x,R[p],x,y);</span><br><span class="line">solve_block(p,q,x,y);</span><br><span class="line">solve_one(L[q],y,x,y);</span><br><span class="line">&#125;</span><br><span class="line">swap(h[x],h[y]);</span><br><span class="line">reset(p);</span><br><span class="line">reset(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">tmp[i]=h[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">MergeSort(<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line">solve(x,y);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 国家集训队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4198] 楼房重建</title>
      <link href="/is-zxy.github.io/2020/04/19/%5B%E6%B4%9B%E8%B0%B7P4198%5D-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/"/>
      <url>/is-zxy.github.io/2020/04/19/%5B%E6%B4%9B%E8%B0%B7P4198%5D-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>小 A 的楼房外有一大片施工工地，工地上有 $N$ 栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。</p><p>为了简化问题，我们考虑这些事件发生在一个二维平面上。小 A 在平面上 $(0,0)$ 点的位置，第 $i$ 栋楼房可以用一条连接 $(i,0)$ 和 $(i,H_i)$ 的线段表示，其中 $H_i$ 为第 $i$ 栋楼房的高度。如果这栋楼房上任何一个高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。</p><p>施工队的建造总共进行了 $M$ 天。初始时，所有楼房都还没有开始建造，它们的高度均为 $0$。在第 $i$ 天，建筑队将会将横坐标为 $X_i$ 的房屋的高度变为 $Y_i$（高度可以比原来大——修建，也可以比原来小——拆除，甚至可以保持不变——建筑队这天什么事也没做）。请你帮小 A 数数每天在建筑队完工之后，他能看到多少栋楼房？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le X_i\le N$，$1\le Y_i\le 10^9$，$1\le N,M\le 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4198" target="_blank" rel="noopener">P4198 楼房重建</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑暴力。</p><p>从$1$到$N$遍历，记录目前点之前的<strong>斜率</strong>最大值为$last$，则如果该楼能被看到，其斜率一定大于$last$，于是继续更新$last$。最终遍历到$N$即可。</p><p>嘛，这只是个求能看到楼房个数的思路。由此可以想到，可以用分块维护每个块内<strong>单调递增</strong>的楼房。</p><p>修改直接单点修改，但是同时也要更新块内元素。</p><p>查询与上面那个遍历差不多，只不过$last$变成了<strong>之前的块</strong>的斜率最大值，并据此在每个块内二分求出个数累加即可。</p><p>时间复杂度$O(\sqrt N \log \sqrt N)$。</p><p>注意当$\mathrm{vector}$为空时不可以<code>upper_bound</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,pos[N],L[N],R[N],t;</span><br><span class="line"><span class="keyword">double</span> h[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">b[x].clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(h[i]&gt;tmp) &#123;</span><br><span class="line">b[x].push_back(h[i]);</span><br><span class="line">tmp=h[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(b[x].begin(),b[x].end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[x],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> last=<span class="number">0</span>;</span><br><span class="line">h[x]=(<span class="keyword">double</span>)y/x;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!b[i].size()) <span class="keyword">continue</span>;</span><br><span class="line">ans+=b[i].size()-(upper_bound(b[i].begin(),b[i].end(),last)-b[i].begin());</span><br><span class="line">last=max(last,b[i].back());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(x,y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[AcWing1050] 鸡蛋的硬度</title>
      <link href="/is-zxy.github.io/2020/04/12/%5BAcWing1050%5D-%E9%B8%A1%E8%9B%8B%E7%9A%84%E7%A1%AC%E5%BA%A6/"/>
      <url>/is-zxy.github.io/2020/04/12/%5BAcWing1050%5D-%E9%B8%A1%E8%9B%8B%E7%9A%84%E7%A1%AC%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。</p><p>参赛者是来自世界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法–从高度扔鸡蛋–来测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第 $a$ 层摔下来没摔破，但是从 $a+1$ 层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是 $a$ 。</p><p>你当然可以找出各种理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从 $100$ 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样–这比赛不过是XX公司的一个另类广告而已。</p><p>勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。</p><p>“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有 $1$ 个鸡蛋，那么我就不得不从第 $1$ 层楼开始一层一层的扔，最坏情况下我要扔 $100$ 次。如果有 $2$ 个鸡蛋，那么就从 $ 2$  层楼开始的地方扔……等等，不对，好像应该从 $1/3$ 的地方开始扔才对，嗯，好像也不一定啊…… $3$ 个鸡蛋怎么办，$4$ 个，$5$ 个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。</p><p>好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100$</p><p>$1\le m \le 10$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.acwing.com/problem/content/1050/" target="_blank" rel="noopener">1048. 鸡蛋的硬度</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相当经典的一题。</p><p>其实老早就看过，不过读不懂题。今天看了<a href="https://www.bilibili.com/video/BV1KE41137PK" target="_blank" rel="noopener">李永乐老师的视频</a>后才懂。</p><p>定义$dp[i][j]$表示$i$层楼，$j$个鸡蛋，最坏情况的最小值。</p><p>状态转移，枚举扔的楼层$k$，分类讨论：</p><ul><li>蛋在第$k$层碎了，那么说明蛋硬度在$[1,k-1]$之间，蛋少了一个，则方案为$dp[k-1][j-1]$。</li><li>蛋没碎，说明蛋硬度在$[k,i]$之间，蛋没少，则方案为$dp[i-k][j]$。</li></ul><p>由于要最坏情况，则取这两个值的较大值。由于扔了一次，所以还需加$1$。</p><p>则</p><script type="math/tex; mode=display">dp[i][j]=\min\{\max(dp[k-1][j-1],dp[i-k][j])+1\}</script><p>初始化$dp[i][1]$为$i$，$dp[1][i]$为$1$，其余均为一个较大值，我初始化为$i$的。</p><p>时间复杂度$O(n^2m)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,dp[N][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[i][j]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[i][j],max(dp[k<span class="number">-1</span>][j<span class="number">-1</span>],dp[i-k][j])+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2016] 愤怒的小鸟</title>
      <link href="/is-zxy.github.io/2020/04/09/%5BNOIP2016%5D-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/"/>
      <url>/is-zxy.github.io/2020/04/09/%5BNOIP2016%5D-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
      
        <content type="html"><![CDATA[<p><code>Kiana</code> 最近沉迷于一款神奇的游戏无法自拔。</p><p>简单来说，这款游戏是在一个平面上进行的。</p><p>有一架弹弓位于 $(0,0)$ 处，每次 <code>Kiana</code> 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是<code>Kiana</code> 指定的参数，且必须满足 $a &lt; 0$，$a,b$ 都是实数。</p><p>当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。</p><p>在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。 </p><p>如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；</p><p>如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。</p><p>例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，<code>Kiana</code> 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。</p><p>而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。</p><p>这款神奇游戏的每个关卡对 <code>Kiana</code>来说都很难，所以<code>Kiana</code>还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。</p><p>假设这款游戏一共有 $T$ 个关卡，现在 <code>Kiana</code>想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p><img src="C:\Users\Administrator\Desktop\2.png" alt=""></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2831" target="_blank" rel="noopener">愤怒的小鸟</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$n$较小，考虑状压。</p><p>设两点$(x_1,y_1),(x_2,y_2)$，则过这两点与原点的抛物线$y=ax^2+bx$中，</p><script type="math/tex; mode=display">a=\frac{x_2y_1-x_1y_2}{x_1x_2(x_1-x_2)},b=\frac{x_1^2y_2-x_2^2y_1}{x_1x_2(x_1-x_2)}</script><p>于是预处理所有可行的抛物线，并把其经过的猪作为状态记录下来。</p><p>预处理完后直接状转即可，定义$dp[i]$表示目前猪状态为$i$时的最少鸟数。</p><p>易得</p><script type="math/tex; mode=display">dp[i|line[j]]=\min(dp[i|line[j]],dp[i]+1)</script><p>其中$line[j]$表示预处理的第$j$个抛物线经过的猪的状态。</p><p>最终答案即为$dp[2^n-1]$。</p><p>注意控制精度，要开<code>long double</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;N)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all (1&lt;&lt;n) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m,line[MAXN];</span><br><span class="line">ll dp[tot];</span><br><span class="line">ld x[N],y[N],eps=<span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%llf%llf"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">line[cnt++]=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"><span class="keyword">int</span> use=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((use&gt;&gt;j)&amp;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ld a=(x[j]*y[i]-x[i]*y[j])/(x[i]*x[j]*(x[i]-x[j])),b=(x[i]*x[i]*y[j]-x[j]*x[j]*y[i])/(x[i]*x[j]*(x[i]-x[j]));</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">line[cnt]=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;n;k++) <span class="keyword">if</span>(<span class="built_in">abs</span>(a*x[k]*x[k]+b*x[k]-y[k])&lt;=eps) use|=(<span class="number">1</span>&lt;&lt;k),line[cnt]|=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;all;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;j++) dp[i|line[j]]=min(dp[i|line[j]],dp[i]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[all<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ2411] Mondriaan&#39;s Dream</title>
      <link href="/is-zxy.github.io/2020/04/08/%5BPOJ2411%5D-Mondriaan-s-Dream/"/>
      <url>/is-zxy.github.io/2020/04/08/%5BPOJ2411%5D-Mondriaan-s-Dream/</url>
      
        <content type="html"><![CDATA[<p>求把 $N\times M(1\le N,M\le 11)$ 的棋盘分割成若干个 $1\times 2$ 的长方形，有多少种方案。</p><p>例如当 $N=2,M=4$ 时，共有 $5$ 种方案；当 $N=2,M=3$ 时，有 $3$ 种方案，如下图所示。</p><p><img src="http://poj.org/images/2411_1.jpg" alt="img"></p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://poj.org/problem?id=2411" target="_blank" rel="noopener"><strong>Mondriaan’s Dream</strong></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$N,M$ 较小，考虑状压。</p><p>这题的状压思路比较妙。</p><p>阶段为行，状态可以用一个 $M$ 位的二进制数表示，其中第 $k(0\le k\le M)$ 位为 $1$ 表示第 $k$ 列是一个竖着的长方形的上面一半，为 $0$ 则为其他情况（竖着的下面一半或横着的）。</p><p>定义 $dp[i][j]$ 表示第 $i$ 行状态为 $j$ 的方案数。</p><p>令目前处理的行的状态为 $j$ ，其上一行状态为 $k$ ，若可以转移，则首先保证 $j|k$ 中没有奇数个连续的 $0$ ，否则无法放横着的长方形。还需要保证 $j\&amp;k$ 为 $0$ ，这样就能保证其上一行为 $1$ 的位置，对应的下一行为 $0$ ，即拼成一个完整的竖着的长方形。</p><p>于是据此进行转移求解即可。</p><p>最终答案 $dp[n][0]$ ，因为最后一行不可能存在竖着的长方形的上面一半。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot 1&lt;&lt;m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll dp[N][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="keyword">bool</span> vh[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> cnt=<span class="number">0</span>,has_odd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) has_odd|=cnt,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cnt^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vh[i]=has_odd|cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;n) &#123;</span><br><span class="line">init(m);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line">dp[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tot;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j&amp;k||vh[j|k]) <span class="keyword">continue</span>;</span><br><span class="line">dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码一定程度上是直接蒯书上的，预处理的方式有些巧妙。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF711C] Coloring Trees</title>
      <link href="/is-zxy.github.io/2020/04/05/%5BCF711C%5D-Coloring-Trees/"/>
      <url>/is-zxy.github.io/2020/04/05/%5BCF711C%5D-Coloring-Trees/</url>
      
        <content type="html"><![CDATA[<p>有 $n$ 棵树， $m$ 种颜料，要求现在要给这些树涂上颜料，最后涂成 $k$ 段（连续颜色相同划为一段如 $2$ , $1$ , $1$ , $1$ , $3$ , $2$ , $2$ , $3$ , $1$ , $3$ 是 $7$ 段），有些树已经涂了，则不涂了只能涂一次，输入 $n$ 个数（每个数为 $0\sim m$）， $0$ 表示还没有涂， $1\sim m$ 表示已经涂了哪种颜料。接下来输入 $n$ 行 $m$ 列，表示每棵树涂成每种颜色所要的颜料量。现在要把所有树都涂上颜料涂成 $k$ 段，求最少要用的颜料量。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le k\le n\le 100$</p><p>$1\le m\le 100$</p><p>$0\le c_i\le m$</p><p>$1\le p_{i,j}\le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF711C" target="_blank" rel="noopener">CF711C Coloring Trees</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][j][l]$表示前$i$颗树分为$j$段，第$i$棵树颜色为$l$时的最小费用。</p><p>根据这个状态分类讨论即可。</p><p>注意将转移考虑全面。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">ll c[N],cost[N][N],dp[N][N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">cin</span>&gt;&gt;cost[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">ans=dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(c[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][c[<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">1</span>][<span class="number">1</span>][i]=cost[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(k,i);j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=m;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==l) dp[i][j][l]=min(dp[i][j][l],dp[i<span class="number">-1</span>][j][l]);</span><br><span class="line"><span class="keyword">else</span> dp[i][j][c[i]]=min(dp[i][j][c[i]],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][l]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=m;l++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=m;o++) &#123;</span><br><span class="line"><span class="keyword">if</span>(l==o) dp[i][j][l]=min(dp[i][j][l],dp[i<span class="number">-1</span>][j][o]+cost[i][l]);</span><br><span class="line"><span class="keyword">else</span> dp[i][j][l]=min(dp[i][j][l],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][o]+cost[i][l]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[n]) ans=dp[n][k][c[n]];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=min(dp[n][k][i],ans);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(ans==dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]?<span class="number">-1</span>:ans)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 多维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2009] 逆序对数列</title>
      <link href="/is-zxy.github.io/2020/04/04/%5BHAOI2009%5D-%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/04/04/%5BHAOI2009%5D-%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>对于任意一个由 $1\sim n$ 自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为 $m$ 的这样自然数数列到底有多少个？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 1000$，$k\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2513" target="_blank" rel="noopener">[HAOI2009]逆序对数列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义 $dp[i][j]$ 表示 $i$ 的全排列中逆序对是为 $j$ 的数列的个数。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=\sum\limits_{k=\max(0,j-i+1)}^jdp[i-1][k]</script><p>于是可以得到一个$O(nm^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=max(<span class="number">0</span>,j-i+<span class="number">1</span>);k&lt;=j;k++) dp[i][j]+=dp[i<span class="number">-1</span>][k],dp[i][j]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑记录上一阶段的值，剔除不合法的状态，直接转移，有点儿类似单调队列。</p><p>于是可得$O(nm)$的算法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,dp[N][<span class="number">5050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">sum+=dp[i<span class="number">-1</span>][j],sum%=mod;</span><br><span class="line">dp[i][j]=sum;</span><br><span class="line"><span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;=<span class="number">0</span>) sum-=dp[i<span class="number">-1</span>][j-i+<span class="number">1</span>],sum=(sum+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> HAOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[国家集训队] 小Z的袜子</title>
      <link href="/is-zxy.github.io/2020/04/02/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/"/>
      <url>/is-zxy.github.io/2020/04/02/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>作为一个生活散漫的人，小 Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小 Z 再也无法忍受这恼人的找袜子过程，于是他决定听天由命……</p><p>具体来说，小 Z 把这 $N$ 只袜子从 $1$ 到 $N$ 编号，然后从编号$L$到$R$。</p><p>尽管小 Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。</p><p>你的任务便是告诉小 Z，他有多大的概率抽到两只颜色相同的袜子。当然，小 Z 希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。</p><p><strong>然而数据中有 $L=R$ 的情况，请特判这种情况，输出<code>0/1</code>。</strong></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N,M\le 50000$，$1\le L&lt;R\le N$，$C_i\le N$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1494" target="_blank" rel="noopener">[国家集训队]小Z的袜子</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于一个询问，设询问区间内有$x$对颜色相同的袜子，区间长度为$y$，则概率为</p><script type="math/tex; mode=display">\dfrac{x}{C_y^2}</script><p>即为</p><script type="math/tex; mode=display">\dfrac{2x}{y(y-1)}</script><p>$y$已知，考虑如何求$x$。</p><p>显然，$x$的值为</p><script type="math/tex; mode=display">\dfrac{\sum\limits_{i=1}^N\mathrm{cnt_i}(\mathrm{cnt_i}-1)}{2}</script><p>其中$\mathrm{cnt_i}$表示第$i$种颜色在询问区间内出现的次数。</p><p>即对于一个询问，其答案为</p><script type="math/tex; mode=display">\dfrac{\sum\limits_{i=1}^N\mathrm{cnt_i}(\mathrm{cnt_i}-1)}{y(y-1)}</script><p>分子明显是可以$O(1)$转移的，莫队即可。</p><p>分数约分，<code>gcd</code>即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,blo;</span><br><span class="line">ll c[N],anst[N],ansb[N],ans=<span class="number">0</span>,cnt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,pos,id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> query &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.pos==pos) <span class="keyword">return</span> r&lt;x.r;</span><br><span class="line"><span class="keyword">return</span> pos&lt;x.pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">return</span> !y?x:gcd(y,x%y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ans+=<span class="number">2</span>*cnt[c[x]];</span><br><span class="line">cnt[c[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">cnt[c[x]]--;</span><br><span class="line">ans-=<span class="number">2</span>*cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]);</span><br><span class="line"></span><br><span class="line">blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q[i].l&gt;&gt;q[i].r;</span><br><span class="line">q[i].id=i,q[i].pos=(q[i].l<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">ll l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l&gt;q[i].l) l--,add(l);</span><br><span class="line"><span class="keyword">while</span>(r&lt;q[i].r) r++,add(r);</span><br><span class="line"><span class="keyword">while</span>(l&lt;q[i].l) del(l),l++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;q[i].r) del(r),r--;</span><br><span class="line"><span class="keyword">if</span>(l==r) anst[q[i].id]=<span class="number">0</span>,ansb[q[i].id]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll g=gcd(ans,(r-l+<span class="number">1</span>)*(r-l));</span><br><span class="line">anst[q[i].id]=ans/g;</span><br><span class="line">ansb[q[i].id]=(r-l+<span class="number">1</span>)*(r-l)/g;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d/%d\n"</span>,anst[i],ansb[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 国家集训队 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3901] 数列找不同</title>
      <link href="/is-zxy.github.io/2020/04/02/%5B%E6%B4%9B%E8%B0%B7P3901%5D-%E6%95%B0%E5%88%97%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
      <url>/is-zxy.github.io/2020/04/02/%5B%E6%B4%9B%E8%B0%B7P3901%5D-%E6%95%B0%E5%88%97%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>现有数列$A_1,A_2,\ldots,A_N$，$Q$个询问$(L_i,R_i)$，询问$A_{L_i} ,A_{L_i+1},\ldots,A_{R_i}$是否互不相同。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N,Q\le 10^5$，$1\le A_i\le N$，$1\le L_i\le R_i\le N$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3901" target="_blank" rel="noopener">P3901 数列找不同</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>莫队板子中的板子，比我写的学习笔记里的例题还板。。</p><p>明显$O(1)$转移。</p><p>直接莫队。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Q,a[N],blo,js[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> Ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,pos,id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> query &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==x.pos) <span class="keyword">return</span> r&lt;x.r;</span><br><span class="line"><span class="keyword">return</span> pos&lt;x.pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(js[a[x]]) ans++;</span><br><span class="line">js[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">js[a[x]]--;</span><br><span class="line"><span class="keyword">if</span>(js[a[x]]) ans--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q[i].l&gt;&gt;q[i].r;</span><br><span class="line">q[i].id=i,q[i].pos=(q[i].l<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>,q+Q+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l&gt;q[i].l) l--,add(l);</span><br><span class="line"><span class="keyword">while</span>(r&lt;q[i].r) r++,add(r);</span><br><span class="line"><span class="keyword">while</span>(l&lt;q[i].l) del(l),l++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;q[i].r) del(r),r--;</span><br><span class="line"><span class="keyword">if</span>(!ans) Ans[q[i].id]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> Ans[q[i].id]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(Ans[i]) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通莫队学习笔记</title>
      <link href="/is-zxy.github.io/2020/04/01/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/04/01/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>莫队算法是一种<strong>离线</strong>算法。本次学习的<strong>普通莫队</strong>使用来解决<strong>不带修改</strong>只有查询的一类<strong>区间</strong>问题。</p><p>前置知识：分块及其思想。</p><a id="more"></a><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><p>考虑一类区间问题。</p><p>这类区间问题，如果我们已知了一个区间$[l,r]$的情况，那么我们便可以$O(1)$求出$[l-1,r],[l+1,r],[l,r-1],[l,r+1]$的情况。</p><p>显然有种$O(n^2)$的朴素算法。</p><p>能否优化呢？</p><p>这时候，莫队算法就登场了。</p><h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><p>我们可以考虑分块呀！</p><p>分块后，将每个询问的左端点所在的块的序号作为第一关键字，右端点的大小作为第二关键字，然后对其进行升序排序，针对排好的顺序依次处理的话，时间复杂度就会大大降低。</p><p>举个例子吧。</p><p>假设序列长度为$10$，询问区间有<code>[1,8],[6,7],[6,9],[1,3],[4,6],[7,9],[5,9],[8,10]</code>。</p><p>先按第一关键字进行排序可得<code>[1,8],[1,3]|[4,6],[6,7],[6,9],[5,9]|[7,9]|[8,10]</code>。</p><p>再按照第二关键字排序可得<code>[1,3],[1,8]|[4,6],[6,7],[6,9],[5,9]|[7,9]|[8,10]</code>。</p><p>其中<code>|</code>表示左端点所在的块与块的分割。</p><p>这样依次处理显然优了很多。</p><p>时间复杂度为$O\left((N+Q)\sqrt{N}\right)$，其分析见<a href="https://blog.csdn.net/hnshhslsh/article/details/50582926" target="_blank" rel="noopener">莫队算法详解</a>。</p><h2 id="例题-洛谷P2709-小B的询问"><a href="#例题-洛谷P2709-小B的询问" class="headerlink" title="例题 [洛谷P2709] 小B的询问"></a>例题 [洛谷P2709] 小B的询问</h2><p>小B有一个长为$n$的整数序列$a$，值域为$[1,k]$。<br>他一共有$m$个询问，每个询问给定一个区间$[l,r]$，求：</p><script type="math/tex; mode=display">\sum\limits_{i=1}^k c_i^2</script><p>其中$c_i$表示数字$i$在$[l,r]$中的出现次数。<br>小B请你帮助他回答询问。</p><!--more--><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$1\le n,m,k \le 5\times 10^4$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2709" target="_blank" rel="noopener">P2709 小B的询问</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然是可以$O(1)$转移的。</p><p>于是直接莫队即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,id,pos;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> query &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==x.pos) <span class="keyword">return</span> r&lt;x.r;</span><br><span class="line"><span class="keyword">return</span> pos&lt;x.pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> a[N],n,m,k,blo;</span><br><span class="line">ll Ans[N],cnt[N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">cnt[a[x]]++;</span><br><span class="line">ans+=<span class="number">2</span>*cnt[a[x]]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">cnt[a[x]]--;</span><br><span class="line">ans-=<span class="number">2</span>*cnt[a[x]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">q[i].id=i,q[i].pos=(q[i].l<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l&gt;q[i].l) l--,add(l);</span><br><span class="line"><span class="keyword">while</span>(r&lt;q[i].r) r++,add(r);</span><br><span class="line"><span class="keyword">while</span>(l&lt;q[i].l) del(l),l++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;q[i].r) del(r),r--;</span><br><span class="line">Ans[q[i].id]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P3901" target="_blank" rel="noopener">P3901 数列找不同</a></td><td><a href="https://www.luogu.com.cn/record/32415077" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1494" target="_blank" rel="noopener">[国家集训队]小Z的袜子</a></td><td><a href="https://www.luogu.com.cn/record/32417662" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3604" target="_blank" rel="noopener">P3604 美好的每一天</a></td><td>×</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/CF1000F" target="_blank" rel="noopener">CF1000F One Occurrence</a></td><td><a href="https://www.luogu.com.cn/record/32436955" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>$O(1)$转移的区间问题便可以用莫队啦。</p><p>$O(logN)$转移的区间问题（例如最值问题）也可以，时间复杂度会变为$O(N\sqrt{N}\log N)$，能过的话就用吧233。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/hnshhslsh/article/details/50582926" target="_blank" rel="noopener">莫队算法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 莫队 </tag>
            
            <tag> 离线算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF920F] SUM and REPLACE</title>
      <link href="/is-zxy.github.io/2020/03/31/%5BCF920F%5D-SUM-and-REPLACE/"/>
      <url>/is-zxy.github.io/2020/03/31/%5BCF920F%5D-SUM-and-REPLACE/</url>
      
        <content type="html"><![CDATA[<p>给你一个数组$a_i$，对其进行$m$次操作。其中$D(x)$为$x$的约数个数</p><p>有两种操作：</p><p>输入<code>1 l r</code>表示将$[l,r]$的$a_i$替换为$D(a_i)$。</p><p>输入<code>2 l r</code>则输出$\sum^r_{i=l}a_i$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m\le 3\times 10^5$</p><p>$1\le a_i\le 10^6$</p><p>$1\le l\le r\le n$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF920F" target="_blank" rel="noopener">CF920F SUM and REPLACE</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和<a href="https://www.luogu.com.cn/problem/P4145" target="_blank" rel="noopener">P4145 上帝造题的七分钟2 / 花神游历各国</a>差不多的思路。</p><p>首先$O(n)$线性筛求出因数个数，因为其是个积性函数。</p><p>一个数$x$进行这样变换的次数不会超过$log_2x$次，因为$D(x)$至多为$\dfrac{x}{2}$。</p><p>本题$a_i$最大为$10^6$，则最多这样变换$20$次。</p><p>因此便可以暴力单点修改（不满足区间可减性也不易区间修改）。</p><p>一个数为$2$或$1$时，便不必在变换了，因为其因数个数就是本身。</p><p>因此维护区间和，以及一个标记，用来标记一个区间内的数字是否都为$1$或$2$。</p><p>查询就是老操作了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>;</span><br><span class="line">ll D[MAXN],v[MAXN],prime[MAXN],num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) tree[x].flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ls|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">D[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) v[i]=i,prime[++tot]=i,num[i]=<span class="number">1</span>,D[i]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;=MAXN) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">D[i*prime[j]]=D[i]*D[prime[j]];</span><br><span class="line">num[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">D[i*prime[j]]=D[i]/(num[i]+<span class="number">1</span>)*(num[i]+<span class="number">2</span>);</span><br><span class="line">num[i*prime[j]]=num[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">f(p)=f(ls)&amp;f(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s(p));</span><br><span class="line">f(p)=(s(p)&lt;=<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f(p)||l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">s(p)=D[s(p)];</span><br><span class="line">f(p)=(s(p)&lt;=<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">change(ls,l,r);</span><br><span class="line">change(rs,l,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> s(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">primes();</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;opt,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(opt&amp;<span class="number">1</span>) change(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/28/%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/28/%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>众所周知，分块，是一个优雅的暴力数据结构。</p><a id="more"></a><h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><p>分块的基本思想是通过适当的划分，预处理一部分信息并保存下来，用<strong>空间</strong>换取<strong>时间</strong>，打到时空平衡。事实上，分块更接近与“朴素”（也就是暴力），效率往往比不上树状数组与线段树，但是它更加通用、容易实现。</p><p>直接看题。</p><h2 id="例题-LOJ-6277-数列分块入门-1"><a href="#例题-LOJ-6277-数列分块入门-1" class="headerlink" title="例题 [LOJ#6277] 数列分块入门 1"></a>例题 [LOJ#6277] 数列分块入门 1</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字都加$c$。</p><p>输入<code>1 l r c</code>时表示询问$a_r$的值（$l$和$c$忽略）。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6277" target="_blank" rel="noopener">#6277. 数列分块入门 1</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，这题就是之前做的线段树与树状数组的板子，只不过这里用分块来解决。</p><p>如何“分块”？</p><p>考虑将该数列分为若干个长度不超过$\lfloor\sqrt n\rfloor$的块。易得第$i$块左端点为$(i-1)\lfloor \sqrt n \rfloor+1$，右端点为$\min(i\lfloor\sqrt n \rfloor,n)$。 </p><p>根据本题题意，预处理出数组$sum$，其中$sum[i]$表示第$i$块的数的总和。设$add[i]$表示第$i$块的“增量标记”，起初$add[i]$都为$0$。</p><p>然后对于每一个<code>0</code>操作，设其$l$属于第$p$块，$r$属于第$q$块，显然有两种情况：整块与非整块。</p><ul><li>对于整块：第$i$块$(i\in [p+1,q-1])$的$add$直接加$c$。</li><li>对于非整块，直接朴素更新。</li></ul><p>查询的话直接原数组加上其$add$值即可。</p><p>时间复杂度为$O\left((N+Q)\sqrt N\right)$，虽然比不上树状数组、线段树，但其优势在后面会逐渐显现。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N],add[N],a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line"><span class="keyword">if</span>(R[t]&lt;n) t++,L[t]=R[t<span class="number">-1</span>]+<span class="number">1</span>,R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line">sort(b+L[i],b+R[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) b[i]=a[i];</span><br><span class="line">sort(b+L[x],b+R[x]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(pos[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[pos[l]];i++) a[i]+=c;</span><br><span class="line">reset(pos[l]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) add[i]+=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[pos[r]];i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(pos[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[l]]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[pos[l]];i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[l]]) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) ans+=lower_bound(b+L[i],b+R[i]+<span class="number">1</span>,c-add[i])-(b+L[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[pos[r]];i&lt;=r;i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[r]]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r,c*c));</span><br><span class="line"><span class="keyword">else</span> change(l,r,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6278-数列分块入门-2"><a href="#例题-LOJ-6278-数列分块入门-2" class="headerlink" title="例题 [LOJ#6278] 数列分块入门 2"></a>例题 [LOJ#6278] 数列分块入门 2</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的元素个数。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字都加$c$。</p><p>输入<code>1 l r c</code>时表示询问$[l,r]$内小于$c^2$的数字的个数。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6278" target="_blank" rel="noopener">#6278. 数列分块入门 2</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题大概就体现分块的优势了，线段树这题比较难写。</p><p>非整块依旧是朴素更新、查询。</p><p>可以用另一个数组，存每一个整块都从小到大排完序的序列，这样整块查询直接二分，整块修改直接增量标记。</p><p><strong>一定要用另一个数组存排完序的块</strong>，因为查询的$l,r$是<strong>原序列</strong>的下标！</p><p>时间复杂度$O(nlogn+n\sqrt{n}log\sqrt{n})$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N],add[N],a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line"><span class="keyword">if</span>(R[t]&lt;n) t++,L[t]=R[t<span class="number">-1</span>]+<span class="number">1</span>,R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line">sort(b+L[i],b+R[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) b[i]=a[i];</span><br><span class="line">sort(b+L[x],b+R[x]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(pos[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[pos[l]];i++) a[i]+=c;</span><br><span class="line">reset(pos[l]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) add[i]+=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[pos[r]];i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(pos[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[l]]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[pos[l]];i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[l]]) ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) ans+=lower_bound(b+L[i],b+R[i]+<span class="number">1</span>,c-add[i])-(b+L[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[pos[r]];i&lt;=r;i++) <span class="keyword">if</span>(a[i]&lt;c-add[pos[r]]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r,c*c));</span><br><span class="line"><span class="keyword">else</span> change(l,r,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从昨天23点调到今天14点…自闭，错因居然是<code>init</code>里的对最后一块的操作。原先写的是<code>if(R[t]&lt;n) L[++t]=R[t-1]+1,R[t]=n;</code>，死活调不出来，抱着艹蛋的心态，改成了<code>if(R[t]&lt;n) ++t,L[t]=R[t-1]+1,R[t]=n</code>过了…崩溃。貌似是同行的优先级问题。</p><p>所以决定，以后不这样写了，直接<code>R[t]=n</code>，倒也方便不少。</p><hr><h2 id="例题-LOJ-6279-数列分块入门3"><a href="#例题-LOJ-6279-数列分块入门3" class="headerlink" title="例题 [LOJ#6279] 数列分块入门3"></a>例题 [LOJ#6279] 数列分块入门3</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的前驱（比其小的最大元素）。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字都加$c$。</p><p>输入<code>1 l r c</code>时表示询问$[l,r]$中$c$的前驱的值（不存在则输出$-1$）。</p><h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6279" target="_blank" rel="noopener">#6279. 数列分块入门 3</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与上题思想是一样的，把二分改一改就好了。不多解释。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],L[N],R[N],add[N],pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line">sort(b+L[i],b+R[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) b[i]=a[i];</span><br><span class="line">sort(b+L[x],b+R[x]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) a[i]+=c;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) add[i]+=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) a[i]+=c;</span><br><span class="line">reset(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>,p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) <span class="keyword">if</span>(a[i]+add[p]&lt;c) ans=max(ans,a[i]+add[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) <span class="keyword">if</span>(a[i]+add[p]&lt;c) ans=max(ans,a[i]+add[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=lower_bound(b+L[i],b+R[i]+<span class="number">1</span>,c-add[i])-(b+L[i]);</span><br><span class="line"><span class="keyword">if</span>(t) ans=max(ans,b[L[i]+t<span class="number">-1</span>]+add[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) <span class="keyword">if</span>(a[i]+add[q]&lt;c) ans=max(ans,a[i]+add[q]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r,c));</span><br><span class="line"><span class="keyword">else</span> change(l,r,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6280-数列分块入门4"><a href="#例题-LOJ-6280-数列分块入门4" class="headerlink" title="例题 [LOJ#6280] 数列分块入门4"></a>例题 [LOJ#6280] 数列分块入门4</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，区间求和。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字都加$c$。</p><p>输入<code>1 l r c</code>时表示询问$[l,r]$的所有数字的和$\mod (c+1)$。</p><h3 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-3"><a href="#链接-3" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6280" target="_blank" rel="noopener">#6280. 数列分块入门 4</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>预处理每块的所有元素和。</p><p>考虑区间修改操作。非整块朴素修改，顺便更新块的元素和；整块直接加增量标记上。</p><p>查询同理，要加上增量标记。注意查询整块时增量标记要乘块长度（我的写法是这样）。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y,mod) ((x%mod)+(y%mod))%mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N];</span><br><span class="line">ll a[N],add[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) sum[i]+=a[j],pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]+=c,sum[p]+=c;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) a[i]+=c,sum[p]+=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) add[i]+=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) a[i]+=c,sum[q]+=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) ans=plus(ans,a[i]+add[p],c);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) ans=plus(ans,a[i]+add[p],c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) ans=plus(ans,(R[i]-L[i]+<span class="number">1</span>)*add[i]+sum[i],c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) ans=plus(ans,a[i]+add[q],c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r;</span><br><span class="line">ll c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r,c+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> change(l,r,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6281-数列分块入门5"><a href="#例题-LOJ-6281-数列分块入门5" class="headerlink" title="例题[LOJ#6281] 数列分块入门5"></a>例题[LOJ#6281] 数列分块入门5</h2><p>给出一个长为$n$的数列$a_1\cdots a_n$，以及$n$个操作，操作涉及区间开方，区间求和。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字开方。对于区间中每个$a_i(l\le i\le r)$，$a_i\leftarrow \lfloor \sqrt{a_i} \rfloor$。</p><p>输入<code>1 l r c</code>时表示询问$[l,r]$的所有数字的和。</p><h3 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-4"><a href="#链接-4" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6281" target="_blank" rel="noopener">#6281. 数列分块入门 5</a></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>之前用线段树做过类似的题，<a href="http://zxyer.xyz/2020/03/23/%5B%E6%B4%9B%E8%B0%B7P4145%5D-%E4%B8%8A%E5%B8%9D%E9%80%A0%E9%A2%98%E7%9A%84%E4%B8%83%E5%88%86%E9%92%9F2-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/" target="_blank" rel="noopener">[洛谷P4145] 上帝造题的七分钟2/花神游历各国</a>。</p><p>与此同理，每个数最多开方$6$次后就会变成$0$或$1$，因此维护块和，以及一个标记——用来标记块内数字是否都为$0$或$1$。</p><p>考虑开方操作，非整块直接朴素修改。整块的话判断其内数字是否都为$0$或$1$，若是则跳过，不是则朴素修改。</p><p>查询也是一样。非整块一个一个累加，整块直接加块和。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N];</span><br><span class="line">ll a[N],sum[N];</span><br><span class="line"><span class="keyword">bool</span> flag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line">sum[i]+=a[j];</span><br><span class="line">pos[j]=i;</span><br><span class="line"><span class="keyword">if</span>(a[j]!=<span class="number">1</span>&amp;&amp;a[j]!=<span class="number">0</span>) flag[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) <span class="keyword">if</span>(a[i]!=<span class="number">1</span>&amp;&amp;a[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[x]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]!=<span class="number">1</span>&amp;&amp;a[i]!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[x]=sum[x]-a[i]+t;</span><br><span class="line">a[i]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">flag[x]=check(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) solve(p,l,r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">solve(p,l,R[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) solve(i,L[i],R[i]);</span><br><span class="line">solve(q,L[q],r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p==q) <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) ans+=a[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) ans+=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) ans+=sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(l,r));</span><br><span class="line"><span class="keyword">else</span> change(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6282-数列分块入门6"><a href="#例题-LOJ-6282-数列分块入门6" class="headerlink" title="例题[LOJ#6282] 数列分块入门6"></a>例题[LOJ#6282] 数列分块入门6</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及单点插入，单点询问，数据随机生成。</p><p>输入<code>0 l r c</code>时表示在第$l$个数字前插入数字$r$（$c$忽略）。</p><p>输入<code>1 l r c</code>时表示询问$a_r$的值（$l$和$c$忽略）。</p><h3 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-5"><a href="#链接-5" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6282" target="_blank" rel="noopener">#6282. 数列分块入门 6</a></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>插入，不好搞。</p><p>黄学长的文章中有句话：如果我们块内用<strong>数组以外的数据结构</strong>，能够支持其他不一样的操作。</p><p>于是可以想到本题可以用$\mathrm{vector}$或链表来搞。</p><p>我用了$\mathrm{vector}$（好写）。</p><p>插入直接利用$\mathrm{vector}$自带的<code>insert</code>函数。</p><p>查询类似。</p><p>完了吗？</p><p>并没有。</p><p>如果在一个块内插入大量的元素，便可能超时了。</p><p>因此需要引入一个新操作：重构块。即当一个块内元素数量达到一定数量后，便把数列重新平均分块。</p><p>这样保证每个块的大小相对均衡，便一定程度上防止了向一个块内插入大量元素的数据TLE。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 10007 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,pos[N&lt;&lt;<span class="number">1</span>],maxpos,a[N&lt;&lt;<span class="number">1</span>],t;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">b[(i<span class="number">-1</span>)/t+<span class="number">1</span>].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">maxpos=(n<span class="number">-1</span>)/t+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; query(<span class="keyword">int</span> l) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&gt;b[cnt].size()) &#123;</span><br><span class="line">l-=b[cnt].size();</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> make_pair(cnt,l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxpos;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> size=b[i].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++) a[++cnt]=b[i][j];</span><br><span class="line">b[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">t=<span class="built_in">sqrt</span>(cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) b[(i<span class="number">-1</span>)/t+<span class="number">1</span>].push_back(a[i]);</span><br><span class="line">maxpos=(cnt<span class="number">-1</span>)/t+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; w=query(l);</span><br><span class="line">b[w.first].insert(b[w.first].begin()+w.second,x);</span><br><span class="line"><span class="keyword">if</span>(b[w.first].size()&gt;<span class="number">2</span>*t) rebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; w=query(x);</span><br><span class="line"><span class="keyword">return</span> b[w.first][w.second];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(opt) <span class="built_in">cout</span>&lt;&lt;find(r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> insert(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6283-数列分块入门-7"><a href="#例题-LOJ-6283-数列分块入门-7" class="headerlink" title="例题[LOJ#6283] 数列分块入门 7"></a>例题[LOJ#6283] 数列分块入门 7</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间乘法，区间加法，单点询问。</p><p>输入<code>0 l r c</code>时表示将区间$[l,r]$的之间的数字都加$c$。</p><p>输入<code>1 l r c</code>时表示将区间$[l,r]$的之间的数字都乘$c$。</p><p>输入<code>2 l r c</code>时表示询问$a_r$的值$\mod 10007$（$l$和$c$忽略）。</p><h3 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-6"><a href="#链接-6" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6283" target="_blank" rel="noopener">#6283. 数列分块入门 7</a></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>与之前做过的<a href="http://zxyer.xyz/2020/01/07/%5B%E6%B4%9B%E8%B0%B7P3373%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%912-AHOI2009-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97/" target="_blank" rel="noopener">[洛谷P3373] 【模板】线段树2/[AHOI2009]维护序列</a>其实是一样的。</p><p>本题考虑分块做法。</p><p>整块的修改很好想。关键在于非整块。仔细想想，是很难直接改的，所以需要把非整块的标记下放，这样便可以直接改了。</p><p>好吧本题难点就在于标记下放。</p><p>另外，<code>#define plus(x,y) ((x%mod)+(y%mod))%mod</code>这种写法，本题亲测过不了，TLE，常数过大。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 10007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N],t;</span><br><span class="line">ll add[N],a[N],mul[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line">mul[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) a[i]=(a[i]*mul[x]+add[x])%mod;</span><br><span class="line">mul[x]=<span class="number">1</span>,add[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_mul</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]=(a[i]*c)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) a[i]=(a[i]*c)%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) mul[i]=(mul[i]*c)%mod,add[i]=(add[i]*c)%mod;</span><br><span class="line">reset(q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) a[i]=(a[i]*c)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r];</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]=(a[i]+c)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) a[i]=(a[i]+c)%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) add[i]=(add[i]+c)%mod;</span><br><span class="line">reset(q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) a[i]=(a[i]+c)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a[x]*mul[pos[x]]+add[pos[x]])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),a[i]%=mod;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt,l,r;</span><br><span class="line">ll c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld"</span>,&amp;opt,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(!opt) change_add(l,r,c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt&amp;<span class="number">1</span>) change_mul(l,r,c);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ask(r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6284-数列分块入门8"><a href="#例题-LOJ-6284-数列分块入门8" class="headerlink" title="例题[LOJ#6284] 数列分块入门8"></a>例题[LOJ#6284] 数列分块入门8</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及区间询问等于一个数$c$的元素，并将这个区间的所有元素改为$c$。</p><p>输入<code>l r c</code>表示先查询位于$[l,r]$的数字有多少个是$c$，再把位于$[l,r]$的数字都改为$c$。</p><h3 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-7"><a href="#链接-7" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6284" target="_blank" rel="noopener">#6284. 数列分块入门 8</a></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>区间询问很水。</p><p>区间修改咋搞？</p><p>貌似只能暴力了呢..</p><p>联想到之前的开方那题，实际上本题在几次操作后，数列可能只剩下几段不同的区间了。于是此后的每次操作最多只会使得两个块变得数互不相同，因此暴力算法是可以过的。</p><p>于是分块维护一个标记，标记每个块块内是否只有一个数字，若是则标为这个数字，不是则标为$-1$。</p><p>然后操作就与之前题差不多了。标记非$-1$整块直接修改，其余情况均暴力。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,L[N],R[N],pos[N],a[N],f[N],t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">t=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) L[i]=(i<span class="number">-1</span>)*t+<span class="number">1</span>,R[i]=i*t;</span><br><span class="line">R[t]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[x];i&lt;=R[x];i++) a[i]=f[x];</span><br><span class="line">f[x]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=pos[l],q=pos[r],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==c) ans++;</span><br><span class="line"><span class="keyword">else</span> a[i]=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">reset(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==c) ans++;</span><br><span class="line"><span class="keyword">else</span> a[i]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;q;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i]!=<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i]==c) ans+=R[i]-L[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[i]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]==c) ans++;</span><br><span class="line"><span class="keyword">else</span> a[j]=c;</span><br><span class="line">&#125;</span><br><span class="line">f[i]=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reset(q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==c) ans++;</span><br><span class="line"><span class="keyword">else</span> a[i]=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(l,r,c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题-LOJ-6285-数列分块入门-9"><a href="#例题-LOJ-6285-数列分块入门-9" class="headerlink" title="例题[LOJ#6285] 数列分块入门 9"></a>例题[LOJ#6285] 数列分块入门 9</h2><p>给出一个长为$n$的数列，以及$n$个操作，操作涉及询问区间的最小众数。</p><p>输入<code>l r c</code>表示查询位于$[l,r]$的数字的众数。</p><h3 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 100000$</p><p>$-2^{31}\le \mathrm{others},\mathrm{ans}\le 2^{31}-1$</p><h3 id="链接-8"><a href="#链接-8" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6285" target="_blank" rel="noopener">#6285. 数列分块入门 9</a></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>我太懒了，<a href="https://www.docin.com/p-679227660.html" target="_blank" rel="noopener">丢个链接</a>，<del>这不是我这种菜逼好解释的。</del></p><p>值得注意的地方，由于<del>毒瘤</del>良心出题人，本题块的大小需要调整。经本人测试，40的效果很好，调到30时不知为啥莫名WA。</p><p>目前只写了$O\left((N+Q)\sqrt{N}\log N\right)$。</p><p>其中<code>f[i][j]</code>表示第$i$块到第$j$块的众数。</p><p>$O\left((N+Q)\sqrt{N}\right)$的优化咕咕咕，待补。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqrtN 4010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,blo,size,id,v[N],pos[N],val[N],cnt[N],L[sqrtN],R[sqrtN],f[sqrtN][sqrtN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size=<span class="number">30</span>;   <span class="comment">//size为块大小</span></span><br><span class="line">blo=n/size;   <span class="comment">//块个数</span></span><br><span class="line"><span class="keyword">if</span>(!blo) blo=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) L[i]=(i<span class="number">-1</span>)*size+<span class="number">1</span>,R[i]=i*size;</span><br><span class="line">R[blo]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=R[i];j++) &#123;</span><br><span class="line">pos[j]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blo;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>,maxs;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L[i];j&lt;=n;j++) &#123;</span><br><span class="line">cnt[v[j]]++;</span><br><span class="line"><span class="keyword">if</span>(cnt[v[j]]&gt;maxn||(cnt[v[j]]==maxn&amp;&amp;val[v[j]]&lt;val[maxs])) maxs=v[j],maxn=cnt[v[j]];</span><br><span class="line">f[i][pos[j]]=maxs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> upper_bound(ve[x].begin(),ve[x].end(),r)-lower_bound(ve[x].begin(),ve[x].end(),l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxn,maxs,p=pos[l],q=pos[r];</span><br><span class="line">maxs=f[p+<span class="number">1</span>][q<span class="number">-1</span>];</span><br><span class="line">maxn=query(l,r,maxs);</span><br><span class="line"><span class="keyword">if</span>(p==q) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=R[p];i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L[q];i&lt;=r;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=query(l,r,v[i]);</span><br><span class="line"><span class="keyword">if</span>(t&gt;maxn||(t==maxn&amp;&amp;val[v[i]]&lt;val[maxs])) maxn=t,maxs=v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;   <span class="comment">//离散化</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line"><span class="keyword">if</span>(!mp[v[i]]) &#123;</span><br><span class="line">mp[v[i]]=++id;</span><br><span class="line">val[id]=v[i];</span><br><span class="line">&#125;</span><br><span class="line">v[i]=mp[v[i]];</span><br><span class="line">ve[v[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[ask(l,r)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2801" target="_blank" rel="noopener">P2801 教主的魔法</a></td><td><a href="https://www.luogu.com.cn/record/32352641" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4168" target="_blank" rel="noopener">P4168 [Violet]蒲公英</a></td><td><a href="https://www.luogu.com.cn/record/32387388" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://hzwer.com/8053.html" target="_blank" rel="noopener">黄学长的分块入门</a></p><p><a href="https://www.docin.com/p-679227660.html" target="_blank" rel="noopener">区间众数解题报告 - 陈立杰</a></p><p>《算法竞赛进阶指南》</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P6327] 区间加区间sin和</title>
      <link href="/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P6327%5D%20%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P6327%5D%20%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的整数序列$a_1,a_2,\ldots,a_n$，进行$m$次操作，操作分为两类。</p><p>操作$1$：给出$l,r,v$，将$a_l,a_{l+1},\ldots,a_r$分别加上$v$。</p><p>操作$2$：给出$l,r$，询问$\sum\limits_{i=l}^{r}\sin(a_i)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m,a_i,v\le 2\times 10^5$，$1\le l\le r\le n$。保证所有输入的数都是正整数。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5524" target="_blank" rel="noopener">[洛谷P6327] 区间加区间sin和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><del>终于有一道我这菜逼能做出来的Ynoi了！</del>该题被移除Ynoi了（悲）。</p><p>当对区间$[l,r]$进行操作$1$时，则</p><script type="math/tex; mode=display">\begin{align}\sum_{i=l}^r\sin(a_i+v)&= \sum_{i=l}^r\left[\sin(a_i)\cdot \cos(v)+\cos(a_i)\cdot \sin(v)\right] \\&= \sum_{i=l}^r\left[\sin(a_i)\cdot \cos(v)\right]+\sum_{i=l}^r\left[\cos(a_i)\cdot \sin(v)\right] \\&= \cos(v)\sum_{i=l}^r\sin(a_i)+\sin(v)\sum_{i=l}^r\cos(a_i)\end{align}</script><p>于是可以用线段树维护区间正余弦和，分别表示为$S$与$C$，则化为</p><script type="math/tex; mode=display">S\cdot \cos(v)+C\cdot \sin(v)</script><p>维护$cos$值与此同理，代个和角公式，过程就不写了，直接给出最终结果吧</p><script type="math/tex; mode=display">C\cdot cos(v)-S\cdot sin(v)</script><p>涉及区间修改，便可以再维护个懒标记，其<code>spread</code>也是大抵利用上面的式子。</p><p>没了。<del>写了个最劣解233</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,op,l,r;</span><br><span class="line"><span class="keyword">double</span> v;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">double</span> Itvsine,Itvcosine,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) tree[x].Itvsine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(x) tree[x].Itvcosine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ls|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">S(p)=S(ls)+S(rs);</span><br><span class="line">C(p)=C(ls)+C(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">S(p)=<span class="built_in">sin</span>(x);</span><br><span class="line">C(p)=<span class="built_in">cos</span>(x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">double</span> sine=<span class="built_in">sin</span>(lazy(p)),cosi=<span class="built_in">cos</span>(lazy(p)),tmp;</span><br><span class="line">tmp=S(ls);</span><br><span class="line">S(ls)=S(ls)*cosi+C(ls)*sine;</span><br><span class="line">C(ls)=C(ls)*cosi-tmp*sine;</span><br><span class="line">tmp=S(rs);</span><br><span class="line">S(rs)=S(rs)*cosi+C(rs)*sine;</span><br><span class="line">C(rs)=C(rs)*cosi-tmp*sine;</span><br><span class="line">lazy(ls)+=lazy(p);</span><br><span class="line">lazy(rs)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line"><span class="keyword">double</span> sine=<span class="built_in">sin</span>(x),cosi=<span class="built_in">cos</span>(x),tmp=S(p);</span><br><span class="line">S(p)=S(p)*cosi+C(p)*sine;</span><br><span class="line">C(p)=C(p)*cosi-tmp*sine;</span><br><span class="line">lazy(p)+=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> S(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>,&amp;l,&amp;r,&amp;v);</span><br><span class="line">change(<span class="number">1</span>,l,r,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Ynoi2012] NOIP2015洋溢着希望</title>
      <link href="/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P6327%5D-%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P6327%5D-%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%8C%BA%E9%97%B4sin%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的整数序列$a_1,a_2,\ldots,a_n$，进行$m$次操作，操作分为两类。</p><p>操作$1$：给出$l,r,v$，将$a_l,a_{l+1},\ldots,a_r$分别加上$v$。</p><p>操作$2$：给出$l,r$，询问$\sum\limits_{i=l}^{r}\sin(a_i)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m,a_i,v\le 2\times 10^5$，$1\le l\le r\le n$。保证所有输入的数都是正整数。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5524" target="_blank" rel="noopener">[Ynoi2012]NOIP2015洋溢着希望</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>？奇怪的名字。</p><p>终于有一道我这菜逼能做出来的Ynoi了！</p><p>当对区间$[l,r]$进行操作$1$时，则</p><script type="math/tex; mode=display">\begin{align}\sum_{i=l}^r\sin(a_i+v)&= \sum_{i=l}^r\left[\sin(a_i)\cdot \cos(v)+\cos(a_i)\cdot \sin(v)\right] \\&= \sum_{i=l}^r\left[\sin(a_i)\cdot \cos(v)\right]+\sum_{i=l}^r\left[\cos(a_i)\cdot \sin(v)\right] \\&= \cos(v)\sum_{i=l}^r\sin(a_i)+\sin(v)\sum_{i=l}^r\cos(a_i)\end{align}</script><p>于是可以用线段树维护区间正余弦和，分别表示为$S$与$C$，则化为</p><script type="math/tex; mode=display">S\cdot \cos(v)+C\cdot \sin(v)</script><p>维护$cos$值与此同理，代个和角公式，过程就不写了，直接给出最终结果吧</p><script type="math/tex; mode=display">C\cdot cos(v)-S\cdot sin(v)</script><p>涉及区间修改，便可以再维护个懒标记，其<code>spread</code>也是大抵利用上面的式子。</p><p>没了。<del>写了个最劣解233</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,op,l,r;</span><br><span class="line"><span class="keyword">double</span> v;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SGT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">double</span> Itvsine,Itvcosine,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) tree[x].Itvsine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(x) tree[x].Itvcosine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ls|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">S(p)=S(ls)+S(rs);</span><br><span class="line">C(p)=C(ls)+C(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">S(p)=<span class="built_in">sin</span>(x);</span><br><span class="line">C(p)=<span class="built_in">cos</span>(x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">double</span> sine=<span class="built_in">sin</span>(lazy(p)),cosi=<span class="built_in">cos</span>(lazy(p)),tmp;</span><br><span class="line">tmp=S(ls);</span><br><span class="line">S(ls)=S(ls)*cosi+C(ls)*sine;</span><br><span class="line">C(ls)=C(ls)*cosi-tmp*sine;</span><br><span class="line">tmp=S(rs);</span><br><span class="line">S(rs)=S(rs)*cosi+C(rs)*sine;</span><br><span class="line">C(rs)=C(rs)*cosi-tmp*sine;</span><br><span class="line">lazy(ls)+=lazy(p);</span><br><span class="line">lazy(rs)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line"><span class="keyword">double</span> sine=<span class="built_in">sin</span>(x),cosi=<span class="built_in">cos</span>(x),tmp=S(p);</span><br><span class="line">S(p)=S(p)*cosi+C(p)*sine;</span><br><span class="line">C(p)=C(p)*cosi-tmp*sine;</span><br><span class="line">lazy(p)+=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> S(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>,&amp;l,&amp;r,&amp;v);</span><br><span class="line">change(<span class="number">1</span>,l,r,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,ask(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2184] 贪婪大陆</title>
      <link href="/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P2184%5D-%E8%B4%AA%E5%A9%AA%E5%A4%A7%E9%99%86/"/>
      <url>/is-zxy.github.io/2020/03/26/%5B%E6%B4%9B%E8%B0%B7P2184%5D-%E8%B4%AA%E5%A9%AA%E5%A4%A7%E9%99%86/</url>
      
        <content type="html"><![CDATA[<p>小FF最后一道防线是一条长度为$N$的战壕， 小FF拥有无数多种地雷，而SCV每次可以在$[L,R]$区间埋放同一种不同于之前已经埋放的地雷。 由于情况已经十万火急，小FF在某些时候可能会询问你在$[L’,R’]$ 区间内有多少种不同的地雷， 他希望你能尽快的给予答复。</p><ul><li><code>1 L R</code>表示在$[L,R]$这段区间布上一种地雷。</li><li><code>2 L R</code>表示询问$[L,R]$区间总共有多少种地雷。</li></ul><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$0\le n,m\le 10^5$，$0\le L\le R\le n$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2184" target="_blank" rel="noopener">P2184 贪婪大陆</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑一个区间$[L,R]$。</p><p>在区间$[1,L)$内却不在$[L,R]$内的地雷种数为区间右端在$[1,L)$内的个数。</p><p>在区间$[1,R]$内的地雷种数为区间左端在$[1,R]$内的个数。</p><p>显然，区间$[L,R]$内的地雷种数为上述两个数量相减。</p><p>于是维护两个树状数组，一个维护区间左端个数的前缀和，一个维护区间右端个数的前缀和即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s[N],e[N],q,l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) s[x]++;</span><br><span class="line"><span class="keyword">for</span>(;y&lt;=n;y+=lowbit(y)) e[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asks</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=s[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aske</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=e[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">if</span>(q&amp;<span class="number">1</span>) update(l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;asks(r)-aske(l<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1438] 无聊的数列</title>
      <link href="/is-zxy.github.io/2020/03/25/%5B%E6%B4%9B%E8%B0%B7P1438%5D-%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/03/25/%5B%E6%B4%9B%E8%B0%B7P1438%5D-%E6%97%A0%E8%81%8A%E7%9A%84%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>维护一个数列$a_i$，支持两种操作：</p><ul><li><code>1 l r K D</code>：给出一个长度等于$r-l+1$的等差数列，首项为$K$，公差为$D$，并将它对应加到 $[l,r]$范围中的每一个数上。即：令$a_l=a_l+K,a_{l+1}=a_{l+1}+K+D\ldots a_r=a_r+K+(r-l) \times D$。</li><li><code>2 p</code>：询问序列的第$p$个数的值$a_p$。</li></ul><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$0\le n,m\le 10^5$，$-200\le a_i,K,D\le 200$，$1\le l\le r\le n$，$1\le p\le n$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1438" target="_blank" rel="noopener">P1438 无聊的数列</a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>我的想法比较直接，比较暴力。</p><p>直接维护！维护区间的最左端值，以及首项与公差的懒标记（显然满足区间可减性）。</p><p>细节见代码吧。。懒得解释。</p><p>看了题解后，发现还有两种比较妙的做法，一个是差分做法（其实和树状数组区间修改查询差不多）。一个是zkw线段树（自底向上的线段树？）。以后有时间再写<del>其实是现在懒得写</del>。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF ~0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,opt,l,r;</span><br><span class="line">ll k,d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll first,lazyd,lazyf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) tree[x].first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld(x) tree[x].lazyd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lf(x) tree[x].lazyf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ls|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">f(p)=f(ls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;f(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">f(ls)=f(p);</span><br><span class="line">f(rs)+=lf(p)+(l(rs)-l(p))*ld(p);</span><br><span class="line">ld(ls)+=ld(p);</span><br><span class="line">ld(rs)+=ld(p);</span><br><span class="line">lf(ls)+=lf(p);</span><br><span class="line">lf(rs)+=lf(p)+(l(rs)-l(p))*ld(p);</span><br><span class="line">ld(p)=<span class="number">0</span>;</span><br><span class="line">lf(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k,ll d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">f(p)+=d*(l(p)-l)+k;</span><br><span class="line">lf(p)+=d*(l(p)-l)+k;</span><br><span class="line">ld(p)+=d;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,k,d);</span><br><span class="line">change(rs,l,r,k,d);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;x||r(p)&lt;x) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) <span class="keyword">return</span> f(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> max(ask(ls,x),ask(rs,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt;</span><br><span class="line"><span class="keyword">if</span>(opt&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;k&gt;&gt;d;</span><br><span class="line">change(<span class="number">1</span>,l,r,k,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2253] 好一个一中腰鼓！</title>
      <link href="/is-zxy.github.io/2020/03/25/%5B%E6%B4%9B%E8%B0%B7P2253%5D-%E5%A5%BD%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AD%E8%85%B0%E9%BC%93%EF%BC%81/"/>
      <url>/is-zxy.github.io/2020/03/25/%5B%E6%B4%9B%E8%B0%B7P2253%5D-%E5%A5%BD%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AD%E8%85%B0%E9%BC%93%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>设想一下，腰鼓有两面，一面是红色的，一面是白色的。初二的苏大学神想给你这个oier出一道题。假设一共有$N(1&lt;=N&lt;=20,000)$个同学表演，表演刚开始每一个鼓都是红色面朝向观众，舞蹈老师会发出$M(1&lt;=M&lt;=20,000)$个指令，如果指令发给第i个表演的同学,这位同学就会把腰鼓反过来，如果腰鼓之前是红色面朝向观众的,那么就会变成白色面朝向观众，反之亦然。那么问题来了（！？），在老师每一次发出指令后，找到最长的连续的一排同学，满足每相邻的两个手中的腰鼓朝向观众的一面互不相同，输出这样一排连续的同学的人数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2253" target="_blank" rel="noopener">P2253 好一个一中腰鼓！</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>乍一看，本题貌似很复杂——求$01$相间的连续最长子序列长度。</p><p>但如果一开始就把这个$01$序列搞成$01$相间的话，问题就转化为——连续最长$0$个数与连续最长$1$个数的较大值。</p><p>那么这题就与之前做过的几题差不多了，甚至更水，因为本题是单点修改。</p><p><del>又是一个因为一个变量名而调了好长时间的一题呢</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,x;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,lmax0,rmax0,max0,lmax1,rmax1,max1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm0(x) tree[x].lmax0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm0(x) tree[x].rmax0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m0(x) tree[x].max0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm1(x) tree[x].lmax1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm1(x) tree[x].rmax1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m1(x) tree[x].max1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ls|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">m0(p)=max(rm0(ls)+lm0(rs),max(m0(ls),m0(rs)));</span><br><span class="line">m1(p)=max(rm1(ls)+lm1(rs),max(m1(ls),m1(rs)));</span><br><span class="line">lm0(p)=(lm0(ls)==r(ls)-l(ls)+<span class="number">1</span>)?lm0(ls)+lm0(rs):lm0(ls);</span><br><span class="line">rm0(p)=(rm0(rs)==r(rs)-l(rs)+<span class="number">1</span>)?rm0(rs)+rm0(ls):rm0(rs);</span><br><span class="line">lm1(p)=(lm1(ls)==r(ls)-l(ls)+<span class="number">1</span>)?lm1(ls)+lm1(rs):lm1(ls);</span><br><span class="line">rm1(p)=(rm1(rs)==r(rs)-l(rs)+<span class="number">1</span>)?rm1(rs)+rm1(ls):rm1(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">lm1(p)=rm1(p)=m1(p)=l&amp;<span class="number">1</span>;</span><br><span class="line">lm0(p)=rm0(p)=m0(p)=l&amp;<span class="number">1</span>^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;x||r(p)&lt;x) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">m1(p)^=<span class="number">1</span>;</span><br><span class="line">lm1(p)^=<span class="number">1</span>;</span><br><span class="line">rm1(p)^=<span class="number">1</span>;</span><br><span class="line">m0(p)^=<span class="number">1</span>;</span><br><span class="line">lm0(p)^=<span class="number">1</span>;</span><br><span class="line">rm0(p)^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">change(ls,x);</span><br><span class="line">change(rs,x);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">change(<span class="number">1</span>,x);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max(m0(<span class="number">1</span>),m1(<span class="number">1</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/P6492" target="_blank" rel="noopener">[COCI2010-2011#6] STEP</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> COCI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SCOI2010] 序列操作</title>
      <link href="/is-zxy.github.io/2020/03/24/%5BSCOI2010%5D-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/"/>
      <url>/is-zxy.github.io/2020/03/24/%5BSCOI2010%5D-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>lxhgww最近收到了一个$01$序列，序列里面包含了$n$个数，下标从$0$开始。这些数要么是$0$，要么是$1$，现在对于这个序列有五种变换操作和询问操作：</p><ul><li><code>0 l r</code> 把$[l, r]$区间内的所有数全变成$0$</li><li><code>1 l r</code> 把$[l, r]$区间内的所有数全变成$1$</li><li><code>2 l r</code> 把$[l,r]$区间内的所有数全部取反，也就是说把所有的$0$变成$1$，把所有的$1$变成$0$</li><li><code>3 l r</code> 询问$[l, r]$区间内总共有多少个$1$</li><li><code>4 l r</code> 询问$[l, r]$区间内最多有多少个连续的$1$</li></ul><p>对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m\le 10^5$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2572" target="_blank" rel="noopener">[SCOI2010]序列操作</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>调了好长时间。本想重构的，结果在今天早晨成功给调出来了2333。</p><p>题目有点像<a href="http://zxyer.xyz/2020/03/22/%5BUSACO08FEB%5D-Hotel-G/#more" target="_blank" rel="noopener">[USACO08FEB] Hotel G</a>。唯一的麻烦之处在于多了一个修改操作——取反。</p><p>于是需要维护的量有：区间内$1$的个数，区间左端最大连续$1$个数，区间右端最大连续$1$个数，区间最大连续$1$个数，区间左端最大连续$0$个数，区间右端最大连续$0$个数，区间最大连续$0$个数，以及懒标记。我写的这里，懒标记为$1$表示区间全变$0$，懒标记为$2$表示区间全变$1$，懒标记为$3$表示区间取反。</p><p>修改操作中，操作$0,1$都不算太难。操作$2$只需要将$0,1$的信息交换即可。</p><p>下传标记$1,2$都与之前相同。下传标记$3$时，若下传区间的标记为$1$则变$2$，为$2$则变$1$，为$3$则变$0$，这也很好理解，但我就是因为少了“为$3$”的情况而狂调了好长时间。</p><p>另外的就是<code>spread</code>的顺序问题了。切记在<code>change</code>操作前要<code>spread</code>，否则其子区间可能会漏、少操作，就是因为存在着这取反操作的缘故。我觉得在后面<code>spread</code>也是可以的，不过还是要像<code>spread</code>函数里一样分三种情况讨论。</p><p>写线段树，一定要想好细节的处理。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,op,l,r,tot=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,maxn1,lmaxn1,rmaxn1,maxn0,lmaxn0,rmaxn0,lazy,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m1(x) tree[x].maxn1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm1(x) tree[x].lmaxn1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm1(x) tree[x].rmaxn1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m0(x) tree[x].maxn0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm0(x) tree[x].lmaxn0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm0(x) tree[x].rmaxn0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">m1(p)=max(rm1(ls)+lm1(rs),max(m1(ls),m1(rs)));</span><br><span class="line">m0(p)=max(rm0(ls)+lm0(rs),max(m0(ls),m0(rs)));</span><br><span class="line"><span class="keyword">if</span>(lm1(ls)==r(ls)-l(ls)+<span class="number">1</span>) lm1(p)=lm1(ls)+lm1(rs);</span><br><span class="line"><span class="keyword">else</span> lm1(p)=lm1(ls);</span><br><span class="line"><span class="keyword">if</span>(rm1(rs)==r(rs)-l(rs)+<span class="number">1</span>) rm1(p)=rm1(rs)+rm1(ls);</span><br><span class="line"><span class="keyword">else</span> rm1(p)=rm1(rs);</span><br><span class="line"><span class="keyword">if</span>(lm0(ls)==r(ls)-l(ls)+<span class="number">1</span>) lm0(p)=lm0(ls)+lm0(rs);</span><br><span class="line"><span class="keyword">else</span> lm0(p)=lm0(ls);</span><br><span class="line"><span class="keyword">if</span>(rm0(rs)==r(rs)-l(rs)+<span class="number">1</span>) rm0(p)=rm0(rs)+rm0(ls);</span><br><span class="line"><span class="keyword">else</span> rm0(p)=rm0(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s(p));</span><br><span class="line">lm1(p)=rm1(p)=m1(p)=s(p);</span><br><span class="line">lm0(p)=rm0(p)=m0(p)=s(p)^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)==<span class="number">1</span>) &#123;</span><br><span class="line">s(ls)=s(rs)=<span class="number">0</span>;</span><br><span class="line">m1(ls)=lm1(ls)=rm1(ls)=<span class="number">0</span>;</span><br><span class="line">m0(ls)=lm0(ls)=rm0(ls)=r(ls)-l(ls)+<span class="number">1</span>;</span><br><span class="line">m1(rs)=lm1(rs)=rm1(rs)=<span class="number">0</span>;</span><br><span class="line">m0(rs)=lm0(rs)=rm0(rs)=r(rs)-l(rs)+<span class="number">1</span>;</span><br><span class="line">lazy(ls)=<span class="number">1</span>,lazy(rs)=<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)==<span class="number">2</span>) &#123;</span><br><span class="line">s(ls)=r(ls)-l(ls)+<span class="number">1</span>;</span><br><span class="line">s(rs)=r(rs)-l(rs)+<span class="number">1</span>;</span><br><span class="line">m1(ls)=lm1(ls)=rm1(ls)=r(ls)-l(ls)+<span class="number">1</span>;</span><br><span class="line">m0(ls)=lm0(ls)=rm0(ls)=<span class="number">0</span>;</span><br><span class="line">m1(rs)=lm1(rs)=rm1(rs)=r(rs)-l(rs)+<span class="number">1</span>;</span><br><span class="line">m0(rs)=lm0(rs)=rm0(rs)=<span class="number">0</span>;</span><br><span class="line">lazy(ls)=<span class="number">2</span>,lazy(rs)=<span class="number">2</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)==<span class="number">3</span>) &#123;</span><br><span class="line">s(ls)=r(ls)-l(ls)+<span class="number">1</span>-s(ls);</span><br><span class="line">s(rs)=r(rs)-l(rs)+<span class="number">1</span>-s(rs);</span><br><span class="line">swap(m1(ls),m0(ls)),swap(m1(rs),m0(rs));</span><br><span class="line">swap(lm1(ls),lm0(ls)),swap(lm1(rs),lm0(rs));</span><br><span class="line">swap(rm1(ls),rm0(ls)),swap(rm1(rs),rm0(rs));</span><br><span class="line"><span class="keyword">if</span>(!lazy(ls)) lazy(ls)=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lazy(ls)==<span class="number">1</span>) lazy(ls)=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lazy(ls)==<span class="number">2</span>) lazy(ls)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lazy(ls)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!lazy(rs)) lazy(rs)=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lazy(rs)==<span class="number">1</span>) lazy(rs)=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lazy(rs)==<span class="number">2</span>) lazy(rs)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lazy(rs)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line"><span class="keyword">if</span>(!x) &#123;</span><br><span class="line">s(p)=<span class="number">0</span>;</span><br><span class="line">m1(p)=lm1(p)=rm1(p)=<span class="number">0</span>;</span><br><span class="line">m0(p)=lm0(p)=rm0(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>) &#123;</span><br><span class="line">s(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">m1(p)=lm1(p)=rm1(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">m0(p)=lm0(p)=rm0(p)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s(p)=r(p)-l(p)+<span class="number">1</span>-s(p);</span><br><span class="line">swap(m1(p),m0(p));</span><br><span class="line">swap(lm1(p),lm0(p));</span><br><span class="line">swap(rm1(p),rm0(p));</span><br><span class="line">lazy(p)=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line"><span class="keyword">return</span> s(p);</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r,op)+ask(rs,l,r,op);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> m1(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> max(max(ask(ls,l,r,op),ask(rs,l,r,op)),min(rm1(ls),r(ls)-l+<span class="number">1</span>)+min(lm1(rs),r-l(rs)+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line">l++,r++;</span><br><span class="line"><span class="keyword">if</span>(op&lt;=<span class="number">2</span>) change(<span class="number">1</span>,l,r,op);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(<span class="number">1</span>,l,r,op));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> SCOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4145] 上帝造题的七分钟2/花神游历各国</title>
      <link href="/is-zxy.github.io/2020/03/23/%5B%E6%B4%9B%E8%B0%B7P4145%5D-%E4%B8%8A%E5%B8%9D%E9%80%A0%E9%A2%98%E7%9A%84%E4%B8%83%E5%88%86%E9%92%9F2-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/"/>
      <url>/is-zxy.github.io/2020/03/23/%5B%E6%B4%9B%E8%B0%B7P4145%5D-%E4%B8%8A%E5%B8%9D%E9%80%A0%E9%A2%98%E7%9A%84%E4%B8%83%E5%88%86%E9%92%9F2-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<p>“第一分钟，X说，要有数列，于是便给定了一个正整数数列。</p><p>第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。</p><p>第三分钟，k说，要能查询，于是便有了求一段数的和的操作。</p><p>第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。</p><p>第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。</p><p>第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。</p><p>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”</p><p>——《上帝造题的七分钟·第二部》</p><p>所以这个神圣的任务就交给你了。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m\le 100000,1\le l,r\le n$，数列中的数大于$0$，且不超过$10^{12}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4145" target="_blank" rel="noopener">P4145 上帝造题的七分钟2 / 花神游历各国</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>区间开方，不满足可减性，于是无法用线段树进行区间修改。</p><p>考虑单点修改，维护一个标记，标记一个区间内的数是否都为$0$或$1$，因为为$0$或$1$时就不需要开方了，开了也无意义。</p><p>然后就是熟悉的单点修改了，判断是否被标记过以达到一种“剪枝”的效果。由于最大数不超过$10^{12}$，可用计算器算出最多开方$6$次，这也是为什么单点修改能过掉本题$100000$数据的原因。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,l,r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) tree[x].flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">f(p)=f(ls)&amp;f(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s(p);</span><br><span class="line">f(p)=(s(p)==<span class="number">0</span>||s(p)==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f(p)||l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">s(p)=<span class="built_in">floor</span>(<span class="built_in">sqrt</span>(s(p)));</span><br><span class="line">f(p)=(s(p)==<span class="number">0</span>||s(p)==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">change(ls,l,r);</span><br><span class="line">change(rs,l,r);</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> s(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="keyword">if</span>(!k) change(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/SP2713" target="_blank" rel="noopener">SP2713 GSS4 - Can you answer these queries IV</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO08FEB] Hotel G</title>
      <link href="/is-zxy.github.io/2020/03/22/%5BUSACO08FEB%5D-Hotel-G/"/>
      <url>/is-zxy.github.io/2020/03/22/%5BUSACO08FEB%5D-Hotel-G/</url>
      
        <content type="html"><![CDATA[<p>参考样例，第一行输入$n$，$m$ ，$n$代表有$n$个房间，编号为$1\sim n$，开始都为空房，$m$表示以下有$m$行操作，以下 每行先输入一个数$i$，表示一种操作：</p><p>若$i$为$1$，表示查询房间，再输入一个数$x$，表示在$1\sim n$房间中找到长度为$x$的连续空房，输出连续$x$个房间中左端的房间号，尽量让这个房间号最小，若找不到长度为$x$的连续空房，输出$0$，并且在这$x$个空房间中住上人。</p><p>若$i$为$2$，表示退房，再输入两个数$x$，$y$ 代表房间号$x\sim x+y-1$退房，即让房间为空。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50,000$</p><p>$1\le m\le 50,00$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2894" target="_blank" rel="noopener">[USACO08FEB]Hotel G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>觉得很类似<a href="http://zxyer.xyz/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/" target="_blank" rel="noopener">[SP1716] GSS3 - Can you answer these queries III</a>。</p><p>需要维护的信息：一个区间的最大连续空房个数，一个区间左端的最大连续空房个数，一个区间右端的最大连续空房个数，<code>lazytag</code>。</p><p>由于<code>hange</code>有两种操作，退房与入住，所以当<code>lazytag=1</code>时表示退房，<code>lazytag=2</code>时表示入住。</p><p>本题的重点在于查询操作的写法，分类讨论区间左中右哪里满足最大连续空房个数大于等于$x$，但一定注意要<strong>左中右</strong>顺序，因为要求输出最左端的房间号。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,lmax,rmax,sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(x) tree[x].lmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(x) tree[x].rmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">lm(p)=rm(p)=s(p)=r-l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)==<span class="number">1</span>) &#123;</span><br><span class="line">lm(ls)=rm(ls)=s(ls)=r(ls)-l(ls)+<span class="number">1</span>;</span><br><span class="line">lm(rs)=rm(rs)=s(rs)=r(rs)-l(rs)+<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">lazy(ls)=lazy(rs)=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">lm(ls)=rm(ls)=s(ls)=lm(rs)=rm(rs)=s(rs)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">lazy(ls)=lazy(rs)=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s(ls)==r(ls)-l(ls)+<span class="number">1</span>) lm(p)=s(ls)+lm(rs);</span><br><span class="line"><span class="keyword">else</span> lm(p)=lm(ls);</span><br><span class="line"><span class="keyword">if</span>(s(rs)==r(rs)-l(rs)+<span class="number">1</span>) rm(p)=s(rs)+rm(ls);</span><br><span class="line"><span class="keyword">else</span> rm(p)=rm(rs);</span><br><span class="line">s(p)=max(max(s(ls),s(rs)),rm(ls)+lm(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">push_up(ls,l,r);</span><br><span class="line">push_up(rs,l,r);</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">push_down(ls,l,r);</span><br><span class="line">push_down(rs,l,r);</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) <span class="keyword">return</span> l(p);</span><br><span class="line"><span class="keyword">if</span>(s(ls)&gt;=x) <span class="keyword">return</span> ask(ls,x);</span><br><span class="line"><span class="keyword">if</span>(rm(ls)+lm(rs)&gt;=x) <span class="keyword">return</span> r(ls)-rm(ls)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ask(rs,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(s(<span class="number">1</span>)&lt;x) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> l=ask(<span class="number">1</span>,x);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">push_up(<span class="number">1</span>,l,l+x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">push_down(<span class="number">1</span>,x,x+y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1471] 方差</title>
      <link href="/is-zxy.github.io/2020/03/21/%5B%E6%B4%9B%E8%B0%B7P1471%5D-%E6%96%B9%E5%B7%AE/"/>
      <url>/is-zxy.github.io/2020/03/21/%5B%E6%B4%9B%E8%B0%B7P1471%5D-%E6%96%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<p>有一包含$n$个数的序列，对其进行$m$次操作，有如下三种操作：</p><p>操作1：$1\;x\;y\;k$，表示将第$x$到第$y$项每项加上$k$，$k$为一实数。</p><p>操作2：$2\;x\;y$，表示求出第$x$到第$y$项这一子数列的平均数。</p><p>操作3：$3\;x\;y$，表示求出第$x$到第$y$项这一子数列的方差。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m\le 100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1471" target="_blank" rel="noopener">P1471 方差</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>操作$1,2$很好搞。</p><p>将方差的式子拆开就会发现需要维护区间平方和以及区间和，这样就又变成了一个区间修改的线段树问题。</p><script type="math/tex; mode=display">\begin{align}s^2 &= \frac{1}{n}\sum_{i=1}^n(A_i-\bar{A})^2 \\s^2 &= \frac{1}{n}\sum_{i=1}^n(A_i^2-2\bar{A}A_i+\bar{A}^2) \\s^2 &= \frac{1}{n}\left[\sum_{i=1}^nA_i^2-2\bar{A}\sum_{i=1}^nA_i+n\bar{A}^2\right]\end{align}</script><p>据此维护即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,op,x,y;</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">double</span> sum,ssum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss(x) tree[x].ssum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s(p);</span><br><span class="line">ss(p)=s(p)*s(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">ss(p)=ss(ls)+ss(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line">ss(ls)+=<span class="number">2</span>*s(ls)*lazy(p)+(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">ss(rs)+=<span class="number">2</span>*s(rs)*lazy(p)+(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">s(ls)+=(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">s(rs)+=(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">lazy(ls)+=lazy(p);</span><br><span class="line">lazy(rs)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">ss(p)+=<span class="number">2</span>*s(p)*x+(r(p)-l(p)+<span class="number">1</span>)*x*x;</span><br><span class="line">s(p)+=(r(p)-l(p)+<span class="number">1</span>)*x;</span><br><span class="line">lazy(p)+=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">ss(p)=ss(ls)+ss(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask_s</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> s(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask_s(ls,l,r)+ask_s(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask_ss</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> ss(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask_ss(ls,l,r)+ask_ss(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change(<span class="number">1</span>,x,y,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;ask_s(<span class="number">1</span>,x,y)/(y-x+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">double</span> qsum=ask_s(<span class="number">1</span>,x,y);</span><br><span class="line"><span class="keyword">double</span> ave=qsum/(y-x+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;(ask_ss(<span class="number">1</span>,x,y)<span class="number">-2</span>*ave*qsum+(y-x+<span class="number">1</span>)*ave*ave)/(y-x+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2574] XOR的艺术</title>
      <link href="/is-zxy.github.io/2020/03/20/%5B%E6%B4%9B%E8%B0%B7P2574%5D-XOR%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/is-zxy.github.io/2020/03/20/%5B%E6%B4%9B%E8%B0%B7P2574%5D-XOR%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><ol><li>拥有一个伤害串，是一个长度为$n$的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从$1$开始。</li><li>给定一个范围$[l,r]$，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</li><li>会修改伤害串中的数值，修改的方法是把 $[l,r]$中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</li></ol><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 10\%$的数据，保证$n, m \leq 10$。</p><p>另有$30\%$的数据，保证$n, m \leq 2 \times 10^3$。</p><p>对于$100\%$的数据，保证$2 \leq n, m \leq 2 \times 10^5$，$0 \leq op \leq 1$，$1 \leq l \leq r \leq n$，$S$中只含字符 <code>0</code> 和字符 <code>1</code>。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2574" target="_blank" rel="noopener">P2574 XOR的艺术</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然是个数据结构题。</p><p>考虑线段树，由于涉及区间修改，需要lazytag。</p><p>此处能lazytag的依据是，一个区间”翻转”两次相当于没有翻转。</p><p>操作过程很好想，不再赘述。</p><p>注意标记下传。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,op,l,r;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=s[tot++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(ls)+sum(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line">sum(ls)=r(ls)-l(ls)+<span class="number">1</span>-sum(ls);</span><br><span class="line">sum(rs)=r(rs)-l(rs)+<span class="number">1</span>-sum(rs);</span><br><span class="line">lazy(ls)^=<span class="number">1</span>;</span><br><span class="line">lazy(rs)^=<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=r(p)-l(p)+<span class="number">1</span>-sum(p);</span><br><span class="line">lazy(p)^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r);</span><br><span class="line">change(rs,l,r);</span><br><span class="line">sum(p)=sum(ls)+sum(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">if</span>(!op) change(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/P3870" target="_blank" rel="noopener">[TJOI2009]开关</a></p><p><a href="https://www.luogu.com.cn/problem/P2846" target="_blank" rel="noopener">[USACO08NOV]Light Switching </a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TJOI2018] 数学计算</title>
      <link href="/is-zxy.github.io/2020/03/20/%5BTJOI2018%5D-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
      <url>/is-zxy.github.io/2020/03/20/%5BTJOI2018%5D-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>小豆现在有一个数$x$，初始值为$1$。小豆有$Q$次操作，操作有两种类型：</p><p>$1\;m$：$x=x\times m$输出$x\%mod$；</p><p>$2\;pos$：$x= x/$第$pos$次操作所乘的数（保证第$pos$次操作一定为类型$1$,对于每一个类型$1$的操作至多会被除一次）输出$x\%mod$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$1\leq Q\leq500$</p><p>对于$100\%$的数据，$1\leq Q\leq100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4588" target="_blank" rel="noopener">[TJOI2018]数学计算</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用线段树维护一个长度为$Q$的序列。</p><p>初始时全为$1$，操作时单点修改即可，答案即为线段树的根节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,Q,op;</span><br><span class="line">ll m,mod;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d(x) tree[x].data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r,d(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,ll v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">d(p)=v;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) change(ls,x,v);</span><br><span class="line"><span class="keyword">else</span> change(rs,x,v);</span><br><span class="line">d(p)=mul(d(ls),d(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">1</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;Q,&amp;mod);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;op,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">change(<span class="number">1</span>,i,m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">change(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> TJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF743C] Vladik and fractions</title>
      <link href="/is-zxy.github.io/2020/03/20/%5BCF743C%5D-Vladik-and-fractions/"/>
      <url>/is-zxy.github.io/2020/03/20/%5BCF743C%5D-Vladik-and-fractions/</url>
      
        <content type="html"><![CDATA[<p>请找出一组合法的解使得$\frac {1}{x} + \frac{1}{y} + \frac {1}{z} = \frac {2}{n}$成立<br>其中$x,y,z$为正整数并且互不相同</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 10^4$，要求答案$x,y,z\le 2\times 10^9$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF743C" target="_blank" rel="noopener">CF743C Vladik and fractions</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没想出来，看了题解，妙啊..</p><p>当$n&gt;0$时</p><script type="math/tex; mode=display">\frac{1}{n(n+1)}=\frac{1}{n}-\frac{1}{n+1}</script><p>移项</p><script type="math/tex; mode=display">\frac{1}{n}=\frac{1}{n+1}+\frac{1}{n(n+1)}</script><p>两边同时加$\frac{1}{n}$</p><script type="math/tex; mode=display">\frac{2}{n}=\frac{1}{n}+\frac{1}{n+1}+\frac{1}{n(n+1)}</script><p>于是得解。</p><p>由于$x,y,z$互不相同，所以$n=1$时特判输出$-1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;n+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n*(n+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正向不好解决时，考虑反向推。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 构造 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO04OPEN] MooFest</title>
      <link href="/is-zxy.github.io/2020/03/19/%5BUSACO04OPEN%5D-MooFest/"/>
      <url>/is-zxy.github.io/2020/03/19/%5BUSACO04OPEN%5D-MooFest/</url>
      
        <content type="html"><![CDATA[<p>每一年，约翰的$N$只奶牛参加奶牛狂欢节。这是一个全世界奶牛都参加的大联欢。狂欢节包括很多有趣的活动，比如干草堆叠大赛、跳牛栏大赛，奶牛之间有时还相互扎屁股取乐。当然，她们会排成一列嚎叫，来欢庆她们的节日。奶牛们的叫声实在刺耳，以致于每只奶牛的听力都受到不同程度的损伤。现在告诉你奶牛$i$的听力为$v_i$，这表示如果奶牛$j$想说点什么让她听到，必须用高于$ v_i \times dis(i,j)$的音量。因此，如果奶牛$i$和$j$想相互交谈，她们的音量必须不小于$\max (v_i,v_j) \times dis(i,j)$。其中$dis(i,j)$表示她们间的距离。</p><p>现在$N$只奶牛都站在一条直线上了，每只奶牛还有一个坐标$x_i$。如果每对奶牛都在交谈，并且使用最小音量，那所有$N(N-1)/2$对奶牛间谈话的音量之和为多少？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>因为原数据下$O(N^2)$算法可以通过，所以新添加了一些增强数据。</p><p>原数据作为子任务$1$，新添加的数据作为子任务$2$。</p><ul><li>子任务$1$（$1$分）：$1 \leq N,V_i,x_i \leq 2 \times 10^4$。</li><li>子任务$2$（$99$分）：$1 \leq N,V_i,x_i \leq 5 \times 10^4$。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5094" target="_blank" rel="noopener">[USACO04OPEN]MooFest</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接模拟的暴力$O(N^2)$算法肯定是过不了的。</p><p>考虑排序。将奶牛按$v$的值从小到大进行排序，这样依次处理，这样便可以保证目前正处理的奶牛的$v$值是所有被处理过的最大的。那么还需要解决的问题就是求出被处理过的奶牛中坐标比处理中的奶牛坐标小、大的个数以及坐标总和。可以考虑树状数组在线维护，只需两个，维护比其小坐标数与和，比其大可通过其求出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll v[N],x[N],js[N],sum[N],s=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll v,x;</span><br><span class="line">&#125;cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.v&lt;y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll t=x;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;N;x+=lowbit(x)) js[x]+=<span class="number">1</span>,sum[x]+=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask_js</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=js[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask_sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=sum[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;cow[i].v&gt;&gt;cow[i].x;</span><br><span class="line"></span><br><span class="line">sort(cow+<span class="number">1</span>,cow+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> as=ask_sum(cow[i].x),aj=ask_js(cow[i].x);</span><br><span class="line">ans+=(aj*cow[i].x-as)*cow[i].v;</span><br><span class="line">ans+=(s-as-(i<span class="number">-1</span>-aj)*cow[i].x)*cow[i].v;</span><br><span class="line">update(cow[i].x);</span><br><span class="line">s+=cow[i].x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JSOI2008] 星球大战</title>
      <link href="/is-zxy.github.io/2020/03/17/%5BJSOI2008%5D-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/"/>
      <url>/is-zxy.github.io/2020/03/17/%5BJSOI2008%5D-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。</p><p>某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。</p><p>但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。</p><p>现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1197" target="_blank" rel="noopener">[JSOI2008]星球大战</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据每次打击的目标，删边再搞？</p><p>显然过于暴力，铁定TLE。</p><p>难道非要在线吗？</p><p>考虑离线做法。</p><p>将打击对象全部读入后，倒序处理。当处理到底$i$个目标时$(i\in[1,k])$，将与第$i+1$个目标相连的所有路给修起来。特别的，当处理第$k$个目标时，将所有不与这$k$个目标相连的路给修起来。然后每次并查集求出连通块数量存入数组。</p><p>最后正序输出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],k,atk[N],vset[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].u=u;</span><br><span class="line">edge[tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(vset[i]==i) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(edge[i].u==x||edge[i].v==x) &#123;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">vh[atk[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">ans[k]=ask()-k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">vh[atk[i+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">build(atk[i+<span class="number">1</span>]);</span><br><span class="line">ans[i]=ask()-i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交后，TLE了7个点。</p><p>发现这是个傻逼写法。build函数写的有大问题，既然修与$x$连通的点，为何还需要遍历所有边？于是改了改build函数，还是TLE。</p><p>考虑优化，发现每次加入一个点，其连通块的个数其实是可以从未加入此点时的连通块个数得出来的。即build函数中，连通了$x$次，那么连通块的个数就减少了$x-1$个。因为每连通一次，连通块就减少一个。而刚加入这个点时，连通块增加了一个，于是就是减少了$x-1$个连通块。</p><p>这样大大优化后，便可以AC了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],k,atk[N],vset[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].u=u;</span><br><span class="line">edge[tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(vset[i]==i) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(edge[i].u==x||edge[i].v==x) &#123;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line"><span class="keyword">if</span>(fu!=fv) &#123;</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">vh[atk[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">ans[k]=ask()-k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">vh[atk[i+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=build(atk[i+<span class="number">1</span>]);</span><br><span class="line">ans[i]=ans[i+<span class="number">1</span>]+<span class="number">1</span>-tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSOI </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2013] 随机数生成器</title>
      <link href="/is-zxy.github.io/2020/03/16/%5BSDOI2013%5D-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/is-zxy.github.io/2020/03/16/%5BSDOI2013%5D-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>小W喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有$P$页，页码范围为$0 \cdots P-1$。</p><p>小W很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用NOI2012上学习的线性同余法生成一个序列，来决定每天具体读哪一页。</p><p>我们用$X_i$来表示通过这种方法生成出来的第$i$个数，也即小W第$i$天会读哪一页。这个方法需要设置$3$个参数$a,b,X_1$，满足$0\leq a,b,X_1\leq p-1$，且$a,b,X_1$都是整数。按照下面的公式生成出来一系列的整数：$X_{i+1} \equiv aX_i+b \pmod p$其中$\bmod$表示取余操作。</p><p>但是这种方法可能导致某两天读的页码一样。</p><p>小W要读这本书的第$t$页，所以他想知道最早在哪一天能读到第$t$页，或者指出他永远不会读到第$t$页。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$0≤a≤P−1,0≤b≤P−1,2≤P≤10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3306" target="_blank" rel="noopener">[SDOI2013]随机数生成器</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分类讨论一下。</p><ul><li><p>当$a=0$时，$X_i,i\ge 2$一直为$b$，判断$b$是否等于$t$即可。</p></li><li><p>当$a=1$时，$X_{i+1}=X_i+b$，显然是个等差数列，$X_n=X_1+(n-1)b$。</p><p>那么所求的天数$n$即为满足$X_1+(n-1)b\equiv t\pmod p$的最小非负整数解。</p><p>这可以用扩欧进行求解。</p></li><li><p>当$a\ge1$时，$X_{i+1}=aX_i+b$。</p><p>待定系数法搞一下，设$X_{i+1}+k=a(X_i+k)$，解得$k=\frac{b}{a-1}$。</p><p>代入即</p><script type="math/tex; mode=display">X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1})</script><p>那么数列$Y_n=X_n+\frac{b}{a-1}$为一个公比为$a$的等比数列。</p><p>由于$X_1$已知，可以求出$Y_1=X_1+\frac{b}{a-1}$。</p><p>那么</p><script type="math/tex; mode=display">Y_n=(X_1+\frac{b}{a-1})a^{n-1}</script></li></ul><p>  则</p><script type="math/tex; mode=display">  X_n=(X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}</script><p>  则所求的天数$n$即为满足</p><script type="math/tex; mode=display">  (X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}\equiv t\pmod p</script><p>  稍微移个项，化个简</p><script type="math/tex; mode=display">  \begin{align}  (X_1+\frac{b}{a-1})a^{n-1} &\equiv t+\frac{b}{a-1}\pmod p \\  a^{n-1} &\equiv \frac{t+\frac{b}{a-1}}{X_1+\frac{b}{a-1}}\pmod p \\  a^{n-1} &\equiv \frac{at-t+b}{aX_1-X_1+b}\pmod p \\  a^{n-1} &\equiv (at-t+b)\times (aX_1-X_1+b)^{-1}\pmod p  \end{align}</script><p>  注意不能两边同乘一个$a$过去，否则会出带问题！会解出来$0$的。这里只需解出来后加一即可。由于$p$为质数，所以可以用$BSGS$求出$n$的值。</p><p>  其中$(aX_1-X_1+b)^{-1}$表示模$p$意义下的逆元，由于保证$p$为质数，可用费马小定理求出来。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p+p)%p)*((y%p+p)%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll p,a,b,X_1,t,x,y;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(x,mul(t,t));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)),tmp=b,t=quickp(a,k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=mul(tmp,a);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=mul(tmp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>,&amp;p,&amp;a,&amp;b,&amp;X_1,&amp;t);</span><br><span class="line"><span class="keyword">if</span>(X_1==t) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!a) &#123;</span><br><span class="line"><span class="keyword">if</span>(b==t) <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>) &#123;</span><br><span class="line">ll Y=((t+b-X_1)%p+p)%p,gcd=EXGCD(b,p,x,y),ans;</span><br><span class="line"><span class="keyword">if</span>(Y%gcd) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x*=Y/gcd;</span><br><span class="line">ans=(x%p+p)%p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,!ans?p:ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll A=a,B=mul(mul(a,t)-t+b,quickp(mul(mul(a,X_1)-X_1+b,<span class="number">1</span>),p<span class="number">-2</span>));</span><br><span class="line">ll ans=BSGS(A,B,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交了十几遍，结果发现错误原因是求$a\not=1$时的式子时，用自己写的<code>mul</code>操作后可能为负…..于是把<code>mul</code>给改了，保证俩大于$0$。代码中的<code>mul(a,X_1)-X_1+b,1)</code>也是为了保证其大于$0$而这样写的。<del>果然我太弱了呢</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4884] 多少个1？</title>
      <link href="/is-zxy.github.io/2020/03/15/%5B%E6%B4%9B%E8%B0%B7P4884%5D-%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F/"/>
      <url>/is-zxy.github.io/2020/03/15/%5B%E6%B4%9B%E8%B0%B7P4884%5D-%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>给定整数$K$和质数$m$，求最小的正整数$N$，使得$11\cdots1$（$N$个$1$）$ \equiv K \pmod m$</p><p>说人话：就是$111…1111 \bmod m =K$</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$30\%$的数据保证$m\leq 10^6$</p><p>$60\%$的数据保证$m\leq 5\times 10^7$</p><p>$100\%$的数据保证$2\leq m\leq 10^{11},0\leq K&lt; m$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4884" target="_blank" rel="noopener">P4884 多少个1？</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>令$11\cdots1$（$N$个$1$）等于$Q$。</p><p>即</p><script type="math/tex; mode=display">Q\equiv K\pmod m</script><p>则</p><script type="math/tex; mode=display">9Q \equiv 9K\pmod m</script><p>而$9Q=10^N-1$，则</p><script type="math/tex; mode=display">10^N-1\equiv 9K\pmod m</script><p>即</p><script type="math/tex; mode=display">10^N\equiv 9K+1\pmod m</script><p>保证$m$为质数了，所以直接BSGS即可。</p><p>$m\le 10^{11}$，可能爆long long。需要写个龟速乘。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll k,m,ans;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll x,ll y,ll p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(x,plus(t,t));</span><br><span class="line"><span class="keyword">return</span> plus(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y,ll p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> gsc(x,gsc(t,t,p),p);</span><br><span class="line"><span class="keyword">return</span> gsc(t,t,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll tmp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=gsc(tmp,a,p);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=gsc(tmp,t,p);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">ans=BSGS(<span class="number">10</span>,<span class="number">9</span>*k+<span class="number">1</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2011] 计算器</title>
      <link href="/is-zxy.github.io/2020/03/15/%5BSDOI2011%5D-%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/is-zxy.github.io/2020/03/15/%5BSDOI2011%5D-%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>你被要求设计一个计算器完成以下三项任务：</p><ol><li>给定$y,z,p$，计算$ y^z \bmod p$的值；</li><li>给定$ y,z,p$，计算满足$ xy \equiv z \pmod p$的最小非负整数$ x$；</li><li>给定$ y,z,p$，计算满足$ y^x \equiv z \pmod p$的最小非负整数$ x$。</li></ol><p>为了拿到奖品，全力以赴吧！</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>测试点共分为三类，各类测试点占总测试点的比例如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$K=$</th><th style="text-align:center">测试点占比</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$20\%$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$35\%$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$45\%$</td></tr></tbody></table></div><p>所有数据均满足：$1 \leq y,z,p \leq 10^9$，$p$是质数，$1 \leq T \leq 10$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2485" target="_blank" rel="noopener">[SDOI2011]计算器</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于保证$p$是质数，所以导致本题及其好做。</p><p>对于第一项任务，快速幂即可。</p><p>对于第二项任务，EXGCD即可。</p><p>对于第三项任务，BSGS即可。</p><p>调了两小时找不出错，最后发现变量名（y）重复了….崩溃….<del>果然我是个制杖呢</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,k;</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll tmp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=mul(tmp,a);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=mul(tmp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ll a,z,p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;z&gt;&gt;p;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;quickp(a,z,p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">2</span>) &#123;</span><br><span class="line">ll gcd=EXGCD(a,p,x,y);</span><br><span class="line"><span class="keyword">if</span>(z%gcd) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Orz, I cannot find x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;((x*(z/gcd))%p+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">3</span>) &#123;</span><br><span class="line">ll ans=BSGS(a,z,p);</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Orz, I cannot find x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">work(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> SDOI </tag>
            
            <tag> EXGCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS及EXBSGS算法学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/15/BSGS%E5%8F%8AEXBSGS%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/15/BSGS%E5%8F%8AEXBSGS%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>BSGS是用来解决离散对数问题的一种算法。</p><p>离散对数问题是这样一个问题，它是要求解模方程</p><script type="math/tex; mode=display">a^x\equiv b\pmod p</script><a id="more"></a><h1 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h1><p>首先来看$p$为质数的情况。</p><p>因为$a$与$p$互质，由费马小定理得$a^{p-1}=1\pmod p$。</p><p>取模值循环出现，于是可以判断，若有解的话，$x\in[0,p-2]$。</p><p>设$k=\lceil \sqrt p \rceil$，令$x=ik-j$，$i\in[0,k],j\in[0,k-1]$，这样$x$便能取遍$[0,p-2]$内所有数。</p><p>则原式变为</p><script type="math/tex; mode=display">\begin{align}a^{ik-j} &\equiv b\pmod p \\a^{ik} &\equiv b\times a^j\pmod p\end{align}</script><p>于是可以分别算出左面式子的所有值和右面式子的所有值，当出现相等的情况说明有解为$ik-j$。</p><p>这过程可用map实现。</p><h2 id="例题-洛谷P4028-New-Product"><a href="#例题-洛谷P4028-New-Product" class="headerlink" title="例题 [洛谷P4028] New Product"></a>例题 [洛谷P4028] New Product</h2><p>LiM有一家手工糕点店，因为糕点既实惠又好吃，于是积累了$P$个常客。（$P$为质数）</p><p>每次这家店出$NewProduct$（新品）的时候，都会做很多个，这$P$个人都会支持，支持方法是：</p><p><strong>每个人买的数量都相同，而且买的总数要尽量多</strong></p><p>这家店共有$B$个工人，一分钟可以生产已经生产的数量的$A$倍。</p><p>（注：一开始有一个已制作的$New Product$作为制作样品）</p><p>而当制作完毕，抢购（只考虑常客）完后：</p><p><strong>为了考虑工人们，最后要剩下正好$B$个。</strong></p><p>下面给出已知条件，请你帮LiM算算最少要工作多长时间吧！</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$20\%$的数据，$T=1$，所有条件$\le 100$。</p><p>对于$100\%$的数据，$T\le 5000$，所有条件$\le 50000$。$P$为质数！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>板子板子板子。</p><p>求$A^x\equiv B\pmod P$。</p><p>按照上述过程瞎搞即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,p,a,b;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll temp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">temp=mul(temp,a);</span><br><span class="line">vh[temp]=j;</span><br><span class="line">&#125;</span><br><span class="line">temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">temp=mul(temp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[temp]) <span class="keyword">return</span> ((i*k-vh[temp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">int</span> ans=BSGS(p,a,b);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Couldn't Produce!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2485" target="_blank" rel="noopener">[SDOI2011]计算器</a></td><td><a href="https://www.luogu.com.cn/record/31799231" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4884" target="_blank" rel="noopener">[洛谷P4884]多少个1？</a></td><td><a href="https://www.luogu.com.cn/record/31800689" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3306" target="_blank" rel="noopener">[SDOI2013]随机数生成器</a></td><td><a href="https://www.luogu.com.cn/record/31834345" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3846" target="_blank" rel="noopener">[TJOI2007]可爱的质数</a></td><td><a href="https://www.luogu.com.cn/record/31799504" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><h1 id="EXBSGS算法"><a href="#EXBSGS算法" class="headerlink" title="EXBSGS算法"></a>EXBSGS算法</h1><p>咕咕咕</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2018] 屠龙勇士</title>
      <link href="/is-zxy.github.io/2020/03/14/%5BNOI2018%5D-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/"/>
      <url>/is-zxy.github.io/2020/03/14/%5BNOI2018%5D-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<p>小 D 最近在网上发现了一款小游戏。游戏的规则如下：</p><ul><li>游戏的目标是按照编号$ 1 \rightarrow n$顺序杀掉$ n$条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加$ p_i$，直至生命值非负。只有在攻击结束后且当生命值 <strong>恰好</strong> 为$ 0$时它才会死去。</li><li>游戏开始时玩家拥有$ m$把攻击力已知的剑，每次面对巨龙时，玩家只能选择一 把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。 小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格， 于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：</li><li>每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 <strong>攻击力最低</strong> 的一把剑作为武器。</li><li>机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的$ x$次，使巨龙的生命值减少$ x \times ATK$。</li><li>之后，巨龙会不断使用恢复能力，每次恢复$ p_i$生命值。若在使用恢复能力前或某一次恢复后其生命值为$ 0$，则巨龙死亡，玩家通过本关。</li></ul><p>那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数$ x$设置为多少，才能用最少的攻击次数通关游戏吗？</p><p>当然如果无论设置成多少都无法通关游戏，输出$ -1$即可。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><div class="table-container"><table><thead><tr><th><strong>测试点编号</strong></th><th>$n$</th><th>$m$</th><th>$p_i$</th><th>$a_i$</th><th><strong>攻击力</strong></th><th><strong>其他限制</strong></th></tr></thead><tbody><tr><td>1</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$=1$</td><td>无</td></tr><tr><td>2</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$=1$</td><td>无</td></tr><tr><td>3</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无</td></tr><tr><td>4</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无</td></tr><tr><td>5</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>6</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>7</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>8</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>9</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>10</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>11</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>12</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>13</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>14</td><td>$=10^5$</td><td>$=10^5$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>无特殊限制</td></tr><tr><td>15</td><td>$=10^5$</td><td>$=10^5$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>无特殊限制</td></tr><tr><td>16</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>所有$p_i$是质数</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>17</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>所有$p_i$是质数</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>18</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>19</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>20</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr></tbody></table></div><p>特性 1 是指：对于任意的$ i$，$a_i \le p_i$。</p><p>特性 2 是指：$\operatorname{lcm}(p_i) \le 10^6$，即所有$ p_i$的 <strong>最小公倍数</strong> 不大于$ 10^6$。</p><p>对于所有的测试点，$T \le 5$，所有武器的攻击力$ \le 10^6$，所有$ p_i$的最小公倍数$ \le 10^{12}$。</p><p>保证$ T, n, m$均为正整数。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">[NOI2018]屠龙勇士</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，肯定要决定面对每条龙的剑。这个可以用multiset+upper_bound预处理出来。</p><p>定义面对龙$i$时剑的攻击力为$b[i]$。</p><p>那么对于每条龙$i$，其问题转化为$b[i]\times x+p[i]\times y=a[i]$，可变为同余方程$b[i]\times x\equiv a[i] \pmod{p[i]}$。</p><p>$x$即为满足$1\sim n$所有方程的最小解。</p><p>这个同余方程发现，其$x$前带有系数。但我们前面学过的中国剩余定理只能解决$x$无系数的。</p><p>于是想办法把系数给搞掉。</p><p>假设同余方程$b[i]\times x+p[i]\times y=a[i]$，已经求出一个特解$x_0$，则通解即为$x=x_0+\frac{p[i]}{gcd(b[i],p[i])}\times t,t\in Z$。</p><p>即$x\equiv x_0\pmod{\frac{p[i]}{gcd(b[i],p[i])}}$。成功把系数搞没了。</p><p>于是便把这道题变成了一个EXCRT的板子题。</p><p>注意快速乘，直接乘爆longlong。</p><p>注意$p[i]=1$的情况，这时取模为$0$，答案应为$\max_{i=1}^n\{\lceil\frac{a[i]}{b[i]}\rceil\}$，特判一下即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><del>好繁长啊我好菜</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y,mod) ((x%mod)+(y%mod))%mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y,mod) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line">ll a[N],p[N],atk[N],b[N],qa[N],qb[N],x,y,ans,maxn;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">multiset</span> &lt;ll&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll x,ll y,ll mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(x,y/<span class="number">2</span>,mod);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(x,plus(t,t,mod),mod);</span><br><span class="line"><span class="keyword">return</span> plus(t,t,mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readp_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">s.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">ll x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">s.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">multiset</span> &lt;ll&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">it=s.upper_bound(a[i]);</span><br><span class="line"><span class="keyword">if</span>(it!=s.begin()) it--;</span><br><span class="line">b[i]=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert(atk[i]);</span><br><span class="line">maxn=max(maxn,(a[i]+b[i]<span class="number">-1</span>)/b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(b[i],p[i],x,y);</span><br><span class="line"><span class="keyword">if</span>(a[i]%gcd) flag=<span class="literal">false</span>;</span><br><span class="line">qb[i]=p[i]/gcd;</span><br><span class="line">qa[i]=(gsc(x,(a[i]/gcd),qb[i])+qb[i])%qb[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXCRT</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ans=a[<span class="number">1</span>];</span><br><span class="line">ll m=b[<span class="number">1</span>],x,y,js=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(m,b[i],x,y),c=(plus(a[i],-ans,b[i])+b[i])%b[i];</span><br><span class="line"><span class="keyword">if</span>(c%gcd) &#123;</span><br><span class="line">ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c/=gcd;</span><br><span class="line">x=gsc(x,c,b[i]);</span><br><span class="line">ans+=m*x;</span><br><span class="line">m*=b[i]/gcd;</span><br><span class="line">ans=(ans%m+m)%m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line">maxn=<span class="number">0</span>;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">readp_init();</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXCRT(qa,qb,n);</span><br><span class="line"><span class="keyword">if</span>(ans) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;max(ans,maxn)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> NOI </tag>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TJOI2009] 猜数字</title>
      <link href="/is-zxy.github.io/2020/03/11/%5BTJOI2009%5D-%E7%8C%9C%E6%95%B0%E5%AD%97/"/>
      <url>/is-zxy.github.io/2020/03/11/%5BTJOI2009%5D-%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>现有两组数字，每组$k$个。</p><p>第一组中的数字分别用$ a_1,a_2,\cdots ,a_k$表示，第二组中的数字分别用$ b_1,b_2,\cdots ,b_k$表示。</p><p>其中第二组中的数字是两两互素的。求最小的$ n\in \mathbb{N}$，满足对于$ \forall i\in [1,k]$，有$ b_i | (n-a_i)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1≤k≤10，|a_i|\le 10^9$，$1\le b_i\le 6\times 10^3$，$\prod_{i=1}^k b_i\le 10^{18}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">[TJOI2009]猜数字</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>裸的不能再裸的CRT。</p><p>唯一需要注意的是求解过程中可能爆longlong，要龟速乘（其实和快速幂差不多）。</p><p>龟速乘调用负数时需注意，调换一下顺序。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%m)+(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%m)*(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],m=<span class="number">1</span>,x,y,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line">ll t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksc</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=ksc(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(plus(t,t),x);</span><br><span class="line"><span class="keyword">return</span> plus(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">m*=b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(m/b[i],b[i]);</span><br><span class="line">x=(x%b[i]+b[i])%b[i];</span><br><span class="line">ans=plus(ans,ksc(a[i],ksc(m/b[i],x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> TJOI </tag>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理(CRT)及扩展中国剩余定理(EXCRT)学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/11/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT-%E5%8F%8A%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-EXCRT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/11/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT-%E5%8F%8A%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-EXCRT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>其实CRT很早就学过了<del>但是由于本人太蒻了，忘了</del>。</p><p>于是复习一遍，顺带学习学习EXCRT。</p><a id="more"></a><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>《孙子算经》中有“物不知数”问题：“今有物不知其数，三三数之余二，五五数之余三，七七数之余二，问物几何？”即一个整数除以三余二，除以五余三，除以七余二，求这个整数。</p><p>这个问题可以表示成如下的同余方程组</p><script type="math/tex; mode=display">\begin{cases}x\equiv 2\pmod 3 \\x\equiv 3\pmod 5 \\x\equiv 2\pmod 7\end{cases}</script><p>该问题的解显然有无数个。设有一个解为$x_0$，则$x=k\times 105+x_0$均为问题的解。</p><p>考虑以下三个特征方程</p><p>$\begin{cases}x\equiv 1\pmod 3 \\x\equiv 0\pmod 5 \\x\equiv 0\pmod 7\end{cases}\qquad\begin{cases}x\equiv 0\pmod 3 \\x\equiv 1\pmod 5 \\x\equiv 0\pmod 7\end{cases}\qquad\begin{cases}x\equiv 0\pmod 3 \\x\equiv 0\pmod 5 \\x\equiv 1\pmod 7\end{cases}$</p><p>用扩欧求解方程$35m_1\equiv 1\pmod3$，$21m_2\equiv 1\pmod5$，$15m_3\equiv 1\pmod 7$</p><p>解出$m_1,m_2,m_3$后，原同余方程的一个解即为</p><script type="math/tex; mode=display">[2\times (m_1 \times 35)+3\times (m_2\times 21)+2\times (m_3\times 15)]\%105=23</script><hr><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>设自然数$m_1,m_2,\cdots,m_r$两两互质，并记$N=\prod_{i=1}^rm_i$，则同余方程组</p><script type="math/tex; mode=display">\begin{cases} x\equiv b_1\pmod {m_1} \\x\equiv b_2\pmod {m_2} \\\qquad\quad\cdots \\\qquad\quad\cdots \\x\equiv b_r\pmod {m_r}\end{cases}</script><p>在模$N$同余的意义下有唯一解。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>考虑方程组$(1\le i\le r)$：$\begin{cases} x\equiv 0\pmod{m_1} \\ \qquad\quad \cdots \\ x\equiv 0\pmod{m_{i-1}} \\ x\equiv 1\pmod{m_i} \\ x\equiv 0\pmod{m_{i+1}} \\ \quad\qquad\cdots \\ x\equiv 0\pmod{m_{r}}\end{cases}$</p><p>由于各个$m_i(1\le i\le r)$两两互质，将这个方程组作变量替换，令$x=\frac{N}{m_i}\times y$，于是原方程组等同于同余方程$\frac{N}{m_i}\times y\equiv 1\pmod {m_i}$，可用扩欧算出$y$。若要解得特解$x_i$，只要令：$x_i=\frac{N}{m_i}\times y_i$，则方程组的解为$x_0=\sum_{i=1}^r b_i\times x_i\pmod N$，在模$N$意义下唯一。</p><h3 id="例题-洛谷P1495-【模板】中国剩余定理-CRT-曹冲养猪"><a href="#例题-洛谷P1495-【模板】中国剩余定理-CRT-曹冲养猪" class="headerlink" title="例题 [洛谷P1495] 【模板】中国剩余定理(CRT)/曹冲养猪"></a>例题 [洛谷P1495] 【模板】中国剩余定理(CRT)/曹冲养猪</h3><p>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有$16$头母猪，如果建了$3$个猪圈，剩下$1$头猪就没有地方安家了。如果建造了$5$个猪圈，但是仍然有$1$头猪没有地方去，然后如果建造了$7$个猪圈，还有$2$头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 10$</p><p>$b_i\le a_i\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1495" target="_blank" rel="noopener">P1495 【模板】中国剩余定理(CRT)/曹冲养猪</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>仿照上面的过程求解即可。</p><p>注意将解通过取模移至最小正整数解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%m)+(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%m)*(y%m))%m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],x,y,m=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line">ll t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">m*=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(m/a[i],a[i]);</span><br><span class="line">x=(x%a[i]+a[i])%a[i];</span><br><span class="line">ans=plus(ans,mul(m/a[i],mul(x,b[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/UVA756" target="_blank" rel="noopener">UVA756 Biorhythms</a></td><td><a href="https://www.luogu.com.cn/record/24153513" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">[TJOI2009]猜数字</a></td><td><a href="https://www.luogu.com.cn/record/31636980" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><p>上面的算法对于模数是有限制条件的，即两两互质。</p><p>那么如果不两两互质呢？</p><p>先从含有两个方程的同余方程组考虑。</p><script type="math/tex; mode=display">\begin{cases}x\equiv b_1\pmod{m_1} \\x\equiv b_2\pmod{m_2}\end{cases}</script><p>令$x=k_1\times m_1+b_1=k_2\times m_2+b_2$。</p><p>那么考虑此式</p><script type="math/tex; mode=display">\begin{align}m_1\times k_1+b_1&=m_2\times k_2+b_2 \\m_1\times k_1-m_2\times k_2 &=b_2-b_1\end{align}</script><p>根据裴蜀定理，若有整数解，则$\gcd(m_1,m_2)|(b_2-b_1)$。反之则不存在整数解。</p><p>当其存在整数解时，假设已经利用扩欧求出一组特殊解$(k_1’,k_2’)$，其对应的$x=x_0$。令$d=\gcd(m_1,m_2)$。</p><p>则原式化为</p><script type="math/tex; mode=display">k_1\times \frac{m_1}{g}-k_2\times \frac{m_2}{g}=\frac{b_2-b_1}{g}</script><p>那么该不定方程通解为</p><script type="math/tex; mode=display">\begin{cases}k_1=\frac{m_2}{g}t+k_1' \\k_2=\frac{m_1}{g}t+k_2'\end{cases}</script><p>其中$t\in Z$。</p><p>往回代入$x$中，则</p><script type="math/tex; mode=display">\begin{align}x&= k_1\times m_1+b_1 \\&= x_0+\frac{m_1\times m_2}{g}t \\&= x_0+\operatorname{lcm}(m_1,m_2)\times t\end{align}</script><p>则最终解即为$x_0+\operatorname{lcm}(m_1,m_2)\times t\pmod{\operatorname{lcm}(m_1,m_2)}$</p><p>扩展到含有$n$个方程的同余方程组，便可以两个两个合并。</p><p>例如</p><script type="math/tex; mode=display">\begin{cases}x\equiv b_1\pmod{m_1} \\x\equiv b_2\pmod{m_2} \\x\equiv b_3\pmod{m_3} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>合并前两个</p><script type="math/tex; mode=display">\begin{cases}x\equiv x_0+\operatorname{lcm}(m_1,m_2)\times t \pmod{\operatorname{lcm}(m_1,m_2)} \\x\equiv b_3\pmod{m_3} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>合并目前的前两个</p><script type="math/tex; mode=display">\begin{cases}x\equiv x_0+\operatorname{lcm}(m_1,m_2,m_3)\times t\pmod{\operatorname{lcm}(m_1,m_2,m_3)} \\x\equiv b_4\pmod{m_4} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>……</p><p>这样逐一合并到只剩最后一个即可。</p><h3 id="例题-洛谷P4777-【模板】扩展中国剩余定理（EXCRT）"><a href="#例题-洛谷P4777-【模板】扩展中国剩余定理（EXCRT）" class="headerlink" title="例题 [洛谷P4777] 【模板】扩展中国剩余定理（EXCRT）"></a>例题 [洛谷P4777] 【模板】扩展中国剩余定理（EXCRT）</h3><p>给定$ n$组非负整数$ a_i, b_i$，求解关于$ x$的方程组的最小非负整数解。</p><script type="math/tex; mode=display">\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \\ x\equiv b_2\ ({\rm mod}\ a_2) \\ ... \\ x \equiv b_n\ ({\rm mod}\ a_n)\end{cases}</script><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100 \%$的数据，$1 \le n \le {10}^5$，$1 \le a_i \le {10}^{12}$，$0 \le b_i &lt; a_i$，保证所有$ a_i$ 的最小公倍数不超过$ {10}^{18}$。</p><p><strong>请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。</strong></p><p>数据保证有解。</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">P4777 【模板】扩展中国剩余定理（EXCRT）</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>乘法会溢出，所以龟速乘。</p><p>其余仿照上面操作即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y,mod) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y,mod) ((x%mod)+(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(a,b/<span class="number">2</span>,mod);</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(t,plus(t,a,mod),mod);</span><br><span class="line"><span class="keyword">return</span> plus(t,t,mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXCRT</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ans=a[<span class="number">1</span>];</span><br><span class="line">ll m=b[<span class="number">1</span>],x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(m,b[i],x,y),c=(plus(a[i],-ans,b[i])+b[i])%b[i];</span><br><span class="line">c/=gcd;</span><br><span class="line">x=gsc(x,c,b[i]);</span><br><span class="line">ans+=m*x;</span><br><span class="line">m*=b[i]/gcd;</span><br><span class="line">ans=(ans%m+m)%m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i]&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">EXCRT(a,b,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">[NOI2018]屠龙勇士</a></td><td><a href="https://www.luogu.com.cn/record/31749065" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>教练的讲义。</p><p><a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem#i-4" target="_blank" rel="noopener">扩展欧几里得算法与中国剩余定理</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1373] 小a与uim之大逃离</title>
      <link href="/is-zxy.github.io/2020/03/10/%5B%E6%B4%9B%E8%B0%B7P1373%5D-%E5%B0%8Fa%E4%B8%8Euim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/"/>
      <url>/is-zxy.github.io/2020/03/10/%5B%E6%B4%9B%E8%B0%B7P1373%5D-%E5%B0%8Fa%E4%B8%8Euim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>瞬间，地面上出现了一个$n\times m$的巨幅矩阵，矩阵的每个格子上有一坨$0\sim k$不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有$k$的容量，也就是说，如果装了$k+1$那么魔瓶会被清空成零，如果装了$k+2$就只剩下$1$，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！</p><p>现在他想知道他们都能活下来有多少种方法。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n,m&lt;=800,1&lt;=k&lt;=15$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1373" target="_blank" rel="noopener">P1373 小a和uim之大逃离</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>状态的设计十分重要。</p><p>定义$dp[i][j][l][f]$。</p><p>若$f=0$表示第$i$行第$j$列的魔液被小a吸取后小a与uim魔液差值为$l$的方案总数。</p><p>若$f=1$表示第$i$行第$j$列的魔液被uim吸取后小a与uim莫邪差值为$l$的方案总数。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j][l][0]=dp[i-1][j][l-a[i][j]][1]+dp[i][j-1][l-a[i][j]][1] \\dp[i][j][l][1]=dp[i-1][j][l+a[i][j]][0]+dp[i][j-1][l+a[i][j]][0]</script><p>由于可以从任意一个格子开始，初始化$dp[i][j][a[i][j]][0]=1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,a[N][N],dp[N][N][<span class="number">20</span>][<span class="number">2</span>],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">a[i][j]%=k;</span><br><span class="line">dp[i][j][a[i][j]][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;k;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][j][l][<span class="number">0</span>]=plus(dp[i<span class="number">-1</span>][j][(l-a[i][j]+k)%k][<span class="number">1</span>],dp[i][j][l][<span class="number">0</span>]);</span><br><span class="line">dp[i][j][l][<span class="number">1</span>]=plus(dp[i<span class="number">-1</span>][j][(l+a[i][j]+k)%k][<span class="number">0</span>],dp[i][j][l][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j<span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][j][l][<span class="number">0</span>]=plus(dp[i][j<span class="number">-1</span>][(l-a[i][j]+k)%k][<span class="number">1</span>],dp[i][j][l][<span class="number">0</span>]);</span><br><span class="line">dp[i][j][l][<span class="number">1</span>]=plus(dp[i][j<span class="number">-1</span>][(l+a[i][j]+k)%k][<span class="number">0</span>],dp[i][j][l][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=plus(ans,dp[i][j][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2008] 硬币购物</title>
      <link href="/is-zxy.github.io/2020/03/09/%5BHAOI2008%5D-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/"/>
      <url>/is-zxy.github.io/2020/03/09/%5BHAOI2008%5D-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>硬币购物一共有$4$种硬币。面值分别为$c_1,c_2,c_3,c_4$。某人去商店买东西，去了$tot$次。每次带$d_i$枚$c_i$硬币，买$s_i$的价值的东西。请问每次有多少种付款方法。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$d_i,s&lt;=100000$</p><p>$tot&lt;=1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1450" target="_blank" rel="noopener">[HAOI2008]硬币购物</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的思想太棒了。（好吧就是容斥原理）</p><p>若用多重背包，明显TLE飞了。</p><p>先当完全背包做，预处理出$100000$内面值的总方案数，$dp[i]+=dp[i-c[i]]$</p><p>考虑第$i$种硬币，其非法方案数，即超出额定的数量的方案数数量为$dp[s-(d[i]+1)*c[i]]$。</p><p>根据容斥原理，减去一种硬币的非法方案数，加上两种硬币的非法方案数，减去三种硬币的非法方案数，加上四种硬币的非法方案数即可得解。这个过程可以用一种类似状压的方式来实现。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">5</span>],tot,d[<span class="number">5</span>],bit[<span class="number">16</span>],lg[<span class="number">16</span>];</span><br><span class="line">ll dp[N],s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=c[i];j&lt;N;j++) dp[j]+=dp[j-c[i]];</span><br><span class="line">&#125;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tot;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(tot) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">ll ans=dp[s];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i,js=<span class="number">0</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">js++;</span><br><span class="line">sum+=(d[lg[lowbit(j)]+<span class="number">1</span>]+<span class="number">1</span>)*c[lg[lowbit(j)]+<span class="number">1</span>];</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;s) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(js&amp;<span class="number">1</span>) ans-=dp[s-sum];</span><br><span class="line"><span class="keyword">else</span> ans+=dp[s-sum];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">tot--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAOI </tag>
            
            <tag> 背包 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2016] 排列计数</title>
      <link href="/is-zxy.github.io/2020/03/09/%5BSDOI2016%5D-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/"/>
      <url>/is-zxy.github.io/2020/03/09/%5BSDOI2016%5D-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求有多少种长度为$ n $的序列$ A$，满足以下条件：</p><p>$1\sim n $这$ n $个数在序列中各出现了一次</p><p>若第$ i $个数$ A[i] $的值为$ i$，则称$ i $是稳定的。序列恰好有$ m $个数是稳定的</p><p>满足条件的序列可能很多，序列数对$ 10^9+7$取模。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$T\le 500000$</p><p>$n\le 1000000$</p><p>$m\le 1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4071" target="_blank" rel="noopener">[SDOI2016]排列计数</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意显然，$1\sim n$中有$n-m$个数错排，$m$个数不错排的总方案数。</p><p>显然，总方案数为$C_n^m\times D(n-m)$。</p><p>预处理出阶乘和错排数，卢卡斯瞎搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll f[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">d[<span class="number">0</span>]=<span class="number">1</span>,d[<span class="number">1</span>]=<span class="number">0</span>,d[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i++) &#123;</span><br><span class="line">f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line">d[i]=mul(i<span class="number">-1</span>,plus(d[i<span class="number">-1</span>],d[i<span class="number">-2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> mul(mul(f[n],quickp(f[m],p<span class="number">-2</span>)),quickp(f[n-m],p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mul(Laucs(n,m),d[n-m]));</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JLOI2014] 松鼠的新家</title>
      <link href="/is-zxy.github.io/2020/03/08/%5BJLOI2014%5D-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/"/>
      <url>/is-zxy.github.io/2020/03/08/%5BJLOI2014%5D-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。</p><p>松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，……，最后到$a_n$，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。</p><p>维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。</p><p>因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$2&lt;= n &lt;=300000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3258" target="_blank" rel="noopener">[JLOI2014]松鼠的新家</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>十分裸的树上差分。</p><p>需要注意重复经过的问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],head[N],lg[N],tot=<span class="number">0</span>,f[N][<span class="number">20</span>],depth[N],cnt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,v;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].v!=from) dfs(now,edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v!=f[now][<span class="number">0</span>]) &#123;</span><br><span class="line">get_ans(edge[i].v);</span><br><span class="line">cnt[now]+=cnt[edge[i].v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) cnt[a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l=LCA(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">cnt[a[i]]++,cnt[a[i+<span class="number">1</span>]]++,cnt[l]--;</span><br><span class="line"><span class="keyword">if</span>(f[l][<span class="number">0</span>]) cnt[f[l][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line">get_ans(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;cnt[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLOI </tag>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO15DEC] Max Flow P</title>
      <link href="/is-zxy.github.io/2020/03/07/%5BUSACO15DEC%5D-Max-Flow-P/"/>
      <url>/is-zxy.github.io/2020/03/07/%5BUSACO15DEC%5D-Max-Flow-P/</url>
      
        <content type="html"><![CDATA[<p>FJ给他的牛棚的$N(2≤N≤50,000)$个隔间之间安装了$N-1$根管道，隔间编号从$1$到$N$。所有隔间都被管道连通了。</p><p>FJ有$K(1≤K≤100,000)$条运输牛奶的路线，第i条路线从隔间$s_i$运输到隔间$t_i$。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3128" target="_blank" rel="noopener">[USACO15DEC]Max Flow P</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是求访问次数最多的点。</p><p>而涉及区间修改，一个点一个点修改显然超时。</p><p>于是考虑差分，原序列即为差分的前缀和。</p><p>对于一条路径$s_i$到$t_i$，这是条链。具体过程即为$s_i-&gt;LCA(s_i,t_i)-&gt;t_i$。</p><p>用$cnt$来差分。对于每个路线，$cnt[s_i]++,cnt[t_i]++，cnt[LCA(s_i,t_i)]—,cnt[f[LCA(s_i,t_i)]]—$，该结论可将路径分为两部分来看而得出。</p><p>最后用一种类似树形DP的方法，由叶到根，搞出最大的访问次数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,head[N],depth[N],f[N][<span class="number">20</span>],lg[N],tot=<span class="number">0</span>,d[N],cnt[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=f[now][<span class="number">0</span>]) &#123;</span><br><span class="line">get_ans(edge[i].to);</span><br><span class="line">cnt[now]+=cnt[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,cnt[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">int</span> l=LCA(x,y);</span><br><span class="line">cnt[x]++,cnt[y]++,cnt[l]--;</span><br><span class="line"><span class="keyword">if</span>(f[l][<span class="number">0</span>]) cnt[f[l][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line">get_ans(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO19DEC] Milk Visits S</title>
      <link href="/is-zxy.github.io/2020/03/06/%5BUSACO19DEC%5D-Milk-Visits-S/"/>
      <url>/is-zxy.github.io/2020/03/06/%5BUSACO19DEC%5D-Milk-Visits-S/</url>
      
        <content type="html"><![CDATA[<p>Farmer John 计划建造$ N$个农场，用$ N-1$条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。</p><p>Farmer John 的$ M$个朋友经常前来拜访他。在朋友$ i$拜访之时，Farmer John 会与他的朋友沿着从农场$ A_i$到农场$ B_i$之间的唯一路径行走（可能有$ A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。</p><p>请求出每个朋友在拜访过后是否会高兴。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100\%$的数据，$1 \leq N \leq 10^5$，$1 \leq M \leq 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5836" target="_blank" rel="noopener">[USACO19DEC]Milk Visits S</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不妨令根为$1$。</p><p>定义$g[x],h[x]$分别表示从$1$到$x$路径上$G$牛和$H$牛的个数。</p><p>易得点$u$到点$v$路径上$G$牛的总数为</p><script type="math/tex; mode=display">g[u]+g[v]-g[LCA(u,v)]-g[f[0][LCA(u,v)]]</script><p>其中$f[x][y]$表示$y$的第$2^{x-1}$个祖先。</p><p>$H$牛个数同理。</p><p>判断路径上是否有询问的牛类型即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,head[MAXN],tot=<span class="number">0</span>,g[MAXN],h[MAXN],f[N][MAXN],lg[MAXN],depth[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,v;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">string</span> s,ans=(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">depth[to]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][to]=from;</span><br><span class="line">g[to]=g[from],h[to]=h[from];</span><br><span class="line"><span class="keyword">if</span>(s[to<span class="number">-1</span>]==<span class="string">'H'</span>) h[to]++;</span><br><span class="line"><span class="keyword">else</span> g[to]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[to]];i++) f[i][to]=f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][to]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[to];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].v!=from) dfs(to,edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[lg[depth[x]-depth[y]]][x];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][x]!=f[i][y]) &#123;</span><br><span class="line">x=f[i][x];</span><br><span class="line">y=f[i][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">char</span> ins;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;ins;</span><br><span class="line"><span class="keyword">int</span> L=LCA(u,v);</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">'H'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(h[u]+h[v]-h[L]-h[f[<span class="number">0</span>][L]]) ans+=<span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">'G'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[u]+g[v]-g[L]-g[f[<span class="number">0</span>][L]]) ans+=<span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂句整理</title>
      <link href="/is-zxy.github.io/2020/03/06/%E6%9D%82%E5%8F%A5%E6%95%B4%E7%90%86/"/>
      <url>/is-zxy.github.io/2020/03/06/%E6%9D%82%E5%8F%A5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>看番和看书时记下的一些东西<del>感觉莫名有些沙雕呢</del></p><a id="more"></a><hr><h3 id="《挪威的森林》-【日】村上春树"><a href="#《挪威的森林》-【日】村上春树" class="headerlink" title="《挪威的森林》 【日】村上春树"></a>《挪威的森林》 【日】村上春树</h3><ol><li><p>死并非生的对立面，而作为生的一部分永存。</p></li><li><p>我在切身感受那一团薄雾样的东西的朝朝暮暮送走了十八岁的春天，同时努力使自己避免陷入深刻。我隐约感觉到，深刻未必是接近真实的同义词。但无论我怎样认为，死都是深刻的事实。在这令人窒息般的背反性当中，我重复着这种永无休止的圆周式思考。如今想来，那真是奇特的日日夜夜，在活得好端端的青春时代，居然凡事都以死为轴心旋转不休。</p></li><li><p>哪里会有人喜欢孤独，不过是不喜欢失望。</p></li><li><p>“不要同情自己！”他说，“同情自己是卑劣懦夫干的勾当。”<br>“我一定牢记。”我说。然后我们握手告别，他奔往新的天地，我则退回自己的泥沼。</p></li><li><p>无论熟知怎样的哲理，也无以消除所爱之人的死带来的悲哀。无论怎样的哲理，怎样的真诚，怎样的柔情，也无法排遣这种悲哀。我们唯一能做到的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理，在继之而来的意外悲哀面前，又是那样的软弱无力——我形影相吊地倾听这暗夜的涛声和凤鸣，日复一日地如此冥思苦索。</p></li><li><p>木月照旧十七，直子依然二十一，永远地。</p></li><li><p>“我已成为过去的人。你眼前存在的不过是我往日的记忆碎片。我心目中最宝贵的东西早在很久以前就已寿终正寝。我不过是按照过去的记忆坐卧行止罢了。”</p></li><li><p>死并非生的对立面，死潜伏在我们的生之中。</p></li><li><p>人生不需要理想，需要的是行为规范。</p></li></ol><hr><h3 id="《活着》-余华"><a href="#《活着》-余华" class="headerlink" title="《活着》 余华"></a>《活着》 余华</h3><ol><li><p>这辈子想起来也是很快就过来了，过得平平常常，我爹指望我光耀祖宗，他算是看错人了，我啊，就是这样的命。年轻时靠着祖上留下的钱风光了一阵子，往后就越过越落魄了，这样反倒好，看看我身边的人，龙儿和春生，他们也只是风光了一阵子，到头来命都丢了。做人还是平常些好，争这个争那个，争来争去赔了自己的命。像我这样，说起来是越混越没出息，可寿命长，我认识的人一个挨着一个死去，我还活着。</p></li><li><p>我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤着他们的子女，土地召唤着黑暗降临。</p></li><li><p>人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。</p></li></ol><hr><h3 id="《百年孤独》-【哥伦比亚】加西亚·马尔克斯"><a href="#《百年孤独》-【哥伦比亚】加西亚·马尔克斯" class="headerlink" title="《百年孤独》 【哥伦比亚】加西亚·马尔克斯"></a>《百年孤独》 【哥伦比亚】加西亚·马尔克斯</h3><ol><li><p>一天夜里，他相信已破译出一则有关马孔多未来的预言。它会变成一座光明的城市，矗立着玻璃建造的高楼大厦，却没有布恩迪亚家的丝毫血脉存留。</p></li><li><p>走向墓地的路上，细雨绵绵不断，阿尔卡蒂奥望见星期三的曙光闪现在地平线上。留恋之情随着晨雾散去，取而代之的是强烈的好奇感。</p></li><li><p>尼卡诺尔神甫在病榻上不禁感慨：“这实在荒唐，基督信仰的卫士摧毁教堂，共济会的人却下令重建。”</p></li><li><p>沉默寡言的奥雷里亚诺·布恩迪亚上校对家中重新焕发的活力视若无睹，约略懂得幸福晚年的秘诀不过是与孤独签下不失尊严的协定罢了。</p></li><li><p>无论何时，或睡或醒，从最庄严到最卑下的时刻，她都会想起贝丽卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永久存留。</p></li><li><p>她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。</p></li><li><p>这列无辜的黄色火车注定要为马孔多带来无数疑窦与明证，无数甜蜜与不幸，无数变化、灾难与怀念。</p></li><li><p>一个人不是在该死的时候死，而是在能死的时候死。</p></li><li><p>同一血脉的两个孤独者之间的接近与友谊无涉，却有助于他们承受将两人分离又联合的神秘孤独。</p></li><li><p>过去都是假的，回忆没有归路，春天总是一去不返，最疯狂执著的爱情也终究是过眼云烟。</p></li><li><p>这是往昔的最后遗存，这往昔日渐衰落却不会彻底消亡，因为它是在自身之中无休无止地败落下去，每过一刻便向彻底灭亡更近一步，却永远无法抵达最后的终结。</p></li><li><p>他看到羊皮卷卷首的提要在尘世时空中完美显现：家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉。</p></li><li><p>他再次跳读去寻索自己死亡的日期和情形，但没等看到最后一行便已明白自己不会再走出这房间，因为可以预料这座镜子之城——或蜃景之城——将在奥雷里亚诺·巴比伦全部译出羊皮卷之时被飓风抹去，从世人记忆中根除，羊皮卷上所记载的一切自永远至永远不会再重复，因为注定经受百年孤独的家族不会有第二次机会在大地上出现。</p></li></ol><hr><h3 id="《人间失格》-【日】太宰治"><a href="#《人间失格》-【日】太宰治" class="headerlink" title="《人间失格》 【日】太宰治"></a>《人间失格》 【日】太宰治</h3><ol><li><p>平常他们说不定都隐藏着这种本性，可一有机会，他们就像温顺地卧在地上歇息的牛，会突然甩动尾巴拍死肚皮上的牛虻一样，在暴怒中暴露出人可怕的本性。</p></li><li><p>对讨厌的事不能说讨厌，对喜欢的事情也像行窃一样战战兢兢，从而在极度苦涩的滋味和难以言表的痛苦中苦闷得不能自拔。</p></li><li><p>归根结底，诉诸他人终究都是徒劳。</p></li><li><p>在我迄今为止的人生中，曾好多次希望被别人杀死，却从未想过要杀死别人。因为我觉得，这反而会给可怕的对手带去幸福。</p></li><li><p>胆小鬼连幸福都害怕，碰到棉花都会受伤，有时也会被幸福伤害。</p></li><li><p>所谓的世人，究竟指的是什么？是人的复数吗？哪里存在着世人的实体呢？不过，我一直把它视为坚强、严厉和可怕的东西，如今听崛木这么一说，我差点脱口而出：“所谓的世人，不就是你吗？”</p></li><li><p>对于现在的我，既没有幸福，也没有不幸。<br>只是，一切都将消逝。</p></li></ol><hr><h3 id="《末日时在做什么？有没有空？可以来拯救吗？》"><a href="#《末日时在做什么？有没有空？可以来拯救吗？》" class="headerlink" title="《末日时在做什么？有没有空？可以来拯救吗？》"></a>《末日时在做什么？有没有空？可以来拯救吗？》</h3><ol><li><p>我曾经发誓要永远和他在一起，能如此发誓，让我无比幸福。我曾经认为自己喜欢的这个人，能有如此感受，让我无比幸福。他曾经对我说：“我一定会让你幸福。”，能听到他那样说，让我无比幸福。那个人，分了这么多的幸福给我，所以，我敢肯定，现在的我，不管别人怎么说，都一定是世界上最幸福的女孩。</p></li><li><p>对不起，你们当中……有超过一半人我已经记不得了。忘掉的名字还能重新再记，但是，失去的回忆，已经不可能再回来了。</p></li><li><p>抱歉，我已经绝对不可能再获得幸福了。因为我发现，其实我早就被幸福包围了。</p></li><li><p>珂：<font color=CornflowerBlue>我曾经发誓要永远和他在一起，能够如此发誓，让我无比幸福。</font><br>威：<font color=Crimson>我曾经发誓要永远和她在一起，能够如此发誓，让我心获安详。</font><br>珂：<font color=CornflowerBlue>我曾经以为自己喜欢这个人</font><br>威：<font color=Crimson>我曾经觉得自己非常珍视她</font><br>珂：<font color=CornflowerBlue>能有如此感受，让我无比幸福。</font><br>威：<font color=Crimson>能有如此感受，让我无比喜悦。</font><br>珂：<font color=CornflowerBlue>他曾经对我说：我一定会让你幸福</font><br>威：<font color=Crimson>我曾经对她说：我一定会让你幸福</font><br>珂：<font color=CornflowerBlue>能听到他那样说，让我无比幸福。</font><br>威：<font color=Crimson>能够对她那么说，让我心获满足。</font><br>珂：<font color=CornflowerBlue>那个人，分了这么多的幸福给我</font><br>威：<font color=Crimson>我从她那，得到了这么多的东西，可是我却……</font><br>珂：<font color=CornflowerBlue>所以，我敢肯定……现在的我……不管别人怎么说，都一定是世界上最幸福的女孩。</font></p></li></ol><hr><h3 id="《解忧杂货店》-【日】东野圭吾"><a href="#《解忧杂货店》-【日】东野圭吾" class="headerlink" title="《解忧杂货店》 【日】东野圭吾"></a>《解忧杂货店》 【日】东野圭吾</h3><ol><li><p>有一天，我对他说：<br>“我比任何人都爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘记过你，但请让我去追逐梦想吧。”<br>听完这番话，病床上的他流下泪来。他对我说：<br>“我早就在等你这句话了。看到你为了我而烦恼，我很难过。让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。”</p></li><li><p>你对音乐的执著追求，绝不是白白付出。<br>我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。<br>若要问我为何能如此断言，我也很难回答，但这的确是事实。<br>请你始终坚信这一点，坚信到生命最后一刻。</p></li><li><p>人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。</p></li></ol><hr><h3 id="《一九八四》-【英】乔治·奥威尔"><a href="#《一九八四》-【英】乔治·奥威尔" class="headerlink" title="《一九八四》 【英】乔治·奥威尔"></a>《一九八四》 【英】乔治·奥威尔</h3><ol><li><p>从温斯顿所站的地方望去，刚好能看见党的三条标语，用考究的字体镌刻在真理部白色大楼的正面：</p><blockquote><p>战争即和平<br>自由即奴役<br>无知即力量</p></blockquote></li><li><p>温斯顿垂下手臂，缓缓吸了口气，他的大脑滑向了双重思想迷宫般的世界。知与不知；明知事实的全部真相却说着精心编造的谎言；同时持有两种相抵触的观点，明知它们相互矛盾却两者皆信；用逻辑来推翻逻辑；否定道德却又拥护道德；不相信民主却相信党是民主的捍卫者；忘掉一切必须忘掉的，在需要时重回记忆，然后再次迅速忘掉。尤其是，对方法本身也要如法炮制，这简直太玄妙：有意识地进入无意识，然后就意识不到刚才对自己实施的催眠行为。甚至理解“双重思想”这个词，也得用到双重思想。</p></li><li><p>除非他们觉醒，否则永不反抗；除非他们反抗，否则永不觉醒。</p></li><li><p>一切都隐没在迷雾之中。过去已被清除，而清除这一行为又被遗忘，谎言变成了真相。</p></li><li><p>他怀疑自己是否成了疯子，正如之前很多次怀疑过自己那样。也许疯子不过是少数派。从前，相信地球绕着太阳转的曾被认为是疯子；今天，相信过去不可更改的也是疯子。或许他是唯一特有这种想法的人，果真就他一人，那他便是疯子。不过，想到自己是个疯子并没有多可怕，真正可怕的是他自己也可能是错的。</p></li><li><p>常识成了异端中的异端，但可怕的并不是你特有异见他们便要杀你，可怕的是他们有可能是对的。</p></li><li><p>但是，他没错！他们错了，他是对的。必须要捍卫那些明了的，朴素的，真实的一切。不言自明就是真理，这一点必须坚持！世界是客观存在的，其规律不会改变。石头是硬的，水是湿的，悬空的物体会坠向地心。他觉得自己是在和奥布赖恩说话，同时也在阐述一个重要的原理，他写道：</p><blockquote><p>所谓自由，就是可以说二加二等于四的自由。若此成立，其余同理。</p></blockquote></li><li><p>奥吉尔维同志一小时前还不存在，现在已成事实。你可以造出死人，却造不出活人，这让温斯顿觉得好奇。在现实中从未存在过的奥吉尔维同志，如今却存在于过去。一切伪造行为被遗忘，他就会像查理曼大帝和凯撒大帝一样，真实地载入史册，而且有同样的证据可以证明。</p></li><li><p>“如果有希望，”他曾在日记中写到，“希望就在无产者身上。”他时常会想起这句话，陈述的是神秘的真理，却又荒谬无比。</p></li><li><p>如果有希望，希望就在无产者身上。你必须坚信这一点。当你写下这句话时，觉得它合乎情理；当你看着人行道上与你擦肩而过的众人时，它就成了一种信仰。</p></li><li><p>他的身心被一种难以忍受的敏感脆弱所折磨，每一个举动，每一种声音，每一回接触，每一个不得不说或不得不听的字眼，都无法掩饰，让他痛苦万分。</p></li><li><p>过一天算一天，过一周算一周，在看不到未来的现在苟且偷生，这似乎是人难以遏制的本能，就好像只要有空气存在，人的肺部总要继续呼吸一样。</p></li><li><p>党所做的最可怕之事，是让你相信仅靠冲动或感情解决不了任何问题，而与此同时又剥夺你对现实世界的控制力。一旦你落入党的掌控，无论你有意识或是无意识，你做一件事情或阻止一件事，其实已无关紧要。不管发生什么，你终究要消失。你和你的行为从此无人提及，历史的洪流将你清除得一干二净。然而对两代以前的人而言，这似乎并不那么重要，因为他们无意篡改历史，他们遵从的是人与人之间不容置疑的忠诚。他们在乎的是人与人之间的关系，一个完全徒劳的姿势，一个拥抱，一滴眼泪，向垂死之人所说的一句话，都有其自身的价值。</p></li><li><p>他突然想到，无产者，现在仍是如此。他们不会忠诚于任何一个政党，一个国家或一种思想，他们互相忠诚。生平第一次，他不再轻视无产者，或者只是把他们看作一种早晚有一天会爆发、会令全世界重生的蛰伏的力量。无产者仍有人性，他们尚未麻木不仁，他们仍保留着人类最原始的情感，而他自己需要付出有意识的努力才能重新学会。</p></li><li><p>“我并非指招供，招供不是背叛。你说什么或做什么都不重要，重要的唯有感情。如果他们能逼迫我停止爱你——那才是真正的背叛。”</p></li><li><p>不管怎样，事实是无法隐瞒的。他们会用讯问或拷打的方法，从你嘴里撬出来，但如果你的目标不是活命而是保全人性，那最终又有什么区别呢？他们无法改变你的感情，即使你自己想改，也难以更改。他们能详尽无遗地揭露你的所作所为，所思所想，但你的内心仍是坚不可摧的，它的活动甚至连你自己都觉得神秘莫测。</p></li><li><p>任何看得见的变化在我们的有生之年都不可能发生。我们已死，我们真正的生命只存在于未来。我们将以几抔黄土、几根枯骨去参加未来的生活。但未来究竟有多远，无人知晓，也许有千年之遥。</p></li></ol><hr><h3 id="《霍乱时期的爱情》-【哥伦比亚】加西亚·马尔克斯"><a href="#《霍乱时期的爱情》-【哥伦比亚】加西亚·马尔克斯" class="headerlink" title="《霍乱时期的爱情》 【哥伦比亚】加西亚·马尔克斯"></a>《霍乱时期的爱情》 【哥伦比亚】加西亚·马尔克斯</h3><ol><li><p>“请用一枝玫瑰纪念我。”</p></li><li><p>只有没有原则的人，才会从痛苦中得到满足。</p></li><li><p>他在空中悬留了片刻，意识到自己来不及领受圣体，来不及为任何事忏悔，来不及向任何人告别就要死掉了，死在圣神降临节的星期日下午四点零七分。</p></li><li><p>正是这偶然的一瞥，成为这场半世纪后仍未结束的惊天动地的爱情的源头。</p></li><li><p>好奇心也是爱情的种种伪装之一。</p></li><li><p>回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。</p></li><li><p>他对着车上的镜子看了好一会儿，发现镜中的自己也依然在想着费尔明娜·达萨。</p></li><li><p>爱情是一种本能，要么生下来就会，要么永远都不会。</p></li><li><p>灵魂之爱在腰部以上，肉体之爱在腰部以下。</p></li><li><p>婚姻的问题在于，它终结于每晚做爱之后，却在第二天早餐之前又必须重新建立起来。</p></li><li><p>死亡让我感到的唯一痛苦，便是不能为爱而死。</p></li><li><p>暮年的岁月不是奔涌向前的激流，而是一个无底的地下水池，记忆从这里慢慢流走。</p></li><li><p>对于一对恩爱夫妻，最重要的不是幸福，而是稳定。</p></li><li><p>老年常常是在一次无关紧要的摔倒之后开始的，而死神则跟随着第二次跌倒到来。</p></li><li><p>“一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了。”</p></li><li><p>灾难中的爱情更加伟大而高尚。</p></li><li><p>无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。</p></li><li><p>船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟使他吓了一跳，原来是生命，而非死亡，才是没有止境的。<br>“见鬼，那您认为我们这样来来回回的究竟走到什么时候？”他问。<br>在五十三年七个月零十一天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。<br>“一生一世。”他说。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[CF1320B] Navigation System</title>
      <link href="/is-zxy.github.io/2020/03/05/%5BCF1320B%5D-Navigation-System/"/>
      <url>/is-zxy.github.io/2020/03/05/%5BCF1320B%5D-Navigation-System/</url>
      
        <content type="html"><![CDATA[<p>给出$ 2\le n\le2\cdot 10^5$个节点，$2\le m\le2\cdot 10^5$条边的有向图，路径$ p_1,\cdots,p_k$，路径中没有重复元素，边$ (p_i,p_{i+1})$总是存在。</p><p>定义$ s=p_1,t=p_k,p_i\le n$</p><p>有一个导航系统，若当前在节点$ u$，会构造一条从$ u$到$ t$的最短路径（这种路径可能不止一条，但导航系统只会选其中一条），设导航系统规划的下一个节点为$ w$，实际行走的下一个节点为$ v$ 。</p><ul><li>$w=v$不会触发重构。</li><li>$w\neq v$会触发重构。</li></ul><p>实际行走路线为$ p$，求可能的最少重构次数和最多重构次数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF1320B" target="_blank" rel="noopener">CF1320B Navigation System</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建立反向图，由于边权为1，所以bfs出每个点到$p_k$的距离$dis$。</p><p>对于一个点$p_i$，如果$dis[p_i]-1=dis[p_{i+1}]$，则说明$p_{i+1}$在$p_i$到终点的最短路上，然后看以$p_i$为起始点的边，其边终点$k(k≠p_{i+!})$，是否$dis[k]=dis[p_i]-1$，若等于，则说明可以重构，maxans++。</p><p>若$dis[p_i]-1≠dis[p_{i+1}]$，则maxans++,minans++。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N],Reg[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,p[N],q[N],dis[N],minans=<span class="number">0</span>,maxans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">q[head]=x,dis[x]=<span class="number">0</span>,vh[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail) &#123;</span><br><span class="line"><span class="keyword">int</span> s=Reg[q[head]].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[Reg[q[head]][i]]) &#123;</span><br><span class="line">vh[Reg[q[head]][i]]=<span class="number">1</span>;</span><br><span class="line">dis[Reg[q[head]][i]]=dis[q[head]]+<span class="number">1</span>;</span><br><span class="line">q[++tail]=Reg[q[head]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">Reg[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">bfs(p[k]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> s=g[p[i]].size();</span><br><span class="line"><span class="keyword">if</span>(dis[p[i+<span class="number">1</span>]]==dis[p[i]]<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[p[i]][j]==p[i+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[g[p[i]][j]]==dis[p[i]]<span class="number">-1</span>) &#123;</span><br><span class="line">maxans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> maxans++,minans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minans&lt;&lt;<span class="string">" "</span>&lt;&lt;maxans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF1320A] Journey Planning</title>
      <link href="/is-zxy.github.io/2020/03/05/%5BCF1320A%5D-Journey-Planning/"/>
      <url>/is-zxy.github.io/2020/03/05/%5BCF1320A%5D-Journey-Planning/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的序列$ b$。</p><p>设$ b$的一个子序列$ c$的长度为$ m$，它的第$ i$个元素在原序列的下标为$ c_i$，要求对于任意$ 1\leq i&lt;m$，$c_{i+1}-c_i=b_{c_{i+1}}-b_{c_i}$。</p><p>此时这个子序列的贡献为$ \sum_{i=1}^m{b_{c_i}}$。</p><p>求出所有合法的子序列的贡献中最大的贡献。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ ( 1 \le n \le 2 \cdot 10^5)$</p><p>$( 1 \le b_i \le 4 \cdot 10^5)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF1320A" target="_blank" rel="noopener">CF1320A Journey Planning</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>。</p><p>考场上傻了，写了个暴力TLE算法。</p><p>将式子移项，得$b_{c_i+1}-c_{i+1}=b_{c_i}-c_i$。</p><p>于是建立map，将$b_i-i$值相等的$b_i$值存起来取最大的即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,ll&gt; js;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll b[N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">js[b[i]-i]+=b[i];</span><br><span class="line">ans=max(ans,js[b[i]-i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2012]Longge的问题</title>
      <link href="/is-zxy.github.io/2020/03/03/%5BSDOI2012%5D-Longge%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/is-zxy.github.io/2020/03/03/%5BSDOI2012%5D-Longge%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Longge 的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。现在问题来了：给定一个整数$N$，你需要求出$\sum\limits_{i=1}^N \gcd(i, N)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 60\%$的数据，$1\leq N\leq 2^{16}$。</p><p>对于$100\%$的数据，$1\leq N\leq 2^{32}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2303" target="_blank" rel="noopener">[SDOI2012]Longge的问题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^N\gcd(i,N)</script><p>即求</p><script type="math/tex; mode=display">\begin{align}\sum_{d|n}d\sum_{i=1}^N[\gcd(i,N)==d]&= \sum_{d|n}d\sum_{i=1}^{\frac{N}{d}}[\gcd(i,\frac{N}{d})=1] \\&= \sum_{d|n}d\varphi(\frac{N}{d})\end{align}</script><p>但是观察本题$N$范围，开不了数组，于是不能用线性筛求欧拉函数。</p><p>所以要用到欧拉函数的性质，即</p><script type="math/tex; mode=display">\varphi(n)=n\prod_{i=1}^m(1-\frac{1}{p_i}),n=\prod_{i=1}^mp_i^{c_i}</script><p>其中$p$为质数。</p><p>于是可以$O(\sqrt{N})$求出$n$的所有约数，$O(\sqrt{N})$求$\varphi$，约数个数约为$logN$个，时间复杂度$O(\sqrt{N}\cdot logN)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N (1&lt;&lt;31)+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=x,s=<span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!(x%i)) x/=i;</span><br><span class="line">ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>) ans=ans/x*(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">ll sn=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=sn;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(n%i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i*i==n) ans+=phi(i)*i;</span><br><span class="line"><span class="keyword">else</span> ans+=phi(i)*(n/i)+phi(n/i)*i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整除分块学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/02/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/02/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>貌似是莫比乌斯反演的前置知识，那么先学一下好了。</p><a id="more"></a><h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><p>看这个式子</p><script type="math/tex; mode=display">\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor</script><p>显然可以$O(n)$求解。</p><p>那么是否有更高效的方法呢？</p><p>有的——整除分块，$O(\sqrt{n})$。</p><p>显然，对于$i\in [i,n]$，有很多$\lfloor \frac{n}{i} \rfloor$的值是相等的，且呈块状分布。</p><p>显然，相等的值的个数最多为$2\sqrt{n}$个。</p><p>一个重要的结论：若$\forall i\in[l,r]$，$\lfloor \frac{n}{i} \rfloor$都相等，那么$r=\left\lfloor\frac{n}{\lfloor\frac{n}{l}\rfloor}\right\rfloor$。</p><p>简单证明一下：</p><p>令$\lfloor \frac{n}{l} \rfloor=k$</p><p>因为</p><script type="math/tex; mode=display">\lfloor \frac{n}{k} \rfloor \le \frac{n}{k}</script><p>所以</p><script type="math/tex; mode=display">\frac{n}{\lfloor \frac{n}{k}\rfloor} \ge \frac{n}{\frac{n}{k}}=k</script><p>即</p><script type="math/tex; mode=display">\begin{align}\frac{n}{\lfloor \frac{n}{k}\rfloor} &\ge k \\\left\lfloor\frac{n}{\lfloor\frac{n}{k}\rfloor}\right\rfloor &\ge k\end{align}</script><p>根据单调性，易得$\left\lfloor\frac{n}{\lfloor\frac{n}{k}\rfloor}\right\rfloor=k$，此则说明$r$取$\lfloor \frac{n}{k} \rfloor $是满足条件的，此时$[l,r]$内其值都为$k$。</p><p>那么现在还需证明的就是$r$取$\lfloor \frac{n}{k} \rfloor +1$是不满足条件的，即$\left\lfloor \frac{n}{\lfloor \frac{n}{k}\rfloor +1}\right\rfloor &lt;k$。</p><script type="math/tex; mode=display">\left\lfloor \frac{n}{\lfloor \frac{n}{k}\rfloor +1}\right\rfloor<k⟺\frac{n}{\lfloor \frac{n}{k}\rfloor +1}<k⟺\lfloor \frac{n}{k}\rfloor\times k+k>n</script><p>设$n=q\times k+r\ (0\le r&lt; k)$。</p><p>则$\lfloor \frac{n}{k} \rfloor\times k +k=\lfloor q+\frac{r}{k}\rfloor \times k+k=q\times k+r+k&gt;n$</p><p>证毕。</p><p>于是便可用两个指针$l,r$来进行求和，每次求$r$，移动$l$即可。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007]余数求和"></a>[CQOI2007]余数求和</h2><p>给出正整数$n$和$k$计算$ G(n, k)=k\ \bmod\ 1 + k\ \bmod\ 2 + k\ \bmod\ 3 + \cdots + k\ \bmod\ n$的值。其中$ k\ \bmod\ i$表示$k$除以$i$的余数。</p><p>例如$ G(10, 5)=5\ \bmod\ 1 + 5\ \bmod\ 2 + 5\ \bmod\ 3 + 5\ \bmod\ 4 + 5\ \bmod\ 5 \cdots + 5\ \bmod\ 10=29$ 。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$30\%:n,k≤1000$</p><p>$60\%: n , k \le 10^6$</p><p>$100\%: n , k \le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2261" target="_blank" rel="noopener">[CQOI2007]余数求和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>即求</p><script type="math/tex; mode=display">\sum_{i=1}^n(k\bmod i)</script><p>化简</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n(k\bmod i) &=\sum_{i=1}^n(k-i\times\lfloor \frac{k}{i}\rfloor) \\&= n\times k-\sum_{i=1}^n i\times\lfloor \frac{k}{i}\rfloor\end{align}</script><p>后式可整除分块求出，前式可直接求出。于是便可$O(\sqrt{n})$求解。</p><p>本题有几个注意点，当$n&gt;k$时会出现$\lfloor \frac{k}{i} \rfloor=0$的情况，这样便出现了$\frac{k}{0}$，所以$n$应取$n,k$中的较小值，这样是没有影响的。</p><p>$\left\lfloor\frac{k}{\lfloor\frac{k}{l}\rfloor}\right\rfloor$也有可能大于$n$，也要判断一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">sum=n*k;</span><br><span class="line">n=min(n,k);</span><br><span class="line"><span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">r=min(k/(k/l),n);</span><br><span class="line">sum-=(k/l)*(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整除分块可快速处理形如$\sum_{i=1}^nf(\lfloor \frac{n}{i} \rfloor)$的式子。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/jszjinshengzhi/luogu-p2261cqoi2007-yu-shu-qiu-hu" target="_blank" rel="noopener">jszjinshengzhi的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 整除分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF813D] Two Melodies</title>
      <link href="/is-zxy.github.io/2020/03/02/%5BCF813D%5D-Two-Melodies/"/>
      <url>/is-zxy.github.io/2020/03/02/%5BCF813D%5D-Two-Melodies/</url>
      
        <content type="html"><![CDATA[<p>给定一个$n$，以及$n$个数$ a_1,a_2,a_3,\cdots,a_n$，定义一个$Melody$子序列(和”最长上升子序列”中的”子序列”定义一样，是指在原序列中相对顺序不变但是不一定连续的一段子序列)如下:</p><p>对于任意相邻的两个元素，一定满足这两个元素差为$1$或者两个元素除$7$同余。</p><p>请在原序列中找出两个无重复部分的$Melody$子序列并且选出的两个长度加起来最大。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$( 2&lt;=n&lt;=5000)$</p><p>$( 1&lt;=a_{i}&lt;=10^{5})$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF813D" target="_blank" rel="noopener">CF813D Two Melodies</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道很好的DP。</p><p>定义$dp[i][j]$表示一个子序列以$a_i$结尾，一个子序列以$a_j$结尾，两个子序列的最大长度和。</p><p>由于是对称的，所以不妨设$i&lt;j$。</p><p>于是易得</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i][0],dp[i][k])+1,j\in(i,n],k\in[1,j)</script><p>其中$a[k]$是与$a[j]$相差为$1$或同余于$7$的数。</p><p>于是易得一个$O(n^3)$的TLE算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N][N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxn=dp[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(a[k]-a[j])==<span class="number">1</span>||a[k]%<span class="number">7</span>==a[j]%<span class="number">7</span>) maxn=max(maxn,dp[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j]=maxn+<span class="number">1</span>;</span><br><span class="line">dp[j][i]=dp[i][j];</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，可以用两个桶记录，$mod[k]$表示模$7$得$k$的最大$dp$值，$num[l]$表示$a[k]=l,k\in[1,j)$的最大$dp$值。于是状转方程变为</p><script type="math/tex; mode=display">dp[i][j]=\max(dp[i][0],num[j-1],num[j+1],mod[j\%7])+1</script><p>每次求出一个$dp$值都更新$mod$与$num$，转移时直接拿来用，时间复杂度$O(n^2)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N][N],ans=<span class="number">0</span>,num[MAXN],mod[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                                          </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="built_in">memset</span>(mod,<span class="number">0</span>,<span class="keyword">sizeof</span>(mod));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">num[a[j]]=max(num[a[j]],dp[i][j]);</span><br><span class="line">mod[a[j]%<span class="number">7</span>]=max(mod[a[j]%<span class="number">7</span>],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">dp[i][j]=max(dp[i][<span class="number">0</span>],max(num[a[j]<span class="number">-1</span>],max(num[a[j]+<span class="number">1</span>],mod[a[j]%<span class="number">7</span>])))+<span class="number">1</span>;</span><br><span class="line">dp[j][i]=dp[i][j];</span><br><span class="line">num[a[j]]=max(num[a[j]],dp[i][j]);</span><br><span class="line">mod[a[j]%<span class="number">7</span>]=max(mod[a[j]%<span class="number">7</span>],dp[i][j]);</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P6160] [Cnoi2020]向量</title>
      <link href="/is-zxy.github.io/2020/03/01/%5B%E6%B4%9B%E8%B0%B7P6160%5D-%5BCnoi2020%5D-%E5%90%91%E9%87%8F/"/>
      <url>/is-zxy.github.io/2020/03/01/%5B%E6%B4%9B%E8%B0%B7P6160%5D-%5BCnoi2020%5D-%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>以氷屋为原点，三月精的位置分别记作向量$\vec{a}$, $\vec{b}$, $\vec{c}$。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j3u0l3no.png" alt="img"></p><p>由定义可知，$|\vec{a}|=r_1$, $|\vec{b}|=r_2$, $|\vec{c}|=r_3$。</p><p>现在 Cirno 分配给你的任务是计算其 <strong>破坏极限指数</strong> $\sigma$。</p><p>$\sigma=\min\{\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{c}\cdot\vec{a}\}$</p><p>其中「$\cdot$」表示 <strong>向量内积</strong>。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul><li>Subtask1($ 20\%$) : $r_1=r_2=r_3$</li><li>Subtask2($ 40\%$) : $r_1,r_2,r_3 \le 10$</li><li>Subtask3($ 40\%$) : $r_1,r_2,r_3 \le 10^9$</li></ul><p>对于$ 100\%$的数据$ 0 &lt; r_1 \le r_2 \le r_3 \le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6160" target="_blank" rel="noopener">P6160 [Cnoi2020]向量</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考场上把我整懵了的一题。</p><p>于是考场上打了20分半径相等的情况。</p><p>正解居然是$O(1)$的…好强。</p><script type="math/tex; mode=display">\begin{align}\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{c}\cdot\vec{a} &= \frac{1}{2}(|\vec{a}+\vec{b}+\vec{c}|^2-\vec{a}^2-\vec{b}^2-\vec{c}^2) \\&= \frac{1}{2}|\vec{a}+\vec{b}+\vec{c}|^2-\frac{1}{2}(\vec{a}^2+\vec{b}^2+\vec{c}^2)\end{align}</script><p>后项明显为定值，于是考虑最小化前项。</p><p>当$r_3&lt; r_2+r_1$时，可以构造矢量三角形，则前式最小值为$\vec{a}+\vec{b}+\vec{c}=\vec{0}$。</p><p>当$r_3\ge r_2+r_1$时，$|\vec{a}+\vec{b}+\vec{c}|\ge r_3-r_2-r_1$。</p><p>据此求解即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> a,b,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c&lt;a+b) <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;<span class="number">-0.5</span>*(a*a+b*b+c*c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;<span class="number">0.5</span>*(c-a-b)*(c-a-b)<span class="number">-0.5</span>*(a*a+b*b+c*c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（没错就是这么短）</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2398] GCD SUM</title>
      <link href="/is-zxy.github.io/2020/02/29/%5B%E6%B4%9B%E8%B0%B7P2398%5D-GCD-SUM/"/>
      <url>/is-zxy.github.io/2020/02/29/%5B%E6%B4%9B%E8%B0%B7P2398%5D-GCD-SUM/</url>
      
        <content type="html"><![CDATA[<p>求</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)</script><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$n\leq 3000$。</p><p>对于$ 60\%$的数据，$7000\leq n\leq 7100$。</p><p>对于$ 100\%$的数据，$n\leq 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2398" target="_blank" rel="noopener">P2398 GCD SUM</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和<a href="https://www.luogu.com.cn/problem/P2568" target="_blank" rel="noopener">P2568 GCD</a>做法很像。</p><p>硬算肯定TLE。</p><p>有很多组数的最大公因数是同一个数，据此产生思路。</p><p>对于$x,y$满足$gcd(x,y)=1$，则$gcd(kx,ky)=k$。</p><p>根据上题，$[1,n]$内最大公因数为$p$的对数为$2\sum_{i=1}^{\lfloor \frac{n}{p} \rfloor}\varphi(i)-1$。</p><p>于是该式答案即为$\sum_{i=1}^ni\times(2\sum_{j=1}^{\lfloor \frac{n}{i} \rfloor}\varphi(j)-1)$</p><p>线性筛$O(n)$求出欧拉函数，前缀和优化即可。$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,euler[N],prime[N],v[N],tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++tot]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||i*prime[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[i*prime[j]]=euler[i]*euler[prime[j]];</span><br><span class="line"><span class="keyword">else</span> euler[i*prime[j]]=euler[i]*prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+euler[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=i*(sum[n/i]*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2134] 百日旅行</title>
      <link href="/is-zxy.github.io/2020/02/28/%5B%E6%B4%9B%E8%B0%B7P2134%5D-%E7%99%BE%E6%97%A5%E6%97%85%E8%A1%8C/"/>
      <url>/is-zxy.github.io/2020/02/28/%5B%E6%B4%9B%E8%B0%B7P2134%5D-%E7%99%BE%E6%97%A5%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>小明和小红还剩下$N$天的假期，小明可以安排旅行的计划。如果连续$X$天旅游，小明需要花旅行费用$P\times X^2$元；如果连续$X$天不旅游，小明需要请小红吃饭，花费为$Q\times X$元。（$P,Q$都是输入的常数）</p><p>请你帮小明写一个程序，计算出假期里他至少需要花费多少元。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$数据，$N&lt;=20$。</p><p>对于$90\%$数据，$N&lt;=1000,P&lt;=2000,Q&lt;=10000$。</p><p>对于剩下的$10\%$数据，$N&lt;=200000,Q&lt;=P&lt;=10000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2134" target="_blank" rel="noopener">P2134 百日旅行</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][k]$，当$k$为$0$时表示前$i$天的最后一段旅游的最小费用，$k$为$1$反之。</p><p>易得</p><script type="math/tex; mode=display">dp[i][k]=\left\{\begin{aligned}&\min\{dp[j][1]+P(i-j)^2\},j\in[0,i) && k=0\\&\min\{dp[j][0]+Q(i-j)\},j\in[0,i) && k=1\end{aligned}\right.</script><p>于是可得$O(n^2)$算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,p,q,dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll x=i-j;</span><br><span class="line">dp[i][<span class="number">0</span>]=min(dp[i][<span class="number">0</span>],dp[j][<span class="number">1</span>]+(x*x*p));</span><br><span class="line">dp[i][<span class="number">1</span>]=min(dp[i][<span class="number">1</span>],dp[j][<span class="number">0</span>]+(x*q));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[n][<span class="number">1</span>],dp[n][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T了一个点。</p><p>观察数据范围，发现最后一个点虽然$n$特别大，但是保证了$Q\le P$，于是可以特判，A掉本题。</p><p>但还是来个正规的做法吧。</p><p>先取$k=0$的情况。</p><script type="math/tex; mode=display">\begin{align}dp[j][1]+P(i-j)^2&= dp[j][1]+P(i^2-2ij+j^2) \\&= dp[j][1]+Pi^2-2Pij+Pj^2\end{align}</script><p>令$l&lt;j&lt;i$，当决策$j$比决策$l$优时，则</p><script type="math/tex; mode=display">\begin{align}dp[j][1]-2Pij+Pj^2 &\le dp[l][1]-2Pil+Pl^2 \\dp[j][1]+Pj^2-(dp[l][1]+Pl^2) &\le 2Pi(j-l) \\\frac{dp[j][1]+Pj^2-(dp[l][1]+Pl^2)}{j-l} &\le 2Pi\end{align}</script><p>明显斜率优化。$2Pi$递增，则单调队列维护下凸壳即可。</p><p>在看$k=1$的情况。</p><script type="math/tex; mode=display">dp[j][0]+Q(i-j)</script><p>这个东西。。不讲了，明显取前面的最小的。</p><p>于是可得$O(n)$的算法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,p,q,dp[N][<span class="number">2</span>],minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> que[N],head,tail;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dp[y][<span class="number">1</span>]+p*y*y-(dp[x][<span class="number">1</span>]+p*x*x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">head=tail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=minn+q*i;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(que[head],que[head+<span class="number">1</span>])&lt;=<span class="number">2</span>*p*i*X(que[head],que[head+<span class="number">1</span>])) head++;</span><br><span class="line">dp[i][<span class="number">0</span>]=dp[que[head]][<span class="number">1</span>]+p*(i-que[head])*(i-que[head]);</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(que[tail<span class="number">-1</span>],que[tail])*X(que[tail],i)&gt;=Y(que[tail],i)*X(que[tail<span class="number">-1</span>],que[tail])) tail--;</span><br><span class="line">que[++tail]=i;</span><br><span class="line">minn=min(minn,dp[i][<span class="number">0</span>]-q*i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[n][<span class="number">1</span>],dp[n][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CEOI2004] 锯木厂选址</title>
      <link href="/is-zxy.github.io/2020/02/25/%5BCEOI2004%5D-%E9%94%AF%E6%9C%A8%E5%8E%82%E9%80%89%E5%9D%80/"/>
      <url>/is-zxy.github.io/2020/02/25/%5BCEOI2004%5D-%E9%94%AF%E6%9C%A8%E5%8E%82%E9%80%89%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>从山顶上到山底下沿着一条直线种植了$n$棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。</p><p>木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。</p><p>你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ 2≤n≤20000 $</p><p>$ 1≤w_i≤10000,0≤d_i≤10000 $</p><p>保证所有树运到山脚的锯木厂所需要的费用小于$2×10^9$分。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4360" target="_blank" rel="noopener">[CEOI2004]锯木厂选址</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问题可转化为$n+1$个地方放$3$个锯木厂。</p><p>定义$dp[k][i]$表示第$i$个地方放置第$k$个锯木厂，前$i$个地方的最小运输费用。</p><p>定义$sum$为$d$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">dp[k][i]=\min\{dp[k-1][j]+\sum_{l=j+1}^{i-1}[(sum[i-1]-sum[l-1])\times w[l]]\}</script><p>最终答案即为$dp[3][n+1]$。</p><p>于是$O(n^3)$的算法诞生了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w[N],d[N],dp[<span class="number">5</span>][N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=j+<span class="number">1</span>;l&lt;i;l++) s+=(sum[i<span class="number">-1</span>]-sum[l<span class="number">-1</span>])*w[l];</span><br><span class="line">dp[k][i]=min(dp[k][i],dp[k<span class="number">-1</span>][j]+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$\min$内的式子单独提出来看看</p><script type="math/tex; mode=display">\begin{align}dp[k-1][j]+\sum_{l=j+1}^{i-1}[(sum[i-1]-sum[l-1])\times w[l]]&= dp[k-1][j]+\sum_{l=j+1}^{i-1}(sum[i-1]\times w[l])-\sum_{l=j+1}^{i-1}(sum[l-1]\times w[l]) \\&= dp[k-1][j]+sum[i-1]\sum_{l=j+1}^{i-1}w[l]-\sum_{l=j+1}^{i-1}(sum[l-1]\times w[l])\end{align}</script><p>定义$sw$表示$w$的前缀和，$suw[i]$表示$sum[i-1]\times w[i]$的前缀和。</p><p>于是可化为</p><script type="math/tex; mode=display">dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j])</script><p>则</p><script type="math/tex; mode=display">dp[k][i]=\min\{dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j])\}</script><p>于是可得$O(n^2)$的算法。开$O2$居然水过了..</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll w[N],d[N],dp[<span class="number">5</span>][N],sum[N],sw[N],suw[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">sw[i]=sw[i<span class="number">-1</span>]+w[i];</span><br><span class="line">suw[i]=suw[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]*w[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">dp[k][i]=min(dp[k][i],dp[k<span class="number">-1</span>][j]+sum[i<span class="number">-1</span>]*(sw[i<span class="number">-1</span>]-sw[j])-(suw[i<span class="number">-1</span>]-suw[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将$\min$内的式子提出来</p><script type="math/tex; mode=display">\begin{align}&\ \ \ \ \ dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j]) \\&=dp[k-1][j]+sum[i-1]\times sw[i-1]-sum[i-1]\times sw[j]-suw[i-1]+suw[j]\end{align}</script><p>剔除常量</p><script type="math/tex; mode=display">dp[k-1][j]-sum[i-1]\times sw[j]+suw[j]</script><p>令$l&lt;j&lt;i$，当决策$j$比决策$l$更优时</p><script type="math/tex; mode=display">\begin{align}dp[k-1][j]-sum[i-1]\times sw[j]+suw[j] &\le dp[k-1][l]-sum[i-1]\times sw[l]+suw[l] \\dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l]) &\le sum[i-1]\times sw[j]-sum[i-1]\times sw[l] \\dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l]) &\le sum[i-1]\times (sw[j]-sw[l]) \\\frac{dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l])}{sw[j]-sw[l]} &\le sum[i-1]\end{align}</script><p>明显，斜率优化。</p><p>$sum$递增，即斜率递增。横坐标也单调递增，则单调队列维护下凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N];</span><br><span class="line">ll w[N],d[N],dp[<span class="number">5</span>][N],sum[N],sw[N],suw[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dp[k<span class="number">-1</span>][y]+suw[y]-(dp[k<span class="number">-1</span>][x]+suw[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sw[y]-sw[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">sw[i]=sw[i<span class="number">-1</span>]+w[i];</span><br><span class="line">suw[i]=suw[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]*w[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">sum[n]=sum[n<span class="number">-1</span>],sw[n]=sw[n<span class="number">-1</span>],suw[n]=suw[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(q[head],q[head+<span class="number">1</span>],k)&lt;=sum[i<span class="number">-1</span>]*X(q[head],q[head+<span class="number">1</span>])) head++;</span><br><span class="line">dp[k][i]=dp[k<span class="number">-1</span>][q[head]]+sum[i<span class="number">-1</span>]*sw[i<span class="number">-1</span>]-sum[i<span class="number">-1</span>]*sw[q[head]]-suw[i<span class="number">-1</span>]+suw[q[head]];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(q[tail<span class="number">-1</span>],q[tail],k)*X(q[tail],i)&gt;=Y(q[tail],i,k)*X(q[tail<span class="number">-1</span>],q[tail])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> CEOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IOI2000] 邮局</title>
      <link href="/is-zxy.github.io/2020/02/25/%5BIOI2000%5D-%E9%82%AE%E5%B1%80/"/>
      <url>/is-zxy.github.io/2020/02/25/%5BIOI2000%5D-%E9%82%AE%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。</p><p>邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。</p><p>你要编写一个程序，已知村庄的个数$V$、村庄的位置$X$和邮局的数量$P$，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \leq P \leq 300$</p><p>$P \leq V \leq 3000$.</p><p>$1 \leq X \leq 10000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4767" target="_blank" rel="noopener">[IOI2000]邮局</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先将坐标排个序。</p><p>定义$dp[i][j]$表示前$i$个村庄放$j$个邮局的前$i$个村庄的最小距离总和，$w(i,j)$表示村庄区间$[i,j]$内放一个村庄时该区间的最小距离总和。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=\min\{dp[k][j-1]+w(k+1,i)\},k\in[0,i)</script><p>那么关键就在于$w(k+1,i)$的处理了。</p><p>基本的数学知识，若村庄数为奇数，放中位数处距离和最小。若村庄为偶数，放中间两个村庄之间任意一处均可。</p><p>于是便可得一个$O(PV^3)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;mid;i++) ans+=X[mid]-X[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++) ans+=X[i]-X[mid];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[k][j<span class="number">-1</span>]+w(k+<span class="number">1</span>,i),dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再想想，可以提前预处理出$w$，其实这个$w$是可以$O(V^2)$递推出来的，根据放置一个邮局，邮局位置总是在中位数处，便可推得</p><script type="math/tex; mode=display">w[l][r]=w[l][r-1]+X[r]-X[\lfloor\frac{l+r}{2}\rfloor]</script><p>于是又可以得到一个$O(PV^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=V;l++) &#123;</span><br><span class="line">w[l][l]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=V;r++) &#123;</span><br><span class="line">w[l][r]=w[l][r<span class="number">-1</span>]+X[r]-X[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实$w$是满足四边形不等式的。</p><p>由上面$w$的递推式，可得$w[l][r+1]-w[l][r]=X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ $①</p><p>那么$w[l+1][r+1]-w[l+1][r]=X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor]\ $②</p><p>用①$-$②，得</p><script type="math/tex; mode=display">X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]-(X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor])=X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]</script><p>$X$坐标递增，则$X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ge 0$</p><p>即</p><script type="math/tex; mode=display">\begin{align}w[l][r+1]-w[l][r]-(w[l+1][r+1]-w[l+1][r]) &\ge 0 \\w[l][r+1]-w[l][r]-w[l+1][r+1]+w[l+1][r] &\ge 0 \\w[l][r+1]+w[l+1][r] &\ge w[l][r]+w[l+1][r+1]\end{align}</script><p>因此$w$满足四边形不等式，且明显，对于$a\le b\le c\le d$，$w[a][d]\ge w[b][c]$，故$dp$满足四边形不等式。</p><p>因为$dp$满足四边形不等式，所以对于$dp[i][j]$的最优决策$d[i][j]$，$d[i][j-1]\le d[i][j]\le d[i+1][j]$</p><p>于是状态转移$dp[i][j]$时，从$[dp[i][j-1],d[i+1][j]]$中找最优决策。</p><p>由于要用到$dp[i+1][j]$，所以倒序求解。</p><p>时间复杂度$O(PV)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN],d[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=V;l++) &#123;</span><br><span class="line">w[l][l]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=V;r++) &#123;</span><br><span class="line">w[l][r]=w[l][r<span class="number">-1</span>]+X[r]-X[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line">d[V+<span class="number">1</span>][j]=V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=V;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line"><span class="keyword">int</span> minn=INF,minid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=d[i][j<span class="number">-1</span>];k&lt;=d[i+<span class="number">1</span>][j];k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i]&lt;minn) &#123;</span><br><span class="line">minn=dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i];</span><br><span class="line">minid=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j]=minn;</span><br><span class="line">d[i][j]=minid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOI </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策单调性优化DP学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/21/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/21/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>设$w(x,y)$是定义在整数集合上的二元函数。若对于定义域上的任意整数$a,b,c,d$，其中$a\le b\le c\le d$，都有$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$成立，则称函数$w$满足<strong>四边形不等式</strong>。</p><a id="more"></a><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>设$w(x,y)$是定义在整数集合上的二元函数。若对于定义域上的任意整数$a,b$，其中$a&lt;b$，都有$w(a,b+1)+w(a+1,b)\ge w(a,b)+w(a+1,b+1)$成立，则函数$w$满足四边形不等式。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>对于$a&lt;c$，有$w(a,c+1)+w(a+1,c)\ge w(a,c)+w(a+1,c+1)$</p><p>对于$a+1&lt;c$，有$w(a+1,c+1)+w(a+2,c)\ge w(a+1,c)+w(a+2,c+1)$</p><p>两式相加，得到$w(a,c+1)+w(a+2,c)\ge w(a,c)+w(a+2,c+1)$</p><p>以此类推，对于任意的$a\le b\le c$，有$w(a,c+1)+w(b,c)\ge w(a,c)+w(b,c+1)$</p><p>同理，对任意的$a\le b\le c\le d$，有$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$</p><hr><h1 id="一维线性DP的四边形不等式优化"><a href="#一维线性DP的四边形不等式优化" class="headerlink" title="一维线性DP的四边形不等式优化"></a>一维线性DP的四边形不等式优化</h1><p>在状转方程$f[i]=\min\{f[j]+w(j,i)\},j\in[0,i)$中，若函数$w$满足四边形不等式，则$f$具有决策单调性。</p><h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h2><p>定义$p[i]$表示$i$的最优决策点。</p><p>$\forall i\in[1,n],\forall j\in[0,p[i]-1]$，根据$p[i]$为$i$的最优决策点，则有</p><script type="math/tex; mode=display">f[p[i]]+w(p[i],i)\le f[j]+w(j,i)</script><p>$\forall i’\in[i+1,n]$，因为$w$满足四边形不等式，则有</p><script type="math/tex; mode=display">w(j,i')+w(p[i],i)\ge w(j,i)+w(p[i],i')</script><p>移项，可得</p><script type="math/tex; mode=display">v(p[i],i')-w(p[i],i)\le w(j,i')-w(j,i)</script><p>与第一个不等式相加，可得</p><script type="math/tex; mode=display">f[p[i]]+w(p[i],i')\le f[j]+w(j,i')</script><p>即$i’$的最优决策点一定大于等于$p[i]$。故$f$具有决策单调性。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>那么知道其有决策单调性后，有什么应用呢？</p><p>既然其有决策单调性，定义$p[i]$表示$i$的最优决策点，则$p$内一定是非严格单调递增的。</p><p>那么根据此性质，满足决策单调性的题目主要有两种处理手法。</p><h3 id="方法一：单调队列"><a href="#方法一：单调队列" class="headerlink" title="方法一：单调队列"></a>方法一：单调队列</h3><p>可以用单调队列维护决策集合$p$。</p><p>当求出一个新的$f[i]$时，考虑$i$可以作为哪些$f[i’]\ (i’&gt;i)$的最优决策。根据决策单调性，我们一定可以找到一个位置，在该位置之前，$p$内存储的决策都比$i$要优，其后都比$i$差。于是便可以将该位置及其后面的部分全部变为$i$，即此时它们的最优决策均为$i$。</p><p>一个位置一个位置的修改效率很低，所以可以建立一个队列，代替$p$。队列中保存三个量$(j,l,r)$，表示$p[l$~$r]$的值都是$j$。</p><p>对于每个$i\in[1,n]$，执行以下操作：</p><ol><li><p>检查队头：设队头为$(j_0,l_0,r_0)$，若$r_0=i-1$，则删除队头（因为队头不需要了，$f[i]$之前的值已经被求出）。否则则令$l_0=i$。</p></li><li><p>取队头保存的最优决策$j$进行状态转移，计算出$f[i]$。</p></li><li><p>尝试插入新决策$i$，步骤如下</p><p>(1) 取出队尾，即为$(j_t,l_t,r_t)$</p><p>(2) 若对于$f[l_t]$来说，$i$是比$j_t$更优的决策，即$f[i]+w(i,l_t)\le f[j_t]+w(j_t,l_t)$，记$pos=l_t$，删除队尾，返回步骤(1)。</p><p>(3) 若对于$f[r_t]$来说，$i$是比$j_t$更优的决策，即$f[j_t]+w(j_t,r_t)\le f[i]+w(i,r_t)$，去往步骤(5)。</p><p>(4) 否则，则在$[l_t,r_t]$上二分查找出位置$pos$，在此之前决策比$i$优，在此之后决策$i$更优，将$[l_t,r_t]$修改为$[l_t,pos-1]$，去往步骤(5)。</p><p>(5) 把三元组$(i,pos,n)$插入队尾。</p></li></ol><p>时间复杂度$O(n\ log\ n)$。</p><h3 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h3><p>假设已知$[l,r]$的最优决策在$[L,R]$上。</p><p>定义$mid=\frac{l+r}{2}$，设$dp[mid]$的最优决策为$p$，根据决策单调性，可知$[l,mid-1]$的最优决策在$[L,p]$内，$[mid+1,r]$的最优决策在$[p,R]$内。</p><p>于是将问题分割成了同类型的规模更小的问题，便可递归分治。</p><p>时间复杂度$O(n\ log\ n)$</p><h2 id="例题-POI2011-Lightning-Conductor"><a href="#例题-POI2011-Lightning-Conductor" class="headerlink" title="例题 [POI2011]Lightning Conductor"></a>例题 [POI2011]Lightning Conductor</h2><p>给定一个长度为$ n$的序列$\{a_n\}$，对于每个$i\in [1,n]$，求出一个最小的非负整数$p$，使得 $\forall j\in[1,n]$，都有$a_j\le a_i+p-\sqrt{|i-j|}$。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 5\times 10^{5}$，$0 \le a_i \le 10^{9}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3515" target="_blank" rel="noopener">[POI2011]Lightning Conductor</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><script type="math/tex; mode=display">\begin{align}a_j &\le a_i+p-\sqrt{|i-j|},\forall j\in[1,n] \\p &\ge a_j+\sqrt{|i-j|}-a_i,\forall j\in[1,n]\end{align}</script><p>而$p$为非负整数，则</p><script type="math/tex; mode=display">p=\lceil \max\{ a_j+\sqrt{|i-j|}\}\rceil-a_i,\forall j\in[1,n]</script><p>那么问题便转变为求$\lceil \max\{ a_j+\sqrt{|i-j|}\}\rceil,\forall j\in[1,n]$。</p><p>可以考虑做两次，正做一次，将序列翻转再做一次，结果取两次的最大值，这样便可以去掉绝对值</p><script type="math/tex; mode=display">\lceil \max\{ a_j+\sqrt{i-j}\}\rceil,\forall j\in[1,i)</script><p>定义$dp[i]=\lceil \max\{ a_j+\sqrt{i-j}\}\rceil$。</p><p>此处的$w(j,i)$即为$\sqrt{i-j}$。</p><p>定义$a+1&lt;c$。</p><script type="math/tex; mode=display">w(a,c)=\sqrt{c-a}</script><script type="math/tex; mode=display">w(a+1,c)=\sqrt{c-a-1}</script><script type="math/tex; mode=display">w(a,c+1)=\sqrt{c-a+1}</script><script type="math/tex; mode=display">w(a+1,c+1)=\sqrt{c-a}</script><p>则</p><script type="math/tex; mode=display">\begin{align}w(a,c+1)+w(a+1,c)-[w(a,c)+w(a+1,c+1)] &=\sqrt{c-a-1}+\sqrt{c-a+1}-2\sqrt{c-a}\end{align}</script><p>令$d=c-a$，原式变为</p><script type="math/tex; mode=display">\sqrt{d-1}+\sqrt{d+1}-2\sqrt{d}=(\sqrt{d+1}-\sqrt{d})-(\sqrt{d}-\sqrt{d-1})</script><p>而函数$f(x)=\sqrt{x}-\sqrt{x-1}$单调递减</p><p>则该式恒小于$0$。</p><p>即$w(a,c+1)+w(a+1,c)\le w(a,c)+w(a+1,c+1)$。</p><p>可推广到对于$a\le b\le c\le d$，$w(a,d)+w(b,c) \le w(a,c)+w(b,d)$。</p><p>可以发现，这东西与四边形不等式的符号相反。将上面的证明过程符号取反（因为本题求的是$\max$），便可证明$dp$满足决策单调性。</p><p>于是采用上面两种方法实现即可。</p><p>由于函数$sqrt$较慢，且本题反复调用，可提前预处理出$\sqrt{1}$~$\sqrt{n}$。</p><h3 id="代码（单调队列）"><a href="#代码（单调队列）" class="headerlink" title="代码（单调队列）"></a>代码（单调队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,head,tail,a[N];</span><br><span class="line"><span class="keyword">double</span> dp[N],sqr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,p;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">double</span>(a[j])+sqr[i-j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=q[t].r+<span class="number">1</span>,l=q[t].l,r=q[t].r;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(w(q[t].p,mid)&lt;=w(x,mid)) ans=mid,r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">q[tail].l=max(q[tail].l,i);</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;w(i,q[tail].l)&gt;=w(q[tail].p,q[tail].l)) tail--;</span><br><span class="line"><span class="keyword">if</span>(head&gt;tail) &#123;</span><br><span class="line">q[++tail].l=i;</span><br><span class="line">q[tail].r=n;</span><br><span class="line">q[tail].p=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> pos=binary_search(tail,i);</span><br><span class="line"><span class="keyword">if</span>(pos&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">q[tail].r=pos<span class="number">-1</span>;</span><br><span class="line">q[++tail].l=pos;</span><br><span class="line">q[tail].r=n;</span><br><span class="line">q[tail].p=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">insert(i);</span><br><span class="line"><span class="keyword">if</span>(head&lt;=tail&amp;&amp;q[head].r&lt;i) head++;</span><br><span class="line"><span class="keyword">else</span> q[head].l=i;</span><br><span class="line">dp[i]=max(dp[i],w(q[head].p,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sqr[i]=<span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(a[i],a[n-i+<span class="number">1</span>]),swap(dp[i],dp[n-i+<span class="number">1</span>]);</span><br><span class="line">work();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)<span class="built_in">ceil</span>(dp[i])-a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（分治）"><a href="#代码（分治）" class="headerlink" title="代码（分治）"></a>代码（分治）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">double</span> dp[N],sqr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">double</span>(a[j])+sqr[i-j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,p;</span><br><span class="line"><span class="keyword">double</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=min(mid,R);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(w(i,mid)&gt;maxn) maxn=w(i,mid),p=i;</span><br><span class="line">&#125;</span><br><span class="line">dp[mid]=max(dp[mid],maxn);</span><br><span class="line">work(l,mid<span class="number">-1</span>,L,p);</span><br><span class="line">work(mid+<span class="number">1</span>,r,p,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sqr[i]=<span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(a[i],a[n-i+<span class="number">1</span>]),swap(dp[i],dp[n-i+<span class="number">1</span>]);</span><br><span class="line">work(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)<span class="built_in">ceil</span>(dp[i])-a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二维区间DP的四边形不等式优化"><a href="#二维区间DP的四边形不等式优化" class="headerlink" title="二维区间DP的四边形不等式优化"></a>二维区间DP的四边形不等式优化</h1><p>区间DP会经常遇到下面这样的状态转移方程</p><script type="math/tex; mode=display">f[i][j]=\min_{i\le k<j}\{f[i][k]+f[k+1][j]+w(i,j)\}</script><p>对此也可用四边形不等式进行优化。</p><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><p>在状态转移方程$f[i][j]=\min_{i\le k&lt;j}\{f[i][k]+f[k+1][j]+w(i,j)\}$中（特别地，$f[i][i]=w(i,i)=0$），如果下面这两个条件成立</p><ol><li>$w$满足四边形不等式</li><li>对于任意的$a\le b\le c\le d$，有$w(a,d)\ge w(b,c)$。</li></ol><p>那么$f$也满足四边形不等式。</p><p><del>证明过于繁琐，记结论吧233</del></p><h2 id="定理（二维决策单调性）"><a href="#定理（二维决策单调性）" class="headerlink" title="定理（二维决策单调性）"></a>定理（二维决策单调性）</h2><p>在状态转移方程$f[i][j]=\min_{i\le k&lt;j}\{f[i][k]+f[k+1][j]+w(i,j)\}$中（特别地，$f[i][i]=w(i,i)=0$），记$p[i][j]$表示令$f[i][j]$取到最小值的$k$值。</p><p>如果$f$满足四边形不等式，那么对于任意$i&lt;j$，有$p[i][j-1]\le p[i][j]\le p[i+1][j]$。</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>简记$p[i][j]=p$，对于任意的$i&lt;k\le p$，因为$f$满足四边形不等式，则</p><script type="math/tex; mode=display">\begin{align}f[i][p]+f[i+1][k] &\ge f[i][k]+f[i+1][p] \\f[i+1][k]-f[i+1][p] &\ge f[i][k]-f[i][p]\end{align}</script><p>而$p$为最优决策，则</p><script type="math/tex; mode=display">\begin{align}f[i][k]+f[k+1][j]+w(i,j) &\ge f[i][p]+f[p+1][j]+w(i,j) \\f[i][k]+f[k+1][j] &\ge f[i][p]+f[p+1][j]\end{align}</script><p>因此</p><script type="math/tex; mode=display">\begin{align}&\ \ \ \ \ (f[i+1][k]+f[k+1][j]+w(i+1,j))-(f[i+1][p]+f[p+1][j]+w(i+1,j)) \\&= (f[i+1][k]-f[i+1,p])+(f[k+1][j]-f[p+1][j]) \\&\ge (f[i][k]-f[i][p])+(f[k+1][j]-f[p+1][j]) \\&= (f[i][k]+f[k+1][j])-(f[i][p]+f[p+1][j]) \\&\ge 0\end{align}</script><p>这意味着对于$f[i+1][j]$，$p$比任意的$k\le p$更优。因此$p[i+1][j]\ge p[i][j]$。</p><p>同理可证$p[i][j-1]\le p[i][j]$。</p><h3 id="例题-NOI1995-石子合并"><a href="#例题-NOI1995-石子合并" class="headerlink" title="例题 [NOI1995]石子合并"></a>例题 [NOI1995]石子合并</h3><p>在一个圆形操场的四周摆放$N$堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的$2$堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出一个算法,计算出将$ N$堆石子合并成$1 $堆的最小得分和最大得分。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 100,0\le a_i\le 20$</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">[NOI1995]石子合并</a> </p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先本题的数据范围$O(N^3)$的算法是可以过的。</p><p>若$N\le 1000$的话，就需要优化了。</p><p>定义$fmax$与$fmin$表示最大最小得分，$sum$为$a$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">fmax[l][r]=\max_{l\le k< r}\{f[l][k],f[k+1][r]\}+sum[r]-sum[l-1] \\fmin[l][r]=\min_{l\le k< r}\{f[l][k],f[k+1][r]\}+sum[r]-sum[l-1]</script><p>明显$w(l,r)=sum[r]-sum[l-1]$满足四边形不等式。于是求$fmin$可以采用四边形不等式优化。</p><p>但是$fmax$不满足四边形不等式。动手推推，发现取得最大值的决策只能在$f[l+1][r]$和$f[l][r-1]$中，取两者最大值作为决策即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,minf[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],a[N&lt;&lt;<span class="number">1</span>],sum[N&lt;&lt;<span class="number">1</span>],maxf[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],p[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],minsco=INF,maxsco=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">a[i+n]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++) &#123;</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">p[i][i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=(n&lt;&lt;<span class="number">1</span>);l++) &#123;</span><br><span class="line"><span class="keyword">int</span> r=l+len<span class="number">-1</span>,minn=INF,minid;</span><br><span class="line">maxf[l][r]=max(maxf[l+<span class="number">1</span>][r],maxf[l][r<span class="number">-1</span>])+sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=p[l][r<span class="number">-1</span>];k&lt;=p[l+<span class="number">1</span>][r];k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(minf[l][k]+minf[k+<span class="number">1</span>][r]+sum[r]-sum[l<span class="number">-1</span>]&lt;minn) &#123;</span><br><span class="line">minn=minf[l][k]+minf[k+<span class="number">1</span>][r]+sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">minid=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minf[l][r]=minn;</span><br><span class="line">p[l][r]=minid;</span><br><span class="line"><span class="keyword">if</span>(len==n) &#123;</span><br><span class="line">minsco=min(minsco,minf[l][r]);</span><br><span class="line">maxsco=max(maxsco,maxf[l][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minsco&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxsco&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>若是考场上遇到了疑似能四边形不等式优化的题，可以打表判断其是否符合四边形不等式，毕竟考场时间有限。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《算法竞赛进阶指南》</p><p><a href="https://www.cnblogs.com/Xing-Ling/p/11317315.html" target="_blank" rel="noopener">【学习笔记】动态规划—各种 DP 优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2007] 理想的正方形</title>
      <link href="/is-zxy.github.io/2020/02/21/%5BHAOI2007%5D-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/is-zxy.github.io/2020/02/21/%5BHAOI2007%5D-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>有一个$a\times b$的整数组成的矩阵，现请你从中找出一个$n\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>（1）矩阵中的所有数都不超过$1,000,000,000$</p><p>（2）$20\%$的数据$2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10$</p><p>（3）$100\%$的数据$2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2216" target="_blank" rel="noopener">[HAOI2007]理想的正方形</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一个二维的RMQ问题。</p><p>明显可以二维ST表解决，时间复杂度$O(ab\log n)$。</p><p>其实也是一个二维的滑动窗口问题，可用单调队列解决，时间复杂度会更优。咕咕咕。</p><h3 id="代码（ST表）"><a href="#代码（ST表）" class="headerlink" title="代码（ST表）"></a>代码（ST表）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,n,s[N][N],minf[N][N][<span class="number">15</span>],maxf[N][N][<span class="number">15</span>],lg[N],ans=INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=lg[n];k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=a;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=b;j++) &#123;</span><br><span class="line">minf[i][j][k]=min(minf[i][j][k<span class="number">-1</span>],min(minf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j][k<span class="number">-1</span>],min(minf[i][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>],minf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>])));</span><br><span class="line">maxf[i][j][k]=max(maxf[i][j][k<span class="number">-1</span>],max(maxf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j][k<span class="number">-1</span>],max(maxf[i][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>],maxf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>])));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=lg[n];</span><br><span class="line"><span class="keyword">return</span> max(maxf[i][j][t],max(maxf[i][j+n-(<span class="number">1</span>&lt;&lt;t)][t],max(maxf[i+n-(<span class="number">1</span>&lt;&lt;t)][j][t],maxf[i+n-(<span class="number">1</span>&lt;&lt;t)][j+n-(<span class="number">1</span>&lt;&lt;t)][t])))-min(minf[i][j][t],min(minf[i][j+n-(<span class="number">1</span>&lt;&lt;t)][t],min(minf[i+n-(<span class="number">1</span>&lt;&lt;t)][j][t],minf[i+n-(<span class="number">1</span>&lt;&lt;t)][j+n-(<span class="number">1</span>&lt;&lt;t)][t])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(minf,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(minf));</span><br><span class="line"><span class="built_in">memset</span>(maxf,<span class="number">0</span>,<span class="keyword">sizeof</span>(maxf));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i][j];</span><br><span class="line">minf[i][j][<span class="number">0</span>]=maxf[i][j][<span class="number">0</span>]=s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a-n+<span class="number">1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b-n+<span class="number">1</span>;j++) &#123;</span><br><span class="line">ans=min(ans,ask(i,j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAOI </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3398] 仓鼠找sugar</title>
      <link href="/is-zxy.github.io/2020/02/20/%5B%E6%B4%9B%E8%B0%B7P3398%5D-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/"/>
      <url>/is-zxy.github.io/2020/02/20/%5B%E6%B4%9B%E8%B0%B7P3398%5D-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/</url>
      
        <content type="html"><![CDATA[<p>小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为$1$~$n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？</p><p>小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$20\%$的数据$n&lt;=200,q&lt;=200$</p><p>$40\%$的数据$n&lt;=2000,q&lt;=2000$</p><p>$70\%$的数据$n&lt;=50000,q&lt;=50000$</p><p>$100\%$的数据$n&lt;=100000,q&lt;=100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3398" target="_blank" rel="noopener">P3398 仓鼠找sugar</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求两条树上最短路的交点。</p><p>动手模拟模拟，发现若两路径若有交点，则较深的两点的LCA一定在另一条路径上。</p><p>那么如何判断一点在一条路径上呢？</p><p>树上的最短路是一条链，链上任意一点到链两边距离相等，于是便可以据此判断两点的LCA是否在另一条路径上。</p><p>接下来的问题就是如何求两点间距离。</p><p>定义$depth[x]$表示点$x$的深度。</p><p>其实很容易得到，点$x$与点$y$的距离$dis(x,y)=depth[x]+depth[y]-2\times depth[LCA(x,y)]$。</p><p>这里的距离是在本题边权为$1$的情况而定的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">25</span>],head[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[LCA(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"><span class="keyword">int</span> lab=LCA(a,b),lcd=LCA(c,d);</span><br><span class="line"><span class="keyword">if</span>(depth[lab]&gt;depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dis(lab,c)+dis(lab,d)==depth[c]+depth[d]<span class="number">-2</span>*depth[lcd]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(depth[lab]==depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(lab==lcd) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(depth[lab]&lt;depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dis(lcd,a)+dis(lcd,b)==depth[a]+depth[b]<span class="number">-2</span>*depth[lab]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO08OCT] 牧场散步Pasture Walking</title>
      <link href="/is-zxy.github.io/2020/02/19/%5BUSACO08OCT%5D-%E7%89%A7%E5%9C%BA%E6%95%A3%E6%AD%A5Pasture-Walking/"/>
      <url>/is-zxy.github.io/2020/02/19/%5BUSACO08OCT%5D-%E7%89%A7%E5%9C%BA%E6%95%A3%E6%AD%A5Pasture-Walking/</url>
      
        <content type="html"><![CDATA[<p>有$N(2&lt;=N&lt;=1000)$头奶牛，编号为$1$到$W$，它们正在同样编号为$1$到$N$的牧场上行走.为了方便，我们假设编号为$i$的牛恰好在第i号牧场上.</p><p>有一些牧场间每两个牧场用一条双向道路相连，道路总共有$N - 1$条，奶牛可以在这些道路 上行走.第i条道路把第$A_i$个牧场和第$B_i$个牧场连了起来$(1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N)$，而它的长度 是$ 1 &lt;= L_i &lt;= 10,000$。在任意两个牧场间，有且仅有一条由若干道路组成的路径相连.也就是说，所有的道路构成了一棵树。</p><p>奶牛们十分希望经常互相见面.它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出$Q(1 &lt; Q &lt; 1000)$对点之间的路径长度，每对点以一个询问$p_1$,$p_2$$ (1 &lt;= p1 &lt;= N; 1 &lt;= p2 &lt;= N)$。 的形式给出。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$  (2 &lt;= N &lt;= 1,000) $</p><p>$ (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) $</p><p>$ (1 &lt;= L_i &lt;= 10,000) $</p><p>$ (1 &lt;= p_1 &lt;= N; 1 &lt;= p_2 &lt;= N) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2912" target="_blank" rel="noopener">[USACO08OCT]牧场散步Pasture Walking</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两点间路径长度即到其LCA的路径长度之和。</p><p>定义$f[x][i]$表示点$x$的第$2^i$级祖先，$dis[x][i]$表示点$x$到其第$2^i$级祖先的路径长度。</p><p>易得</p><script type="math/tex; mode=display">dis[x][i]=dis[x][i-1]+dis[f[x][i-1]][i-1]</script><p>于是跑个倍增LCA，过程中计算答案即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,head[N],tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">15</span>],dis[N][<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">dis[now][<span class="number">0</span>]=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) &#123;</span><br><span class="line">f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">dis[now][i]=dis[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]+dis[now][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) &#123;</span><br><span class="line">ans+=dis[x][lg[depth[x]-depth[y]]];</span><br><span class="line">x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">ans+=dis[x][i]+dis[y][i];</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans+dis[x][<span class="number">0</span>]+dis[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;LCA(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2013] 货车运输</title>
      <link href="/is-zxy.github.io/2020/02/18/%5BNOIP2013%5D-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/"/>
      <url>/is-zxy.github.io/2020/02/18/%5BNOIP2013%5D-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p>A 国有$n$座城市，编号从$1$到$n$，城市之间有$m$条双向道路。每一条道路对车辆都有重量限制，简称限重。</p><p>现在有$q$辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$1 \le n &lt; 1000$，$1 \le m &lt; 10,000$，$1\le q&lt; 1000$；</p><p>对于$ 60\%$的数据，$1 \le n &lt; 1000$，$1 \le m &lt; 5\times 10^4$，$1 \le q&lt; 1000$；</p><p>对于$ 100\%$的数据，$1 \le n &lt; 10^4$，$1 \le m &lt; 5\times 10^4$，$1 \le q&lt; 3\times 10^4$，$0 \le z \le 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">货车运输</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前的思路是kruskal最大生成树，过程中每并两点，就把问题集合扫一遍，若问题集合中的$x,y$此时相连，那么该问题的答案即为目前加进去的边权值。当然，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,vset[<span class="number">10010</span>],q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dis;</span><br><span class="line">&#125;edge[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.dis&gt;y.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa=find(edge[i].from),fb=find(edge[i].to);</span><br><span class="line"><span class="keyword">if</span>(fa!=fb) vset[fa]=fb;</span><br><span class="line"><span class="keyword">if</span>(find(x)==find(y)) &#123;</span><br><span class="line">ans=edge[i].dis;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">edge[i].from=x;</span><br><span class="line">edge[i].to=y;</span><br><span class="line">edge[i].dis=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;kruskal(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后听说正解是LCA。</p><p>于是最近学了倍增LCA，便A了这题。</p><p>首先还是kruskal最大生成树当然，图若不连通就是森林。</p><p>对于每个问题，先判断其是否在一个树上，然后跑个倍增LCA，记录答案即可。</p><p>主要就是倍增思想。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,vset[N],head[N],tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">25</span>],v[N][<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,dis;</span><br><span class="line">&#125;edge_g[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(graph a,graph b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(edge_g+<span class="number">1</span>,edge_g+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa=find(edge_g[i].x),fb=find(edge_g[i].y);</span><br><span class="line"><span class="keyword">if</span>(fa!=fb) &#123;</span><br><span class="line">add(edge_g[i].x,edge_g[i].y,edge_g[i].dis);</span><br><span class="line">add(edge_g[i].y,edge_g[i].x,edge_g[i].dis);</span><br><span class="line">vset[fa]=fb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">vh[now]=<span class="number">1</span>;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">v[now][<span class="number">0</span>]=value;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) &#123;</span><br><span class="line">v[now][i]=min(v[now][i<span class="number">-1</span>],v[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) &#123;</span><br><span class="line">dfs(<span class="number">0</span>,i,INF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(find(x)!=find(y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) &#123;</span><br><span class="line">ans=min(ans,v[x][lg[depth[x]-depth[y]]]);</span><br><span class="line">x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">ans=min(min(v[x][i],v[y][i]),ans);</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min(ans,min(v[x][<span class="number">0</span>],v[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;edge_g[i].x&gt;&gt;edge_g[i].y&gt;&gt;edge_g[i].dis;</span><br><span class="line"></span><br><span class="line">kruskal();</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;LCA(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> NOIP </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#65] triangle</title>
      <link href="/is-zxy.github.io/2020/02/17/%5BNOI-AC-65%5D-triangle/"/>
      <url>/is-zxy.github.io/2020/02/17/%5BNOI-AC-65%5D-triangle/</url>
      
        <content type="html"><![CDATA[<p>一个无限行的数字三角形，第$i$行有$i$个数。第一行的第一个数是$1$，其他的数满足如下关系：如果用$F[i][j]$表示第$i$行的第$j$个数，那么$F[i][j]=A∗F[i−1][j]+B∗F[i−1][j−1]$（不合法的下标的数为$0$）。</p><p>当$A=2,B=3A=2,B=3$时的数字三角形的前$5$行为：</p><p>$1$</p><p>$2\ 3$</p><p>$4\ 12\ 9$</p><p>$8\ 36\ 54\ 27$</p><p>$16\ 96\ 216\ 216\ 81$</p><p>现在有$T$次询问，求$A=a,B=b$时数字三角形的第$n$行第$m$个数的值模$10^9+9$的结果。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n,T≤100000,1≤m≤n,0≤a,b≤109$。</p><p>Subtask1 ($20\%$) ：$n,T≤100$。</p><p>Subtask2 ($20\%$) ：$n≤10000,T≤1000$。</p><p>Subtask3 ($60\%$) ：无特殊限制。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/65" target="_blank" rel="noopener">#65. triangle</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显，这东西就是求$(ax+by)^{n-1}$的$x^{n-m}y^{m-1}$项的系数。</p><p>根据二项式定理，可以得知答案为</p><script type="math/tex; mode=display">a^{n-m}b^{m-1}C_{n-1}^{n-m}</script><p>卢卡斯快速幂瞎搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p)*(y%p))%p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(mul(t,t),x);</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> mul(mul(f[n],quickp(f[m],p<span class="number">-2</span>)),quickp(f[n-m],p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;i++) f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line">ll a,b,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mul(mul(Laucs(n<span class="number">-1</span>,m<span class="number">-1</span>),quickp(a,n-m)),quickp(b,m<span class="number">-1</span>)));</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> NOI.AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#66] 求和</title>
      <link href="/is-zxy.github.io/2020/02/17/%5BNOI-AC-66%5D-%E6%B1%82%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/02/17/%5BNOI-AC-66%5D-%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给一个$n$行$t$列的矩阵，矩阵第$i$行第$j$列的元素是$i+j$。</p><p>定义矩阵第$i$行的积为第$i$行所有元素的乘积。</p><p>现在要你求矩阵所有行的积的和。答案可能很大，所以$mod\ \ 1000000007(10^9+7)$输出。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$10\%$, $T≤100$,$n≤1000$</p><p>另$20\%$,$T≤10$,$n≤1e7$</p><p>另$20\%$,$T≤10000$,$n≤1e7$</p><p>另$20\%$,$T≤10000$,$n≤1e8$</p><p>$100\%$,$1≤T≤10000$,$1≤n≤1e10$,$1≤t≤1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/66" target="_blank" rel="noopener">#66. 求和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>则求</p><script type="math/tex; mode=display">\sum_{i=1}^n\prod_{j=1}^t(i+j)</script><p>易得每行都为连续自然数，则可化为</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n\frac{(i+t)!}{i!}&= \sum_{i=1}^n(C_{i+t}^i\times t!) \\&= t!\times \sum_{i=1}^nC_{i+t}^i \\&= t!\times \sum_{i=1}^nC_{i+t}^t\end{align}</script><p>考虑这种式子：</p><script type="math/tex; mode=display">\sum_{i=1}^nC_{i+t}^t</script><p>根据组合性质，有</p><script type="math/tex; mode=display">\begin{align}C_{n+1}^m &= C_{n}^m+C_{n}^{m-1} \\C_{n}^{m-1} &= C_{n+1}^m-C_n^m \\C_{n}^m &= c_{n+1}^{m+1}-C_n^{m+1}\end{align}</script><p>那么上式可化为</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n(C_{i+t+1}^{t+1}-C_{i+t}^{t+1})&= C_{n+t+1}^{t+1}-C_{t+1}^{t+1} \\&= C_{n+t+1}^{t+1}-1\end{align}</script><p>那么答案即为</p><script type="math/tex; mode=display">t!\times (C_{n+t+1}^{t+1}-1) \mod 1000000007</script><p>预处理出阶乘，然后卢卡斯即可。</p><p>注意卢卡斯求$C_{n+t+1}^{t+1}\mod p$的结果可能为$0$，再减一为负，所以最终答案要加上$p$再模$p$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p)*(y%p))%p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,t,T,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(mul(t,t),x);</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m=n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=mul(a,n-i);</span><br><span class="line">b=mul(b,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mul(a,quickp(b,p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N<span class="number">-10</span>;i++) f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line">ll ans=mul(f[t],Laucs(n+t+<span class="number">1</span>,t+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(ans+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> NOI.AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#605] 约数个数</title>
      <link href="/is-zxy.github.io/2020/02/16/%5BNOI-AC-605%5D-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
      <url>/is-zxy.github.io/2020/02/16/%5BNOI-AC-605%5D-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>$f(n)$表示$n$的约数个数，现在给出$n$，求出$f(1)$到$f(n)$的总和 。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，满足$n≤5000$。 </p><p>对于$100\%$的数据，满足$n≤1000000$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/605" target="_blank" rel="noopener">#605. 约数个数</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥思路。线性筛板子。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,prime[N],v[N],num[N],factor[N],m=<span class="number">0</span>;</span><br><span class="line">ll sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">factor[<span class="number">1</span>]=sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">num[i]=<span class="number">1</span>;</span><br><span class="line">factor[i]=<span class="number">2</span>;</span><br><span class="line">sum+=factor[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]*factor[prime[j]];</span><br><span class="line">num[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]/(num[i]+<span class="number">1</span>)*(num[i]+<span class="number">2</span>);</span><br><span class="line">num[i*prime[j]]=num[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=factor[i*prime[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性筛 </tag>
            
            <tag> NOI.AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2016] 征途</title>
      <link href="/is-zxy.github.io/2020/02/15/%5BSDOI2016%5D-%E5%BE%81%E9%80%94/"/>
      <url>/is-zxy.github.io/2020/02/15/%5BSDOI2016%5D-%E5%BE%81%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p>Pine开始了从S地到T地的征途。</p><p>从S地到T地的路可以划分成$n$段，相邻两段路的分界点设有休息站。</p><p>Pine计划用$m$天到达T地。除第$m$天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。</p><p>Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。</p><p>帮助Pine求出最小方差是多少。</p><p>设方差是$v$，可以证明，$v\times m^2$是一个整数。为了避免精度误差，输出结果时输出$v\times m^2$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1 \le n \le 10$</p><p>对于$60\%$的数据，$1 \le n \le 100$</p><p>对于$100\%$的数据，$1 \le n \le 3000$</p><p>保证从 S 到 T 的总路程不超过$30000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4072" target="_blank" rel="noopener">[SDOI2016]征途</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$v$是方差，则$v=\frac{\sum_{i=1}^m(S_i-\frac{sum[n]}{m})^2}{m}$</p><p>则</p><script type="math/tex; mode=display">\begin{align}v\times m^2 &= m\sum_{i=1}^m(S_i-\frac{sum[n]}{m})^2 \\&= m\sum_{i=1}^m(S_i^2-2\times S_i\times \frac{sum[n]}{m}+\frac{sum[n]^2}{m^2}) \\&= m\sum_{i=1}^mS_i^2-2\times sum[n]\sum_{i=1}^mS_i+sum[n]^2 \\&= m\sum_{i=1}^mS_i^2-2\times sum[n]^2+sum[n]^2 \\&= m\sum_{i=1}^mS_i^2-sum[n]^2\end{align}</script><p>于是最小化$m\sum_{i=1}^mS_i^2$即可。</p><p>定义$dp[i][k]$表示前$i$段在第$k$天走到的最小$\sum_{i=1}^kS_i^2$的最小值。</p><p>易得</p><script type="math/tex; mode=display">dp[i][k]=\min\{dp[j][k-1]+m\times (sum[i]-sum[j])^2\},i\in[1,n],k\in[0,i)</script><p>最终答案即为$dp[n][m]-sum[n]^2$</p><p>于是可以得到一个$O(mn^2)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[N],sum[N],dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i][k]=min(dp[i][k],dp[j][k<span class="number">-1</span>]+m*(sum[i]-sum[j])*(sum[i]-sum[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]-sum[n]*sum[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$\min$内的式子单独提出来看看。</p><script type="math/tex; mode=display">\begin{align}dp[j][k-1]+m\times (sum[i]-sum[j])^2 &= dp[j][k-1]+m(sum[i]^2-2\times sum[i]\times sun[j]+sum[j]^2) \\&= dp[j][k-1]+m\times sun[i]^2-2m\times sum[i]\times sum[j]+m\times sum[j]^2\end{align}</script><p>将常量剔除，得</p><script type="math/tex; mode=display">dp[j][k-1]-2m\times sum[i]\times sum[j]+m\times sum[j]^2</script><p>定义$sm[i]=m\times sum[i]^2$，则变为</p><script type="math/tex; mode=display">dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j]</script><p>则原状转方程变为</p><script type="math/tex; mode=display">dp[i][k]=\min\{dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j]\}+sm[i],i\in[1,n],k\in[0,i)</script><p>令$p&lt;j&lt;i$， 若转移决策点$j$比转移决策点$k$更优，则</p><script type="math/tex; mode=display">\begin{align}dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j] &\le dp[p][k-1]-2m\times sum[i]\times sum[p]+sm[p] \\ \\dp[j][k-1]+sm[j]-(dp[p][k-1]+sm[p]) &\le 2m\times sum[i](sum[j]-sum[p]) \\ \\\frac{dp[j][k-1]+sm[j]-(dp[p][k-1]+sm[p])}{sum[j]-sum[p]} &\le 2m\times sum[i]\end{align}</script><p>看到这式子，明显可以斜率优化，维护下凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q[N];</span><br><span class="line">ll a[N],sum[N],dp[N][N],sm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">sm[i]=m*sum[i]*sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">1</span>]=sm[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=m;k++) &#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]][k<span class="number">-1</span>]+sm[q[head+<span class="number">1</span>]]-(dp[q[head]][k<span class="number">-1</span>]+sm[q[head]])&lt;=<span class="number">2</span>*m*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i][k]=dp[q[head]][k<span class="number">-1</span>]<span class="number">-2</span>*m*sum[i]*sum[q[head]]+sm[q[head]]+sm[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]][k<span class="number">-1</span>]+sm[q[tail]]-(dp[q[tail<span class="number">-1</span>]][k<span class="number">-1</span>]+sm[q[tail<span class="number">-1</span>]]))*(sum[i]-sum[q[tail]])&gt;=(dp[i][k<span class="number">-1</span>]+sm[i]-(dp[q[tail]][k<span class="number">-1</span>]+sm[q[tail]]))*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]-sum[n]*sum[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2015] WIL-Wilcze doły</title>
      <link href="/is-zxy.github.io/2020/02/14/%5BPOI2015%5D-WIL-Wilcze-doly/"/>
      <url>/is-zxy.github.io/2020/02/14/%5BPOI2015%5D-WIL-Wilcze-doly/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$n$的序列，你有一次机会选中一段连续的长度不超过$d$的区间，将里面所有数字全部修改为$0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过$p$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=d&lt;=n&lt;=2000000,0&lt;=p&lt;=10^{16})$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3594" target="_blank" rel="noopener">[POI2015]WIL-Wilcze doły</a> </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于每个数都是正数，那么当然修改的越多越好，干脆直接修改长度为$d$的区间。</p><p>枚举选中的连续区间的左右端点和被修改区间的左端点，便可以得到一个$O(n^3)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>;</span><br><span class="line">ull p,a[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-d+<span class="number">1</span>;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=i-d+<span class="number">1</span>;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]-sum[j<span class="number">-1</span>]-(sum[k+d<span class="number">-1</span>]-sum[k<span class="number">-1</span>])&lt;=p) ans=max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种选连续数和不超过一个数值的题型让我想到了挑程上的尺取法。于是便采用了这种方法进行优化，向一个队列中加数，当和大于了$p$，就开始从被选的数列中枚举修改为$0$的区间的左端点，若不存在修改后小于等于$p$的修改区间，则将队头出队。过程中记录最大区间长度即可。时间复杂度$O(n^2)$，还是TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>,l=<span class="number">1</span>;</span><br><span class="line">ull p,a[N],sum[N],s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">s+=a[i];</span><br><span class="line"><span class="keyword">if</span>(i-l+<span class="number">1</span>&lt;=d) &#123;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s&gt;p) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=i-d+<span class="number">1</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s-(sum[j+d<span class="number">-1</span>]-sum[j<span class="number">-1</span>])&lt;=p) &#123;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) s-=a[l++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显， 被修改的长为$d$的区间内的数和越大越好，于是可以在用尺取法的过程中用单调队列维护单调递增的目前尺取的区间内长为$d$的区间和的区间左端点进行优化即可。</p><p>时间复杂度$O(n)$，AC。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>,l=<span class="number">1</span>,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ull p,a[N],sum[N],s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">if</span>(i&lt;=d) s+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q[head]=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">s+=a[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;sum[i]-sum[i-d]&gt;=sum[q[tail]]-sum[q[tail]-d]) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]-d+<span class="number">1</span>&lt;l) head++;</span><br><span class="line"><span class="keyword">while</span>(s-(sum[q[head]]-sum[q[head]-d])&gt;p) &#123;</span><br><span class="line">s-=a[l++];</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]-d+<span class="number">1</span>&lt;l) head++;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POI </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 线性动规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1613] 跑路</title>
      <link href="/is-zxy.github.io/2020/02/13/%5B%E6%B4%9B%E8%B0%B7P1613%5D-%E8%B7%91%E8%B7%AF/"/>
      <url>/is-zxy.github.io/2020/02/13/%5B%E6%B4%9B%E8%B0%B7P1613%5D-%E8%B7%91%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑$2^k$千米（$k$是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点$1$，公司为点$n$，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证$1$到$n$至少有一条路径。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$50\%$的数据满足最优解路径长度$&lt;=1000$；</p><p>$100\%$的数据满足$n&lt;=50，m&lt;=10000$，最优解路径长度$&lt;=maxlongint$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1613" target="_blank" rel="noopener">P1613 跑路</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读完题，我就想：这不就是求最短路二进制下$1$的个数吗？</p><p>严重的错误。</p><p>可以绕着一个环一直跑，跑出个长为$2^k$的路出来，这样路程虽长，但只需一秒。</p><p>于是先求出各个点之间是否有长为$2^k$的路，有的话将这两点之间距离变为$1$。</p><p>最后用Floyd跑个最短路即可。$(n\leq 50)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> to[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=N;l++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(to[i][j][l<span class="number">-1</span>]&amp;&amp;to[j][k][l<span class="number">-1</span>]) &#123;</span><br><span class="line">to[i][k][l]=<span class="number">1</span>;</span><br><span class="line">dis[i][k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">to[x][y][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dis[x][y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">Floyd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF57C] Array</title>
      <link href="/is-zxy.github.io/2020/02/13/%5BCF57C%5D-Array/"/>
      <url>/is-zxy.github.io/2020/02/13/%5BCF57C%5D-Array/</url>
      
        <content type="html"><![CDATA[<p>对于长度为$n$的数组$A$，$A$中只包含从$1$到$n$的整数（可重复）。如果$A$单调不上升或单调不下降，$A$就可称为美丽的。 找出在长度为$n$时，有几个美丽的$A$。 </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF57C" target="_blank" rel="noopener">CF57C Array</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$x_i$表示数组中数字$i$个个数，数字单调不下降的排在一起。</p><p>那么明显，$\sum_{i=1}^nx_i=n$的非负整数解的个数就是单调不下降的序列个数。</p><p>这就是组合数学基础了，可用插板法求出方案数为$C_{2n-1}^n$。</p><p>单调不下降的序列翻转一下就是个单调不上升的序列，那么单调不上升的序列的个数也为$C_{2n-1}^n$。</p><p>两者间的重复方案为整个序列中的所有数相同，即有$n$个。</p><p>故总个数为$2\times C_{2n-1}^n-n$</p><p>卢卡斯求下即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line">t=(t*t)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) t=(t*x)%p;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m=n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=(a*(n-i))%p;</span><br><span class="line">b=(b*(i+<span class="number">1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a*quickp(b,p<span class="number">-2</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (Laucs(n/p,m/p)*C(n%p,m%p))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*Laucs(<span class="number">2</span>*n<span class="number">-1</span>,n)-n)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢卡斯（Lucas）定理学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/11/%E5%8D%A2%E5%8D%A1%E6%96%AF%EF%BC%88Lucas%EF%BC%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/11/%E5%8D%A2%E5%8D%A1%E6%96%AF%EF%BC%88Lucas%EF%BC%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>卢卡斯（Lucas）定理可以用来求$C_n^m\ mod\ p$。</p><p>前置知识：乘法逆元。</p><a id="more"></a><h1 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h1><p>令$n=sp+q,m=tp+r,(q,r\le p)$，则有</p><script type="math/tex; mode=display">C_n^m=C_{sp+q}^{tp+r} \equiv C_s^t\times C_q^r(mod\ p)</script><hr><h1 id="简要证明"><a href="#简要证明" class="headerlink" title="简要证明"></a>简要证明</h1><p>定义</p><script type="math/tex; mode=display">n=sp+q,m=tp+r,(q,r\le p)</script><p>组合数定义</p><script type="math/tex; mode=display">C_n^m=\frac{n!}{m!(n-m)!}</script><p>于是易得</p><script type="math/tex; mode=display">C_p^d \equiv 0(mod\ p),d\in(0,p)\ ①</script><p>由二项式定理</p><script type="math/tex; mode=display">(x+y)^n=\sum_{i=0}^nC_n^ix^{n-i}y^i</script><p>于是</p><script type="math/tex; mode=display">(1+x)^n=(1+x)^{sp+q}=(1+x)^q\times[(1+x)^p]^s=(1+x)^q\times[\sum_{i=0}^pC_p^ix^i]^s</script><p>由式①，可得</p><script type="math/tex; mode=display">\begin{align}(1+x)^n &\equiv (1+x)^q\times[\sum_{i=0}^pC_p^ix^i]^s \\ &\equiv (1+x)^q\times (1+x^p)^s\ (mod\ p) \\ &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p)\end{align}</script><p>则</p><script type="math/tex; mode=display">\begin{align}(1+x)^{sp+q} &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p) \\\sum_{k=0}^{sp+q}C_{sp+q}^kx^k &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p) \\\end{align}</script><p>两边同时取$x^{sp+r}$项</p><script type="math/tex; mode=display">C_{sp+q}^{tp+r}x^{tp+r} \equiv C_q^rx^r\times C_{s}^{t}x^{tp}\ (mod\ p)</script><p>而$n=sp+q,m=tp+r,(q,r\le p)$，则</p><script type="math/tex; mode=display">\begin{align}C_n^mx^m &\equiv C_q^r\times C_s^tx^{tp+r}\ (mod\ p) \\&\equiv C_q^r\times C_s^tx^m\ (mod\ p)\end{align}</script><p>两边同时消去$x^m$，可得</p><script type="math/tex; mode=display">C_n^m \equiv C_q^r\times C_s^t\ (mod\ p)</script><p>于是得证。</p><hr><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>有了这个定理，于是我们可以递归求解$C_s^t\ mod\ p$，再用乘法逆元求出$C_q^r\ mod\ p$，两者相乘再$mod\ p$即可。</p><p>转化成一个更加易懂的形式，即</p><script type="math/tex; mode=display">s=\lfloor \frac{n}{p} \rfloor,t=\lfloor \frac{m}{p} \rfloor,q=n\ mod\ p,r=m\ mod\ p \\C_n^m \equiv C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times C_{n\ mod\ p}^{m\ mod\ p}\ (mod\ p)</script><p>定义$C_n^m \equiv Lucas(n,m)\ (mod\ p)$</p><p>则递归式为$Lucas(n,m) \equiv Lucas_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times C_{n\ mod\ p}^{m\ mod\ p}\ (mod\ p)$</p><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P3807-【模板】卢卡斯定理"><a href="#洛谷P3807-【模板】卢卡斯定理" class="headerlink" title="[洛谷P3807] 【模板】卢卡斯定理"></a>[洛谷P3807] 【模板】卢卡斯定理</h2><p>给定$n,m,p(1\le n,m,p\le 10^5)$</p><p>求$C_{n+m}^{m}\ mod\ p$</p><p>保证$P$为$prime$</p><p>$C$表示组合数。</p><p>一个测试点内包含多组数据。</p><!--more--><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3807" target="_blank" rel="noopener">P3807 【模板】卢卡斯定理</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥思路，套板子就好。</p><p>当然乘法逆元也可以用扩欧写。这里我只写了费马小定理的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m,p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickpow(x,y/<span class="number">2</span>);</span><br><span class="line">t=(t*t)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) t=(t*x)%p;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m=n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=(a*(n-i))%p;</span><br><span class="line">b=(b*(i+<span class="number">1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a*quickpow(b,p<span class="number">-2</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (Laucs(n/p,m/p)*C(n%p,m%p))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Laucs(n+m,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 乘法逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU3507] Print Article</title>
      <link href="/is-zxy.github.io/2020/02/10/%5BHDU3507%5D-Print-Article/"/>
      <url>/is-zxy.github.io/2020/02/10/%5BHDU3507%5D-Print-Article/</url>
      
        <content type="html"><![CDATA[<p>给定一个有$n$个数的序列$c$，每次从中取出$[l,r]$内的数的花费为$(\sum_{i=l}^rc[i])+m$，求将序列中所有数取出来的最小花费。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(0 ≤ n ≤ 500000, 0 ≤ M ≤ 1000)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">Print Article</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示前$i$个数已经被取出来的最小花费。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+(sum[i]-sum[j])^2+m\},j\in[0,i)</script><p>于是可得一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m,c[N],sum[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;c[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(sum[i]-sum[j])*(sum[i]-sum[j])+m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微化化</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-2\times sum[i]sum[j]+sum[j]^2\}+sum[i]^2+m</script><p>令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优，则</p><p>$dp[j]-2\times sum[i]sum[j]+sum[j]^2 \le dp[k]-2\times sum[i]sum[k]+sum[k]^2$</p><p>定义$ds[i]=dp[i]+sum[i]^2$，则</p><p>$ds[j]-2\times sum[i]sum[j] \le ds[k]-2\times sum[i]sum[k]$</p><p>$ds[j]-ds[k] \le 2\times sum<a href="sum[j]-sum[k]">i</a>$</p><p>明显$sum$递增，则</p><p>$\frac{ds[j]-ds[k]}{sum[j]-sum[k]} \le 2\times sum[i]$</p><p>明显可以斜率优化，下凸壳，单调队列维护即可，不多解释。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head,tail;</span><br><span class="line">ll m,c[N],sum[N],dp[N],ds[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;c[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">head=tail=<span class="number">1</span>;</span><br><span class="line">dp[<span class="number">0</span>]=q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;ds[q[head+<span class="number">1</span>]]-ds[q[head]]&lt;=<span class="number">2</span>*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i]=ds[q[head]]<span class="number">-2</span>*sum[i]*sum[q[head]]+sum[i]*sum[i]+m;</span><br><span class="line">ds[i]=dp[i]+sum[i]*sum[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(ds[q[tail]]-ds[q[tail<span class="number">-1</span>]])*(sum[i]-sum[q[tail]])&gt;=(ds[i]-ds[q[tail]])*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> HDU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/10/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/10/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><p>定义：若整数$b$，$p$互质，并且$b|a$，则存在一个整数$x$，使得$\frac{a}{b} \equiv ax(mod\ p)$。称$x$为$b$的模$p$乘法逆元，记为$b^{-1} (mod\ p)$。<br><a id="more"></a></p><hr><h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><p>那么该如何求出这个x呢?</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>由定义，$\frac{a}{b} \equiv ax(mod\ p)$</p><p>两边同时乘$\frac{b}{a}$，得$1 \equiv bx(mod\ p)$</p><p>则$bx \equiv 1(mod\ p)$</p><p>这个同余方程可以转化为不定方程$bx+py = 1$（假设$bx=-yp+1$），而$b$与$p$又互质，即$gcd(b,p)=1$，那么就可以用扩展欧几里得算法求出$x$。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>费马小定理：$a^p \equiv a(mod\ p)$   （$p$为质数）</p><p>若$p$为质数，则$b^p \equiv b(mod\ p)$</p><p>两边同时除以$b$，得$b^{p-1} \equiv 1(mod\ p)$，这个式子也可用欧拉定理推出。</p><p>两边同时乘$a$，得$a \equiv ab^{p-1} (mod\ p)$</p><p>两边同时除以b，得$\frac{a}{b} \equiv ab^{p-2} (mod\ p)$</p><p>由定义，此时$x=b^{p-2}$</p><p>则直接求出$b^{p-2}$即可，可用快速幂</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>$1^{-1} \equiv 1(mod\ p)$</p><p>设$p=k*i+r$,$r&lt;i$,$l&lt;i&lt;p$，将此式放到$mod\ p$意义下会得到：$ki+r \equiv 0(mod\ p)$</p><p>两边同时乘$i^{-1}$，$r^{-1}$，可得：</p><p>$k*r^{-1}+i^{-1} \equiv 0 (mod\ p)$</p><p>$i^{-1} \equiv -k*r^{-1} (mod\ p)$</p><p>$i^{-1} \equiv -[p/i]*(p\ mod\ i)^{-1} (mod\ p)$</p><p>由此，假设$A[i]$表示$i$的逆元，则$A[i]=-[p/i]*A[p\ mod\ i]$。</p><hr><h1 id="洛谷P3811-【模板】乘法逆元"><a href="#洛谷P3811-【模板】乘法逆元" class="headerlink" title="[洛谷P3811] 【模板】乘法逆元"></a>[洛谷P3811] 【模板】乘法逆元</h1><p> 给定$n,p$求$1\sim n$中所有整数在模$p$意义下的乘法逆元。 </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P3811" target="_blank" rel="noopener">P3811 【模板】乘法逆元</a></p><h2 id="代码（方法一）"><a href="#代码（方法一）" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h2><p>本题保证了$p$是质数，那么直接就可以用扩展欧几里得算法求出$ix+py=1$的最小正整数解x即可。$(1&lt;=i&lt;=n)$<br>（TLE，$48$分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(i,p);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((x%p)+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法二）"><a href="#代码（方法二）" class="headerlink" title="代码（方法二）"></a>代码（方法二）</h2><p>保证$p$是质数了，直接利用快速幂求出$i^{p-2}$即可，求的过程中注意取模p<br>（TLE，$48$分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t=quickpow(x,y/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(y%<span class="number">2</span>) <span class="keyword">return</span> (t*t*x)%p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (t*t)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;quickpow(i,p<span class="number">-2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法三）"><a href="#代码（方法三）" class="headerlink" title="代码（方法三）"></a>代码（方法三）</h2><p>初始化$A[1]=1$，然后递推求解即可<br>（AC）</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">3000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">a[i]=-(p/i)*a[p%i];</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>) a[i]=a[i]%p+p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="洛谷P2613-【模板】有理数取余"><a href="#洛谷P2613-【模板】有理数取余" class="headerlink" title="[洛谷P2613] 【模板】有理数取余"></a>[洛谷P2613] 【模板】有理数取余</h1><p>给出一个有理数$c=\frac{a}{b}$，求$c \bmod 19260817$的值。 </p><p>对于所有数据，$0\leq a,b \leq 10^{10001}$。 </p><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P2613" target="_blank" rel="noopener">P2613 【模板】有理数取余</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数据这么大，高精？</p><p>当然是不必要的。</p><p>对于一个分数取模，自然想到乘法逆元。</p><p>而恰好，$19260817$它是个<strong>质数</strong>。</p><p>因为求的只是一个数的逆元，所以将$a,b$都对$19260817$取模后，套上面的方法一和二即可。</p><p>注意特判$b=0$的情况。</p><h2 id="代码（方法一）-1"><a href="#代码（方法一）-1" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 19260817</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> sa,sb;</span><br><span class="line">ll a=<span class="number">0</span>,b=<span class="number">0</span>,la,lb,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sa;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sb;</span><br><span class="line"></span><br><span class="line">la=sa.size(),lb=sb.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;la;i++) a=(a*<span class="number">10</span>+(sa[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lb;i++) b=(b*<span class="number">10</span>+(sb[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Angry!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXgcd(b,p);</span><br><span class="line">x=(x%p+p)%p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(x*a)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法二）-1"><a href="#代码（方法二）-1" class="headerlink" title="代码（方法二）"></a>代码（方法二）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 19260817</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> sa,sb;</span><br><span class="line">ll a=<span class="number">0</span>,b=<span class="number">0</span>,la,lb;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickpow(x,k/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>) <span class="keyword">return</span> (((t*t)%p)*x)%p;</span><br><span class="line"><span class="keyword">return</span> (t*t)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sa;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sb;</span><br><span class="line"></span><br><span class="line">la=sa.size(),lb=sb.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;la;i++) a=(a*<span class="number">10</span>+(sa[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lb;i++) b=(b*<span class="number">10</span>+(sb[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Angry!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;(a*quickpow(b,p<span class="number">-2</span>))%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>乘法逆元的用处在哪呢？</p><p>当在题目中遇到了$\frac{a}{b}$这样的除法算式要求对$p$取模时，便可以根据$a,b,p$的性质，求出使得$\frac{a}{b} \equiv ax(mod\ p)$成立的$x$，这样就可以将原来不好取模的除法转化为好取模的乘法。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 乘法逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2009] HH的项链</title>
      <link href="/is-zxy.github.io/2020/02/09/%5BSDOI2009%5D-HH%E7%9A%84%E9%A1%B9%E9%93%BE/"/>
      <url>/is-zxy.github.io/2020/02/09/%5BSDOI2009%5D-HH%E7%9A%84%E9%A1%B9%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。</p><p>有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$1\le n,m\leq 5000$；<br>对于$40\%$的数据，$1\le n,m\leq 10^5$；<br>对于$60\%$的数据，$1\le n,m\leq 5\times 10^5$；<br>对于$100\%$的数据，$1\le n,m,a_i \leq 10^6$，$1\le l \le r \le n$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1972" target="_blank" rel="noopener">[SDOI2009]HH的项链</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>过于高级的数据结构方法我不会，只会一个离线的树状数组方法。</p><p>对于一段区间内相同类型的贝壳，肯定是看右面的。</p><p>将问题按照$r$递增排序。</p><p>于是用树状数组不断向后维护，当当前维护的贝壳种类在之前出现过时，删掉之前的那个，更新。</p><p>对于每一个问题从其上一个问题的$r$加$1$开始向后维护。</p><p>每次维护到第$i$个问题的$r_i$，维护完毕记录答案$ans_i=sum[r_i]-sum[l_i-1]$</p><p>最终按照序号输出$ans$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],m,c[N],next=<span class="number">1</span>,l[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.r==y.r) <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line"><span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(x;x&lt;=n;x+=lowbit(x)) c[x]+=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(x;x;x-=lowbit(x)) ans+=c[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].l,&amp;p[i].r);</span><br><span class="line">p[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">1</span>,p+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=next;j&lt;=p[i].r;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(l[q[j]]) update(l[q[j]],<span class="number">-1</span>);</span><br><span class="line">update(j,<span class="number">1</span>);</span><br><span class="line">l[q[j]]=j;</span><br><span class="line">&#125;</span><br><span class="line">next=p[i].r+<span class="number">1</span>;</span><br><span class="line">ans[p[i].id]=ask(p[i].r)-ask(p[i].l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P6040] 课后期末考试滑溜滑溜补习班</title>
      <link href="/is-zxy.github.io/2020/02/09/%5B%E6%B4%9B%E8%B0%B7P6040%5D-%E8%AF%BE%E5%90%8E%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E6%BB%91%E6%BA%9C%E6%BB%91%E6%BA%9C%E8%A1%A5%E4%B9%A0%E7%8F%AD/"/>
      <url>/is-zxy.github.io/2020/02/09/%5B%E6%B4%9B%E8%B0%B7P6040%5D-%E8%AF%BE%E5%90%8E%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E6%BB%91%E6%BA%9C%E6%BB%91%E6%BA%9C%E8%A1%A5%E4%B9%A0%E7%8F%AD/</url>
      
        <content type="html"><![CDATA[<p>在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。</p><p>补习班上有$n$个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第$i$个学生的问题有一个困难值$a_i$，杀老师回答第$i$个学生的问题需要花费$a_i$的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。</p><p>杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费$k$点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为$k+(q-p-1) \times d$（当前位置为$p$，跳到的位置为$q$）。</p><p>当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过$x-1$个学生，去解决下$x$个学生的问题。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100\%$的数据，$1 \leq n \leq 10^7$，$0 \leq k,d,a_i \leq 10^9$，$1 \leq x \leq n-1$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6040" target="_blank" rel="noopener">P6040 课后期末考试滑溜滑溜补习班</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示已经解决到底$i$个同学的花费的最小精力数。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+a[i]+k+d\times(i-j-1)\},j\in[max(1,i-x),i)</script><p>其中初始化$dp[1]=a[1]$。</p><p>于是可以得到一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,tp,Seed;</span><br><span class="line">ll k,d,dp[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">return</span> Seed = ( <span class="number">1L</span>L * Seed * <span class="number">0x66CCFF</span> % MOD + <span class="number">20120712</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;d&gt;&gt;x&gt;&gt;tp;</span><br><span class="line"><span class="keyword">if</span>(!tp) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Seed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=max(i-x,<span class="number">1</span>);j&lt;i;j++) &#123;</span><br><span class="line">dp[i]=min(dp[i],dp[j]+a[i]+k+(i-j<span class="number">-1</span>)*d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将式子中的常量项从$min$中提出来，则得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-d\times j\}+a[i]+k+d\times i-d,j\in[max(1,i-x),i)</script><p>于是便可以用单调队列维护$min$内的东西单调递增即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,tp,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll k,d,dp[N],a[N],Seed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">return</span> Seed = ( <span class="number">1L</span>L * Seed * <span class="number">0x66CCFF</span> % MOD + <span class="number">20120712</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;d&gt;&gt;x&gt;&gt;tp;</span><br><span class="line"><span class="keyword">if</span>(!tp) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Seed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>]=a[<span class="number">1</span>],q[head]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;q[head]&lt;max(<span class="number">1</span>,i-x)) head++;</span><br><span class="line">dp[i]=dp[q[head]]+a[i]+k+d*(i-q[head]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i]-d*i&lt;=dp[q[tail]]-d*q[tail]) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2010] 特别行动队</title>
      <link href="/is-zxy.github.io/2020/02/09/%5BAPIO2010%5D-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/"/>
      <url>/is-zxy.github.io/2020/02/09/%5BAPIO2010%5D-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>你有一支由$n$名预备役士兵组成的部队，士兵从$1$到$n$编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号<strong>应该连续</strong>，即为形如$(i, i + 1, \cdots i + k)$的序列。所有的队员都应该属于且仅属于一支特别行动队。</p><p>编号为$i$的士兵的初始战斗力为$x_i$，一支特别行动队的初始战斗力$X$为队内士兵初始战斗力之和，即$X = x_i + x_{i+1} + \cdots + x_{i+k}$。</p><p>通过长期的观察，你总结出对于一支初始战斗力为$X$的特别行动队，其修正战斗力$X’= aX^2+bX+c$，其中$a,b,c$是已知的系数$(a &lt; 0)$。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3628" target="_blank" rel="noopener">[APIO2010]特别行动队</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于<strong>同一支特别行动队中队员的编号应该连续</strong>，那么就比较好想了。</p><p>定义$dp[i]$表示前$i$名队员已经分属于各自的行动队，目前所有行动队的修正战斗力之和的最大值。</p><p>于是可以从$[0,i)$队员中枚举$j$，使得第$j+1$名队员到第$i$名队员属于一个行动队。</p><p>那么</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c\},c\in[0,i)</script><p>其中$sum$为$x$的前缀和。初始化$dp[0]=0$，其余均为一个极小的负值。</p><p>于是可以得到一个$O(n^2)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a,b,c,x[N],sum[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll X=(sum[i]-sum[j]);</span><br><span class="line">dp[i]=max(dp[i],dp[j]+a*X*X+b*X+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$max$内的式子单独提出来看看</p><p>$dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c$</p><p>$=dp[j]+a(sum[i]^2-2sum[i]sum[j]+sum[j]^2)+b(sum[i]-sum[j])+c$</p><p>$=dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]+a\times sum[i]^2+b\times sum[i]+c$</p><p>剔除掉求状态$i$时的常量项，则为</p><p>$dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]$</p><p>定义$f[i]=a\times sum[i]^2-b\times sum[i]$，则原式可化为</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j]$</p><p>则</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]+f[j]-2a\times sum[i]sum[j]\}+a\times sum[i]^2+b\times sum[i]+c</script><p>将$max$内提出来</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j]$，发现$sum[j]$这一项，其系数为常量。</p><p>于是该式子可以看做一斜率为$2a\times sum[i]$的过点$(sum[j],dp[j]+f[j])$的直线与$y$轴的截距，于是定义决策点$i(sum[i],dp[i]+f[i])$。</p><p>那么问题就转化为求一个最大的截距，于是需要维护一个上凸壳。</p><p>明显$sum$具有单调性。</p><p>于是令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j] \ge dp[k]+f[k]-2a\times sum[i]sum[k] $</p><p>$dp[j]+f[j]-(dp[k]+f[k]) \ge 2a\times sum[i]\times (sum[j]-sum[k])$</p><p>因为$j&gt;k$且$sum$单调递增，则</p><p>$\frac{dp[j]+f[j]-(dp[k]+f[k])}{sum[j]-sum[k]}\ge 2a\times sum[i]$ 式①</p><p>而若要维护上凸壳，则其具有上凸性，即满足$j_1&lt;j_2&lt;j_3$，则决策点$j_1$与$j_2$之间连线段的斜率大于决策点$j_2$与$j_3$之间的斜率，即</p><p>$\frac{dp[j_2]+f[j_2]-(dp[j_1]+f[j_2])}{sum[j_2]-sum[j_1]}&gt;\frac{dp[j_3]+f[j_3]-(dp[j_2]+f[j_2])}{sum[j_3]-sum[j_2]}$ 式②</p><p>于是用单调队列维护上凸壳，用式①保持队头为最优决策点，用式②维护上凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll a,b,c,x[N],sum[N],dp[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">f[i]=a*sum[i]*sum[i]-b*sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]]+f[q[head+<span class="number">1</span>]]-dp[q[head]]-f[q[head]]&gt;=<span class="number">2</span>*a*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i]=dp[q[head]]+f[q[head]]<span class="number">-2</span>*a*sum[i]*sum[q[head]]+a*sum[i]*sum[i]+b*sum[i]+c;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]+f[q[tail]]-dp[q[tail<span class="number">-1</span>]]-f[q[tail<span class="number">-1</span>]])*(sum[i]-sum[q[tail]])&lt;=(dp[i]+f[i]-dp[q[tail]]-f[q[tail]])*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APIO </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2007] 仓库建设</title>
      <link href="/is-zxy.github.io/2020/02/08/%5BZJOI2007%5D-%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/"/>
      <url>/is-zxy.github.io/2020/02/08/%5BZJOI2007%5D-%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<p>L 公司有$n$个工厂，由高到低分布在一座山上，工厂$1$在山顶，工厂$n$在山脚。</p><p>由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L 公司的总裁 L 先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是 L 先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。</p><p>由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 i<em>i</em> 个工厂目前已有成品$p_i$件，在第$i$个工厂位置建立仓库的费用是$c_i$。</p><p>对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 L 公司产品的对外销售处设置在山脚的工厂$n$，故产品只能往山下运（即<strong>只能运往编号更大的工厂的仓库</strong>），当然运送产品也是需要费用的，一件产品运送一个单位距离的费用是$1$。</p><p>假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p><ul><li>工厂$i$距离工厂$1$的距离$x_i$（其中$x_1=0$）。</li><li>工厂$i$目前已有成品数量$p_i$。</li><li>在工厂$i$建立仓库的费用$c_i$。</li></ul><p>请你帮助 L 公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 20\%$的数据，保证$ n \leq 500$。</p><p>对于$ 40\%$的数据，保证$ n \leq 10^4$。</p><p>对于$ 100\%$的数据，保证$ 1 \leq n \leq 10^6$，$0 \leq x_i,~p_i,~c_i &lt; 2^{31}$。</p><p>对于任意的$ 1 \leq i &lt; n$，保证$ x_i &lt; x_{i + 1}$。</p><p>设答案为$ans$，保证$ ans + \sum\limits_{i = 1}^{n} p_ix_i &lt; 2^{63}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2120" target="_blank" rel="noopener">[ZJOI2007]仓库建设</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示在工厂$i$建立仓库，并且前$i$个工厂的成品均被送往仓库的最小费用值。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+\sum_{k=j+1}^{i-1}[(x[i]-x[k])\times p[k]]\},j\in[0,i)</script><p>于是便可以得到一个$O(n^3)$的及其暴力的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll x[N],p[N],c[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;i;k++) t+=(x[i]-x[k])*p[k];</span><br><span class="line">dp[i]=min(dp[i],dp[j]+t+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$min$内的式子单独拿出来看看</p><p>$dp[j]+c[i]+\sum_{k=j+1}^{i-1}[(x[i]-x[k])\times p[k]]$</p><p>$=dp[j]+c[i]+\sum_{k=j+1}^{i-1}(x[i]\times p[k])-\sum_{k=j+1}^{i-1}(x[k]\times p[k])$</p><p>$=dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}(x[k]\times p[k])$</p><p>定义$f[i]=x[i]\times p[i]$，则原式又可化为</p><p>$dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}f[k]$</p><p>于是状转方程便变为</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}f[k]\},j\in[0,i)</script><p>即</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+x[i]\times(sump[i-1]-sump[j])-(sumf[i-1]-sumf[j])\},j\in[0,i)</script><p>其中$sump$表示$p$的前缀和，$sumf$表示$f$的前缀和。</p><p>则又可以得到一个$O(n^2)$的稍微优化一点的算法，当然，还是TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll x[N],p[N],c[N],dp[N],sump[N],sumf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">sump[i]=sump[i<span class="number">-1</span>]+p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+c[i]+x[i]*(sump[i<span class="number">-1</span>]-sump[j])-(sumf[i<span class="number">-1</span>]-sumf[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将$min$内的式子提出来看看</p><p>$dp[j]+c[i]+x[i]\times(sump[i-1]-sump[j])-(sumf[i-1]-sumf[j])$</p><p>$=dp[j]-x[i]\times sump[j]+sumf[j]+c[i]+x[i]\times sump[i-1]-sumf[i-1]$</p><p>令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]-x[i]\times sump[j]+sumf[j]\le dp[k]-x[i]\times sump[k]+sumf[k]$</p><p>令$ds[i]=dp[i]+sumf[i]$，则又可化为</p><p>$ds[j]-x[i]\times sump[j]\le ds[k]-x[i]\times sump[k]$</p><p>$x[i]\times (sump[k]-sump[j])\le ds[k]-ds[j]$</p><p>而$sump$一定是不下降的，且$k&lt;j$，则（此处排除$sump[k]-sump[j]$的情况，因为实际操作时可用乘法。）</p><p>$x[i]\ge \frac{ds[k]-ds[j]}{sump[k]-sump[j]}$</p><p>定义决策点$q$点坐标为$(sump[q],ds[q])$且斜率有斜率为$x[i]$的直线过$q$点，则该直线与$y$轴交点即为$ds[q]-sump[q]\times x[i]$，即为$min$内的非常量项。</p><p>则可看成量决策点$k(sump[k],ds[k])$，$j(sump[j],ds[j])$，若两点的连线段的斜率小于等于$x[i]$，则转移决策$j$比转移决策$k$更优。</p><p>因为求的是$min$，则为斜率为$x[i]$的过决策点直线在$y$轴的最小截距。则要维护一个下凸壳，由于$sump$与$x$具有单调性，则用单调队列维护下凸性，若队头并非最优决策点则弹出，最后用队头作为被转移的决策点即可。</p><p>那么现在剩余的问题只剩下凸壳的维护。因为具有下凸性，所以对于$j_1&lt;j_2&lt;j_3$，决策点$j_1$与$j_2$之间连线段的斜率要小于决策点$j_2$与$j_3$之间连线段的斜率，即</p><script type="math/tex; mode=display">\frac{ds[j_2]-ds[j_1]}{sump[j_2]-sump[j_1]}<\frac{ds[j_3]-ds[j_2]}{sump[j_3]-sump[j_2]}</script><p>则据此维护凸壳即可。</p><p>状转方程</p><script type="math/tex; mode=display">dp[i]=min\{ds[j]-x[i]\times sump[j]\}+c[i]+x[i]\times sump[i-1]-sumf[i-1]</script><p>每个决策点入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll x[N],p[N],c[N],dp[N],sump[N],sumf[N],ds[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">sump[i]=sump[i<span class="number">-1</span>]+p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;x[i]*(sump[q[head]]-sump[q[head+<span class="number">1</span>]])&lt;=ds[q[head]]-ds[q[head+<span class="number">1</span>]]) head++;</span><br><span class="line">dp[i]=ds[q[head]]-x[i]*sump[q[head]]+c[i]+x[i]*sump[i<span class="number">-1</span>]-sumf[i<span class="number">-1</span>];</span><br><span class="line">ds[i]=dp[i]+sumf[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(ds[q[tail]]-ds[q[tail<span class="number">-1</span>]])*(sump[i]-sump[q[tail]])&gt;=(ds[i]-ds[q[tail]])*(sump[q[tail]]-sump[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> ZJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HNOI2008] 玩具装箱TOY</title>
      <link href="/is-zxy.github.io/2020/02/07/%5BHNOI2008%5D-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/"/>
      <url>/is-zxy.github.io/2020/02/07/%5BHNOI2008%5D-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/</url>
      
        <content type="html"><![CDATA[<p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为$1 \cdots n$的$n$件玩具，第$i$件玩具经过压缩后的一维长度为$C_i$。</p><p>为了方便整理，P教授要求：</p><ul><li>在一个一维容器中的玩具编号是连续的。</li><li>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为$x=j-i+\sum\limits_{k=i}^{j}C_k$。</li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$x$，其制作费用为$(x-L)^2$。其中$L$是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望所有容器的总费用最小。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">[HNOI2008]玩具装箱TOY</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示压缩完前$i$个玩具的最小费用。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+[i-(j+1)+sum[i]-sum[j]-L]^2\},j\in[0,i)</script><p>于是可以得到一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll c[N],sum[N],L,dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j<span class="number">-1</span>+sum[i]-sum[j]-L)*(i-j<span class="number">-1</span>+sum[i]-sum[j]-L));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>铁定TLE。</p><p>将这个式子单独提出来看看</p><script type="math/tex; mode=display">dp[j]+[i-(j+1)+sum[i]-sum[j]-L]^2</script><p>发现，其实再此过程中我们还可以维护的是$sum[i]+i$，遍定义$f[i]=sum[i]+i$，于是此式又可化为</p><script type="math/tex; mode=display">dp[j]+[f[i]-f[j]-1-L]^2</script><p>瞬间清爽不少。</p><p>考虑决策更优性，令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]+[f[i]-f[j]-1-L]^2\le dp[k]+[f[i]-f[k]-1-L]^2$</p><p>$dp[j]+f[i]^2-2(f[j]+1+L)f[i]+(f[j]+1+L)^2\le dp[k]+f[i]^2-2(f[k]+1+L)f[i]+(f[k]+1+L)^2$</p><p>$dp[j]-2(f[j]+1+L)f[i]+(f[j]+1+L)^2\le dp[k]-2(f[k]+1+L)f[i]+(f[k]+1+L)^2$</p><p>$2(f[k]+1+L)f[i]-2(f[j]+1+L)f[i]\le dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]$</p><p>$2(f[k]-f[j])f[i]\le dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]$</p><p>而$f$肯定是单调递增的，则</p><p>$2f[i]\ge \frac{dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]}{f[k]-f[j]}$</p><p>方便理解，再进一步化化，令$p[i]=(f[i]+1+L)^2$，则</p><p>$2f[i]\ge \frac{dp[k]+p[k]-(dp[j]+p[j])}{f[k]-f[j]}$</p><p>不等式右面的形式像什么？斜率的求法。</p><p>于是看成两个点，$k(f[k],dp[k]+p[k])$与$j(f[j],dp[j]+p[j])$，这两点的连线段斜率即为不等式右面。</p><p>则说明，相邻的两个决策点$j,k$，$k&lt;j$，若两点连线段的斜率小于$2f[i]$，则转移决策点$j$比转移决策点$k$更优。</p><p>每个决策点都有一个斜率为$2f[i]$的直线穿过，可得此直线与$y$轴交点即为$(0,dp[k]+p[k]-2f[i]p[k])$（以决策点$k$举例）。</p><p>而这个纵坐标就是$min$内的非常量项。</p><p>求的是最小的，则显然是下凸壳的顶点，这样与$y$轴交点才能尽可能小。</p><p>因此我们需要维护这个下凸壳。</p><p>令$j_1&lt;j_2&lt;j_3$，若要满足下凸性，则决策点$j_1$与$j_2$的连线段的斜率要小于决策点$j_2$与决策点$j_3$的斜率，即</p><p>$\frac{dp[j_2]+p[j_2]-(dp[j_1]+p[j_1])}{f[j_2]-f[j_1]}&lt;\frac{dp[j_3]+p[j_3]-(dp[j_2]+p[j_2])}{f[j_3]-f[j_2]}$</p><p>据此用单调队列维护凸壳即可。</p><p>每次再用$2f[i]\ge \frac{dp[k]+p[k]-(dp[j]+p[j])}{f[k]-f[j]}$不断弹出队头，直至队头为最优决策点，然后直接用队头进行转移即可。</p><p>每个决策点只会入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll c[N],sum[N],f[N],L,dp[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">f[i]=sum[i]+i;</span><br><span class="line">p[i]=(f[i]+<span class="number">1</span>+L)*(f[i]+<span class="number">1</span>+L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,p[<span class="number">0</span>]=(<span class="number">1</span>+L)*(<span class="number">1</span>+L);</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="number">2</span>*f[i]*(f[q[head]]-f[q[head+<span class="number">1</span>]])&lt;=dp[q[head]]+p[q[head]]-dp[q[head+<span class="number">1</span>]]-p[q[head+<span class="number">1</span>]]) head++;</span><br><span class="line">dp[i]=dp[q[head]]+(f[i]-<span class="built_in">sqrt</span>(p[q[head]]))*(f[i]-<span class="built_in">sqrt</span>(p[q[head]]));</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]+p[q[tail]]-dp[q[tail<span class="number">-1</span>]]-p[q[tail<span class="number">-1</span>]])*(f[i]-f[q[tail]])&gt;=(dp[i]+p[i]-dp[q[tail]]-p[q[tail]])*(f[q[tail]]-f[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> HNOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2365] 任务安排/[SDOI2012] 任务安排</title>
      <link href="/is-zxy.github.io/2020/02/06/%5B%E6%B4%9B%E8%B0%B7P2365%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%20%5BSDOI2012%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/"/>
      <url>/is-zxy.github.io/2020/02/06/%5B%E6%B4%9B%E8%B0%B7P2365%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%20%5BSDOI2012%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h2 id="洛谷P2365-任务安排"><a href="#洛谷P2365-任务安排" class="headerlink" title="[洛谷P2365] 任务安排"></a>[洛谷P2365] 任务安排</h2><p>$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。</p><p>从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。</p><p>每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。</p><p> 对于$100\%$的数据，$1\le n\le5000$，$0 \le s\le50$，$1\le t_i,f_i \le 100$。 </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2365" target="_blank" rel="noopener">P2365 任务安排</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][j]$表示前$i$个任务被分为$j$批的最小费用值。</p><p>定义$sumt[i]$表示$t$的前缀和，$sumf[i]$表示$f$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=min\{dp[k][j-1]+(sumt[i]+s\times j)(sumf[i]-sumf[k])\},k\in[0,i)</script><p>初始化$dp[0][0]=0$，其余均为一个极大值。</p><p>于是便可以照这个写出一个$O(n^3)$的TLE代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,t[N],f[N],sumt[N],sumf[N],dp[N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">ans=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[i][j],dp[k][j<span class="number">-1</span>]+(sumt[i]+s*j)*(sumf[i]-sumf[k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=min(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察式子，发现$j$的作用仅是为了计算此前个过程中的启动时间和，但事实上，既然这个时间要乘上此后的所有$f$，不如提前加入其中。因为若分完前$j$个任务后，要等待$s$秒，则后续费用一定会加上$(sumf[n]-sumf[j])\times s$，于是可以提前加进去，这样dp数组可以省去一维，状转方程变为</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+sumt[i]\times (sumf[i]-sumf[j])+s\times (sumf[n]-sumf[j])\},j\in[0,i)</script><p>这样又可以写出一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,t[N],f[N],sumt[N],sumf[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+sumt[i]*(sumf[i]-sumf[j])+s*(sumf[n]-sumf[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再整理，可得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-(sumt[i]+s)\times sumf[j]\}+sumt[i]\times sumf[i]+s\times sumf[n],j\in[0,i)</script><p>对于每一个$i$，$min$外都是常量。</p><p>观察$min$内的式子：$dp[j]-(sumt[i]+s)\times sumf[j]$，令$k=sumt[i]+s$，则原式变为$-k\times sumf[j]+dp[j]$。</p><p>这个形式像什么？一次函数。</p><p>将其看做一条斜率为$k$，且过点$(sumf[j],dp[j])$的直线。</p><p>那么其与$y$轴交点即为$(0,dp[j]-k\times sumf[j])$</p><p>这是什么？这就是$min$内的东西。则问题就转化为找最小的截距。</p><p>则对于每个$sumf[j],dp[j],j\in[0,i)$过点$(sumf[j],dp[j])$的直线，最小的截距明显就是下凸壳的顶点。</p><p>令$k&lt;j&lt;i$，如果转移$j$比转移$k$要更优的话，则</p><p>$dp[j]-(sumt[i]+s)\times sumf[j]&lt;dp[k]-(sumt[i]+s)\times sumf[k]$</p><p>$dp[j]-dp[k]&lt;(sumt[i]+s)(sumf[j]-sumf[k])$</p><p>$∵j&gt;k$</p><p>$∴sumf[j]-sumf[k]&gt;0$</p><p>$∴\frac{dp[j]-dp[k]}{sumf[j]-sumf[k]}&lt;sumt[i]+s$</p><p>则相邻两点$j,k,k&lt;j$，若$j$与$k$的连线段的斜率小于$sumt[i]+s$的话，那么$k$不需要了。</p><p>令$j_1&lt;j_2&lt;j_3$，若$j_2$有可能成为最优决策，则其满足下凸性，$j_1$与$j_2$连成线段的斜率要小于$j_2$与$j_3$连成线段的斜率。</p><p>即$\frac{dp[j_2]-dp[j_1]}{sumf[j_2]-sumf[j_1]}&lt;\frac{dp[j_3]-dp[j_2]}{sumf[j_3]-sumf[j_2]}$。</p><p>便可以以此建立单调队列，维护这个下凸壳。</p><p>队头与队头后一个的连线段的斜率小于$sumt[i]+s$的话则直接弹出，因为$sumt[i]+s$具有单调性。队尾在加入$i$后不符合下凸性则弹出队尾，然后将$i$加入队尾。每次状态转移直接用队头即可。</p><p>每个元素只入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,f[N],t[N],sumf[N],sumt[N],dp[N],q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]]-dp[q[head]]&lt;=(sumt[i]+s)*(sumf[q[head+<span class="number">1</span>]]-sumf[q[head]])) head++;</span><br><span class="line">dp[i]=dp[q[head]]-(sumt[i]+s)*sumf[q[head]]+sumt[i]*sumf[i]+s*sumf[n];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]-dp[q[tail<span class="number">-1</span>]])*(sumf[i]-sumf[q[tail]])&gt;=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDOI2012-任务安排"><a href="#SDOI2012-任务安排" class="headerlink" title="[SDOI2012] 任务安排"></a>[SDOI2012] 任务安排</h2><p>$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。</p><p>从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。</p><p>每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。</p><p> 对于$100\%$的数据，$1\le n\le3\times 10^5$，$0 \le s\le2^8$，$|t_i|\le 2^8$，$0\le f_i\le2^8$。</p><!--more--><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5785" target="_blank" rel="noopener">[SDOI2012]任务安排</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题与之前的那道任务安排不同在于数据量增大了，且$t$的值可能为负的。</p><p>因此上面的$O(n^3)$与$O(n^2)$的方法都过不了。</p><p>斜率优化？</p><p>而因为$t$值可能为负，所以$sumt[i]+s$不再具有单调性，那么上面的保存相邻两点连线段斜率大于$sumt[i]+s$的方法便不再适用。</p><p>因此不能弹出队头，而是要维护整个凸壳。所维护的凸壳具有下凸性，因此最优的决策点一定是左侧的线段斜率小于$sumt[i]+s$，右侧的线段斜率大于$sumt[i]+s$，所以便可以用二分查找，来寻找这个最优的决策点。</p><p>队尾的操作维护下凸性与上题相同，保持不变即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,head=<span class="number">1</span>,tail=<span class="number">1</span>,q[N];</span><br><span class="line">ll f[N],t[N],sumf[N],sumt[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==tail) <span class="keyword">return</span> q[head];</span><br><span class="line"><span class="keyword">int</span> l=head,r=tail;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[q[mid+<span class="number">1</span>]]-dp[q[mid]]&lt;=(sumt[i]+s)*(sumf[q[mid+<span class="number">1</span>]]-sumf[q[mid]])) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> q[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p=binary_search(i);</span><br><span class="line">dp[i]=dp[p]-(sumt[i]+s)*sumf[p]+sumt[i]*sumf[i]+s*sumf[n];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]-dp[q[tail<span class="number">-1</span>]])*(sumf[i]-sumf[q[tail]])&gt;=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2014] PTA-Little Bird</title>
      <link href="/is-zxy.github.io/2020/02/06/%5BPOI2014%5D-PTA-Little-Bird/"/>
      <url>/is-zxy.github.io/2020/02/06/%5BPOI2014%5D-PTA-Little-Bird/</url>
      
        <content type="html"><![CDATA[<p>有$n$棵树，每棵树都有其高度。</p><p>有$q$只鸟，每只鸟从第一棵树开始跳，跳到比其矮的树不耗费体力，反之则耗费$1$点体力。</p><p>每只鸟$i$都有其最多能跳跃的树的棵树$k_i$，即鸟$i$在树$j$上时可以跳到第$[i+1,i+k_i]$中任意一棵树上。</p><p>求每只鸟耗费的最少体力。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(2\le n\le 1\ 000\ 000)$ </p><p>$(1\le d_i\le 10^9)$</p><p>$(1\le q\le 25)$</p><p>$ (1\le k_i\le n-1)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3572" target="_blank" rel="noopener">[POI2014]PTA-Little Bird</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示到第$i$棵树上的最少体力。</p><p>明显</p><script type="math/tex; mode=display">dp[i]=min\{a[i]<a[j]?dp[j]:dp[j]+1\},j\in[max(1,i-k),i-1]</script><p>直接写$O(nqk)$是超时的（此处$k=\sum_{i=1}^qk_i$)。</p><p>但是明显能单调队列优化。</p><p>当一棵树$i$与另一棵树$j$，$i&gt;j$，$a[i]&gt;a[j]$且$dp[i]=dp[j]$，那么第$i$棵树肯定是比第$j$棵树要优的。</p><p>于是维护一个单调递增的单调队列，每次状转用队头即可。</p><p>本题卡STL，数组模拟deque可以过。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],q,dp[N];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q) &#123;</span><br><span class="line">q--;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k); </span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">que.clear();</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!que.empty()&amp;&amp;((a[i<span class="number">-1</span>]&gt;=a[que.back()]&amp;&amp;dp[i<span class="number">-1</span>]==dp[que.back()])||dp[i<span class="number">-1</span>]&lt;dp[que.back()])) que.pop_back();</span><br><span class="line">que.push_back(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty()&amp;&amp;que.front()&lt;max(i-k,<span class="number">1</span>)||que.front()&gt;i<span class="number">-1</span>) que.pop_front();</span><br><span class="line">dp[i]=(a[que.front()]&gt;a[i])?dp[que.front()]:dp[que.front()]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POI </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P5858] 「SWTR-03」Golden Sword</title>
      <link href="/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P5858%5D-%E3%80%8CSWTR-03%E3%80%8DGolden-Sword/"/>
      <url>/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P5858%5D-%E3%80%8CSWTR-03%E3%80%8DGolden-Sword/</url>
      
        <content type="html"><![CDATA[<p>制造一把金宝剑需要$n$种原料，编号为$1$到$n$，编号为$i$的原料的坚固值为$a_i$。</p><p>炼金是很讲究放入原料的顺序的，因此小$E$必须按照$1$到$n$的顺序依次将这些原料放入炼金锅。</p><p>但是，炼金锅的容量非常有限，它最多只能容纳$w$个原料。</p><p>所幸的是，每放入一个原料之前，小$E$可以从中取出一些原料，数量不能超过$s$个。</p><ul><li>我们定义第$i$种原料的耐久度为：放入第$i$种原料时锅内的原料总数$\times a_i$，则宝剑的耐久度为<strong>所有原料</strong>的耐久度之和。</li></ul><p>小$E$当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。</p><p>注：这里的”放入第$i$种原料时锅内的原料总数“<strong>包括正在放入锅中的原料</strong>，详细信息请见样例。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5858" target="_blank" rel="noopener">P5858 「SWTR-03」Golden Sword</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][j]$表示放入第$i$中原料时<strong>锅内的原料总数</strong>有$j$种的最大耐久值。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=max\{d[i-1][k]+a[i]\times j\},k\in[j-1,min(j+s-1,w)]</script><p>于是可得一个$O(nws)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,s;</span><br><span class="line">ll a[N],dp[N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">ans=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(i,w);j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&lt;=min(j+s<span class="number">-1</span>,w);k++) dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][k]+a[i]*j);</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=max(dp[i][j],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状转方程可以将$a[i]\times j$提出来，即</p><script type="math/tex; mode=display">dp[i][j]=max\{d[i-1][k]\}+a[i]\times j,k\in[j-1,min(j+s-1,w)]</script><p>于是便可以用单调队列优化了。</p><p>但细节较多，且$i=1$的情况需特判。</p><p>时间复杂度$O(nw)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,s;</span><br><span class="line">ll a[N],dp[N][N],ans=LONG_LONG_MIN;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">q.clear();</span><br><span class="line"><span class="keyword">if</span>(i&gt;w) q.push_back(w);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=min(i,w);j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">1</span>&amp;&amp;!q.empty()&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;=dp[i<span class="number">-1</span>][q.back()]) q.pop_back();</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>) q.push_back(j<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;(q.front()&lt;j<span class="number">-1</span>||q.front()&gt;min(j+s<span class="number">-1</span>,w))) q.pop_front();</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][q.front()]+a[i]*j;</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=max(ans,dp[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2627] 修剪草坪/[洛谷2034] 选择数字</title>
      <link href="/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P2627%5D-%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA-%5B%E6%B4%9B%E8%B0%B72034%5D-%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%97/"/>
      <url>/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P2627%5D-%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA-%5B%E6%B4%9B%E8%B0%B72034%5D-%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>给定一行$n$个非负整数$a[1]..a[n]$。现在你可以选择其中若干个数，但不能有超过$k$个连续的数字被选择。你的任务是使得选出的数字的和最大。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1 &lt;= N &lt;= 100,000) $</p><p>$ (0 &lt;= a_i &lt;= 1,000,000,000) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2627" target="_blank" rel="noopener">P2627 修剪草坪</a></p><p><a href="https://www.luogu.com.cn/problem/P2034" target="_blank" rel="noopener">P2034 选择数字</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][pos]$，当$pos$等于$0$时表示$a[i]$不选时前$i$个数的最大和，当$pos$等于$1$时表示$a[i]$选时前$i$个数的最大和。</p><p>对于第$i$个数，可以从$[i-k,i-1]$中枚举断点$j$，即$j$不选。</p><p>则易得</p><script type="math/tex; mode=display">dp[i][pos]=\left\{\begin{aligned}max(dp[i-1][0],dp[i-1][1])\ \  && pos=0 \\max\{dp[j]+sum[i]-sum[j]\} && pos=1 \\\end{aligned}\right.</script><p>而在过程中$sum[i]$为定值，所以可以提出来</p><script type="math/tex; mode=display">dp[i][pos]=\left\{\begin{aligned}max(dp[i-1][0],dp[i-1][1])\ \  && pos=0 \\max\{dp[j]-sum[j]\}-sum[i] && pos=1 \\\end{aligned}\right.</script><p>因此可以用维护一个递减的$dp[j]-sum[j]$单调队列，每次转移状态直接用队头减$sum[i]$即可。</p><p>当然，线段树也是可以的，但不是目前学习的重点，此处不再赘述。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll a[N],dp[N][<span class="number">2</span>],sum[N];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(q.empty()) &#123;</span><br><span class="line">q.push_back(i<span class="number">-1</span>);</span><br><span class="line">dp[i][<span class="number">1</span>]=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;q.front()&lt;i-k) q.pop_front();</span><br><span class="line">dp[i][<span class="number">1</span>]=dp[q.front()][<span class="number">0</span>]-sum[q.front()]+sum[i];</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;dp[i][<span class="number">0</span>]-sum[i]&gt;dp[q.back()][<span class="number">0</span>]-sum[q.back()]) q.pop_back();</span><br><span class="line">q.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max(dp[n][<span class="number">0</span>],dp[n][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2422] 良好的感觉</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P2422%5D-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%84%9F%E8%A7%89/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P2422%5D-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%84%9F%E8%A7%89/</url>
      
        <content type="html"><![CDATA[<p>kkk做了一个人体感觉分析器。每一天，人都有一个感受值$A_i$，$A_i$越大，表示人感觉越舒适。在一段时间$[i, j]$内，人的舒适程度定义为$[i, j]$中最不舒服的那一天的感受值$*[i, j]$中每一天感受值的和。现在给出kkk在连续$N$天中的感受值，请问，在哪一段时间，kkk感觉最舒适？ </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1&lt;=N&lt;=100$</p><p>对于$70\%$的数据，$1&lt;=N&lt;=2000$</p><p>对于$100\%$的数据，$1&lt;=N&lt;=100000$，$1&lt;=感受值&lt;=1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2422" target="_blank" rel="noopener">P2422 良好的感觉</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>标签是单调队列，然而正规来讲应该是单调栈。</p><p>定义$f[i]$表示$a[i]$为最小感受值得最大舒适程度。</p><p>易得$f[i]=(sum[r_i]-sum[l_i])*a[i]$。</p><p>其中$r_i$表示$a[i]$右面第一个比$a[i]$小的数的下标，$l_i$同理。</p><p>并没有什么前置要求，因此是个单向操作，于是就不需要用双端队列（单调队列）了，单调栈即可。</p><p>维护一个单调递增的单调栈，栈顶为最小值，当入栈的数$i$比栈顶$j$小时，说明$i$就是$j$右面的第一个比$j$小的数，$j$左面的第一个比$j$小的数即为栈顶下面的数；若栈只有一层，则$j$为当前所有入过栈元素的最小值。维护答案，$j$弹出栈顶，$i$入栈。</p><p>当每个元素都操作后，需要再次检验栈是否为空，若不为空，则再次进行上述操作，直至栈为空。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;a[i]&lt;a[s.top()]) &#123;</span><br><span class="line">ll p=a[s.top()],t;</span><br><span class="line">s.pop();</span><br><span class="line">t=s.empty()?<span class="number">0</span>:s.top();</span><br><span class="line">ans=max(ans,(sum[i<span class="number">-1</span>]-sum[t])*p);</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">ll p=a[s.top()],t;</span><br><span class="line">s.pop();</span><br><span class="line">t=s.empty()?<span class="number">0</span>:s.top();</span><br><span class="line">ans=max(ans,(sum[n]-sum[t])*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1725] 琪露诺</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1725%5D-%E7%90%AA%E9%9C%B2%E8%AF%BA/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1725%5D-%E7%90%AA%E9%9C%B2%E8%AF%BA/</url>
      
        <content type="html"><![CDATA[<p>给定一长度为 $n+1$的数列$A$, 第$1$项为$0$。<br>以第一项为起点 , 对于当前的位置$i$<br>可以转移到：$(i+l,i+r)$中任意一位置<br>并且获得当前位置上 数的价值 .</p><p>求 : 当位置$≥n+1$时可以取得的 最大价值和</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$60\%$的数据：$N &lt;= 10,000$</p><p>对于$100\%$的数据：$N &lt;= 200,000$</p><p>对于所有数据$-1,000 &lt;= A[i] &lt;= 1,000$且$1 &lt;= L &lt;= R &lt;= N$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1725" target="_blank" rel="noopener">P1725 琪露诺</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大概交了个二三十遍，彻底自闭。</p><p>定义$dp[i]$表示到达位置$i$所得到的的最大的价值，易得</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]\}+a[i]</script><p>其中$j\in[i-l,i-j]$</p><p>所以$[1,l)$内的位置都是无法走到的，于是从$l$开始。</p><p>这个RMQ其实也可以用树状数组、线段树、ST表啥的来求。这里不再赘述。</p><p>明显，具有单调性，可用单调队列优化。于是从$l$开始每次将$i-l$入队，然后不符合要求的出队，过程中要保证队列不为空。然后直接用$dp[i]$加上队头和本处的价值，若此时队列为空则continue。</p><p>交了二三十遍的原因就在于刚开始时我先转移状态再入队$i-l$，而事实上$i-l$这个状态也是可能为队头的，因此不全面，导致错误。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,l,r,a[N],dp[N],ans=-INF;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;dp[i-l]&gt;=dp[q.back()]) q.pop_back();</span><br><span class="line">q.push_back(i-l);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;(q.front()&lt;i-r||q.front()&gt;i-l)) q.pop_front();</span><br><span class="line"><span class="keyword">if</span>(q.empty()) <span class="keyword">continue</span>;</span><br><span class="line">dp[i]=dp[q.front()]+a[i];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n-r+<span class="number">1</span>) ans=max(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1886] 滑动窗口/【模板】单调队列</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1886%5D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1886%5D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p><p>例如：</p><p>The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。</p><p><a href="https://postimg.cc/bS1Dk494" target="_blank" rel="noopener"><img src="https://i.postimg.cc/sxNYdrQf/688.jpg" alt="688.jpg"></a></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 50\%$的数据，$1 \le n \le 10^5$；<br>对于$100\%$的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">P1886 滑动窗口 /【模板】单调队列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>单调队列板子。</p><p>不太好解释。理解就好。</p><p>队列一般储存两个值：数组下标和动规状态值。</p><p>本题明显具有单调性。</p><p>维护单调性即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(i-k+<span class="number">1</span>&gt;q[head].id&amp;&amp;head&lt;=tail) head++;</span><br><span class="line"><span class="keyword">while</span>(a[i]*p&lt;q[tail].v&amp;&amp;head&lt;=tail) tail--;</span><br><span class="line">q[++tail].v=a[i]*p;</span><br><span class="line">q[tail].id=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;q[head].v*p&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">work(<span class="number">1</span>);</span><br><span class="line">work(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1714] 切蛋糕</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1714%5D-%E5%88%87%E8%9B%8B%E7%B3%95/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1714%5D-%E5%88%87%E8%9B%8B%E7%B3%95/</url>
      
        <content type="html"><![CDATA[<p>给定一长$n$的序列，求其中长度不超过$m$的最大连续子序列和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对$20\%$的数据，$N≤100$。</p><p>对$100\%$的数据，$N≤500000$，$|Pi|≤500$。 答案保证在$2^{31}-1$之内。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1714" target="_blank" rel="noopener">P1714 切蛋糕</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前缀和+单调队列，$O(n)$。</p><p>求的是最大连续子序列和，因此维护单调递增的单调队列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> n,m,s[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>,ans=~INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(q[head].id&lt;i-m&amp;&amp;head&lt;=tail) head++;</span><br><span class="line">ans=max(ans,s[i]-q[head].v);</span><br><span class="line"><span class="keyword">while</span>(s[i]&lt;q[tail].v&amp;&amp;head&lt;=tail) tail--;</span><br><span class="line">q[++tail].v=s[i];</span><br><span class="line">q[tail].id=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P5788] 【模板】单调栈</title>
      <link href="/is-zxy.github.io/2020/02/03/%5B%E6%B4%9B%E8%B0%B7P5788%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/is-zxy.github.io/2020/02/03/%5B%E6%B4%9B%E8%B0%B7P5788%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>给出项数为$n$的整数数列$a_{1 \dots n}$。</p><p>定义函数$f(i)$代表数列中第$i$个元素之后第一个大于$a_i$ 的元素的<strong>下标</strong>。若不存在，则$f(i)=0$。</p><p>试求出$f(1\dots n)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$n\leq 100$；</p><p>对于$ 60\%$的数据，$n\leq 5 \times 10^3$；</p><p>对于$ 100\%$的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">P5788 【模板】单调栈</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>单调栈板子。</p><p>维护一个单调递减的单调栈。</p><p>依次入栈，若比栈顶大，弹出栈顶，栈顶的$f$值即为当前入栈的下标。</p><p>入完栈后，最终栈内剩下的$f$值均为$0$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],f[N];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;a[s.top()]&lt;a[i]) &#123;</span><br><span class="line">f[s.top()]=i;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">f[s.top()]=<span class="number">0</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,f[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2007] 时态同步</title>
      <link href="/is-zxy.github.io/2020/02/03/%5BZJOI2007%5D-%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
      <url>/is-zxy.github.io/2020/02/03/%5BZJOI2007%5D-%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字$1,2,3$进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。</p><p>在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。</p><p>激励电流在导线上的传播是需要花费时间的，对于每条边$e$，激励电流通过它需要的时间为$t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q​有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$40\%$的数据，$N ≤ 1000$</p><p>对于$100\%$的数据，$N ≤ 500000$</p><p>对于所有的数据，$t_e ≤ 1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1131" target="_blank" rel="noopener">[ZJOI2007]时态同步</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不算难的一题。</p><p>定义$dp[root]$表示以$root$为根的子树的道具最少使用次数。</p><p>显然要用道具补到与最长链相同。</p><p>于是</p><script type="math/tex; mode=display">dp[root]=\sum_{j\in son_{root}}dp[j]+cnt*maxn[root]-sum</script><p>其中$maxn[i]$表示以$i$为根的子树从根到叶的最大距离。</p><p>$sum=\sum_{j\in son_{root}}(maxn[j]+edge[j])$</p><p>$cnt$表示$root$的儿子个数。</p><p>过程中维护好$maxn[root]$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,s,head[N&lt;&lt;<span class="number">1</span>],tot=<span class="number">0</span>;</span><br><span class="line">ll dp[N],maxn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">ll cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to==fa) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line">dfs(edge[i].to,root);</span><br><span class="line">dp[root]+=dp[edge[i].to];</span><br><span class="line">maxn[root]=max(maxn[edge[i].to]+edge[i].w,maxn[root]);</span><br><span class="line">sum+=maxn[edge[i].to]+edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line">dp[root]+=cnt*maxn[root]-sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;t;</span><br><span class="line">add(a,b,t);</span><br><span class="line">add(b,a,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(s,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[s]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> ZJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO07JAN] 平衡的阵容Balanced Lineup</title>
      <link href="/is-zxy.github.io/2020/02/02/%5BUSACO07JAN%5D-%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%98%B5%E5%AE%B9Balanced-Lineup/"/>
      <url>/is-zxy.github.io/2020/02/02/%5BUSACO07JAN%5D-%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%98%B5%E5%AE%B9Balanced-Lineup/</url>
      
        <content type="html"><![CDATA[<p>每天,农夫 John的$N$$(1 &lt;= N &lt;= 50,000)$头牛总是按同一序列排队. 有一天, John 决定让一些牛们玩一场飞盘比赛. 他准备找一群在对列中为置连续的牛来进行比赛. 但是为了避免水平悬殊,牛的身高不应该相差太大. John 准备了$Q (1 &lt;= Q &lt;= 200,000)$ 个可能的牛的选择和所有牛的身高 $(1 &lt;= 身高 &lt;= 1,000,000)$. 他想知道每一组里面最高和最低的牛的身高差别. </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2880" target="_blank" rel="noopener">[USACO07JAN]平衡的阵容Balanced Lineup</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显的RMQ问题。</p><p>ST表、线段树、树状数组不解释。</p><h3 id="代码（ST表）"><a href="#代码（ST表）" class="headerlink" title="代码（ST表）"></a>代码（ST表）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,h[MAXN],lg[MAXN],fi[MAXN][N],fa[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) &#123;</span><br><span class="line">fi[i][j]=min(fi[i][j<span class="number">-1</span>],fi[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">fa[i][j]=max(fa[i][j<span class="number">-1</span>],fa[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=lg[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(fa[l][p],fa[r-(<span class="number">1</span>&lt;&lt;p)+<span class="number">1</span>][p])-min(fi[l][p],fi[r-(<span class="number">1</span>&lt;&lt;p)+<span class="number">1</span>][p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(fi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(fi));</span><br><span class="line"><span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="keyword">sizeof</span>(fa));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">fi[i][<span class="number">0</span>]=fa[i][<span class="number">0</span>]=h[i];</span><br><span class="line">lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（线段树）"><a href="#代码（线段树）" class="headerlink" title="代码（线段树）"></a>代码（线段树）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,minn,maxn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minn(x) tree[x].minn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn(x) tree[x].maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;minn(p);</span><br><span class="line">maxn(p)=minn(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">minn(p)=min(minn(ls),minn(rs));</span><br><span class="line">maxn(p)=max(maxn(ls),maxn(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxn_ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> maxn(p);</span><br><span class="line"><span class="keyword">return</span> max(maxn_ask(ls,l,r),maxn_ask(rs,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minn_ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> minn(p);</span><br><span class="line"><span class="keyword">return</span> min(minn_ask(ls,l,r),minn_ask(rs,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn_ask(<span class="number">1</span>,l,r)-minn_ask(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（树状数组）"><a href="#代码（树状数组）" class="headerlink" title="代码（树状数组）"></a>代码（树状数组）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,h[N],ci[N],ca[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> h[l];</span><br><span class="line"><span class="keyword">if</span>(r-lowbit(r)+<span class="number">1</span>&gt;l) <span class="keyword">return</span> min(ci[r],ask_min(l,r-lowbit(r)));</span><br><span class="line"><span class="keyword">return</span> min(h[r],ask_min(l,r<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_max</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> h[l];</span><br><span class="line"><span class="keyword">if</span>(r-lowbit(r)+<span class="number">1</span>&gt;l) <span class="keyword">return</span> max(ca[r],ask_max(l,r-lowbit(r)));</span><br><span class="line"><span class="keyword">return</span> max(h[r],ask_max(l,r<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">ca[i]=ci[i]=h[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;lowbit(i);j++) &#123;</span><br><span class="line">ci[i]=min(ci[i],ci[i-j]);</span><br><span class="line">ca[i]=max(ca[i],ca[i-j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask_max(l,r)-ask_min(l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST表 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3694] 邦邦的大合唱站队</title>
      <link href="/is-zxy.github.io/2020/02/02/%5B%E6%B4%9B%E8%B0%B7P3694%5D-%E9%82%A6%E9%82%A6%E7%9A%84%E5%A4%A7%E5%90%88%E5%94%B1%E7%AB%99%E9%98%9F/"/>
      <url>/is-zxy.github.io/2020/02/02/%5B%E6%B4%9B%E8%B0%B7P3694%5D-%E9%82%A6%E9%82%A6%E7%9A%84%E5%A4%A7%E5%90%88%E5%94%B1%E7%AB%99%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>$N$个偶像排成一列，他们来自$M$个不同的乐队。每个团队至少有一个偶像。</p><p>现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。</p><p>请问最少让多少偶像出列？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$N\le 20, M=2$</p><p>对于$40\%$的数据，$N\le 100, M\le 4$</p><p>对于$70\%$的数据，$N\le 2000, M\le 10$</p><p>对于全部数据，$1\le N\le 10^5, M\le 20$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3694" target="_blank" rel="noopener">P3694 邦邦的大合唱站队</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$m$较小，考虑状压。</p><p>用二进制数表示状态，若第$i$位为$1$则表示第$i$个团队在队列中（从$0$开始）。</p><p>定义$dp[i]$表示状态$i$下最少让偶像出列的个数。</p><p>定义$sum[i][j]$表示原队伍中前$i$个人中属于$j$团队的人的个数。</p><p>定义$num[i]$表示$i$团队的总人数。</p><p>可得</p><script type="math/tex; mode=display">dp[i]=min\{dp[i\ xor2^j]+num[j]-(sum[l][j]-sum[l-num[j]][j])\}</script><p>其中$l$表示该状态下的总人数，即$l=\displaystyle\sum_{2^j\&amp;i==1}num[j]$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;m)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,id[MAXN],sum[MAXN][N],num[N],dp[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id[i];</span><br><span class="line">id[i]--;</span><br><span class="line">num[id[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) sum[i][j]+=(id[i]==j)?<span class="number">1</span>+sum[i<span class="number">-1</span>][j]:sum[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) l+=((<span class="number">1</span>&lt;&lt;j)&amp;i)?num[j]:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i) &#123;</span><br><span class="line">dp[i]=min(dp[i],dp[i^(<span class="number">1</span>&lt;&lt;j)]+num[j]-(sum[l][j]-sum[l-num[j]][j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[tot<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO08NOV] 奶牛混合起来Mixed Up Cows</title>
      <link href="/is-zxy.github.io/2020/02/01/%5BUSACO08NOV%5D-%E5%A5%B6%E7%89%9B%E6%B7%B7%E5%90%88%E8%B5%B7%E6%9D%A5Mixed-Up-Cows/"/>
      <url>/is-zxy.github.io/2020/02/01/%5BUSACO08NOV%5D-%E5%A5%B6%E7%89%9B%E6%B7%B7%E5%90%88%E8%B5%B7%E6%9D%A5Mixed-Up-Cows/</url>
      
        <content type="html"><![CDATA[<p>约翰家有$N$头奶牛，第i头奶牛的编号是$S_i$，每头奶牛的编号都是唯一的。这些奶牛最近在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队伍中，相邻奶牛的编号之差均超过$K$。比如当$K=1$时，$1,3,5,2,6,4$就是一支混乱的队伍， 而$1,3,6,5,2,4$不是，因为$6$和$5$只差$1$。请数一数，有多少种队形是混乱的呢？ </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (4 &lt;= N &lt;= 16) $</p><p>$(1 &lt;= K &lt;= 3400) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2915" target="_blank" rel="noopener">[USACO08NOV]奶牛混合起来Mixed Up Cows</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$n$较小，考虑状压。</p><p>有些像Travelling那题。</p><p>令二进制数中，第$i$位为$1$表示第$i$只奶牛在队伍中，反之则不在。</p><p>定义$dp[i][j]$表示在状态$i$下，队尾为第$j$只奶牛的队伍数。</p><p>易得（$check(j)$表示$2^j$对于$i$是一个合法状态。）</p><script type="math/tex; mode=display">dp[i+2^l][l]=\sum_{check(j)\&\&i\&2^j==1}dp[i][j]</script><p>最终答案即为$\sum_{i=0}^{n-1}dp[2^n-1][i]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,id[N],bits[N];</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;N][N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;id[i];</span><br><span class="line"></span><br><span class="line">bits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i) bits[i]=bits[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(bits[j]&amp;i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>((bits[l]&amp;i)||<span class="built_in">abs</span>(id[j]-id[l])&lt;=k) <span class="keyword">continue</span>;</span><br><span class="line">dp[i+bits[l]][l]+=dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=dp[tot<span class="number">-1</span>][i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2006] 保安站岗</title>
      <link href="/is-zxy.github.io/2020/02/01/%5BSDOI2006%5D-%E4%BF%9D%E5%AE%89%E7%AB%99%E5%B2%97/"/>
      <url>/is-zxy.github.io/2020/02/01/%5BSDOI2006%5D-%E4%BF%9D%E5%AE%89%E7%AB%99%E5%B2%97/</url>
      
        <content type="html"><![CDATA[<p>五一来临，某地下超市为了便于疏通和指挥密集的人员和车辆，以免造成超市内的混乱和拥挤，准备临时从外单位调用部分保安来维持交通秩序。</p><p>已知整个地下超市的所有通道呈一棵树的形状；某些通道之间可以互相望见。总经理要求所有通道的每个端点（树的顶点）都要有人全天候看守，在不同的通道端点安排保安所需的费用不同。</p><p>一个保安一旦站在某个通道的其中一个端点，那么他除了能看守住他所站的那个端点，也能看到这个通道的另一个端点，所以一个保安可能同时能看守住多个端点（树的结点），因此没有必要在每个通道的端点都安排保安。</p><p>请你帮助超市经理策划安排，在能看守全部通道端点的前提下，使得花费的经费最少。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$0&lt;n\le1500$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2458" target="_blank" rel="noopener">[SDOI2006]保安站岗</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与战略游戏和没有上司的舞会差不多。刚看这题时交了个战略游戏代码上去，当然错了233。</p><p>战略游戏是看路，而本题是看点。</p><p>路，可被连接的两点给看到。</p><p>而点，则有三种状态，一是被它父节点给看到，二是被自己看到，三是被子节点看到。</p><p>于是定义$dp[root][p]$表示以$root$为根的状态，其中</p><p>$dp[root][0]$表示$root$被其父节点看到的最小花费。</p><p>$dp[root][1]$表示$root$处就有看守的最小花费。</p><p>$dp[root][2]$表示$root$被其子节点看到的最小花费。</p><p>于是</p><script type="math/tex; mode=display">dp[root][0]=\sum_{v\in son_{root}}min(dp[v][1],dp[v][2])  \\dp[root][1]=\sum_{v\in son_{root}}min\{dp[v][0],dp[v][1],dp[v][2]\}+cost[root] \\dp[root][2]=\sum_{v\in son_{root}}min(dp[v][1],dp[v][2])+d</script><p>其中$d=\min_{v\in son_{root}}(dp[v][1]-min(dp[v][1],dp[v][2]))$ 。</p><p>这个$d$的用途很大。因为对于$dp[root][2]$，必须要选取一个子节点上放看守，否则状态$dp[root][2]$就不成立了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,cost[N],root=<span class="number">0</span>,dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=son[root].size();</span><br><span class="line"><span class="keyword">int</span> d=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v=son[root][i];</span><br><span class="line">dfs(v);</span><br><span class="line">dp[root][<span class="number">0</span>]+=min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]);</span><br><span class="line">dp[root][<span class="number">1</span>]+=min(dp[v][<span class="number">0</span>],min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]));</span><br><span class="line">dp[root][<span class="number">2</span>]+=min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]);</span><br><span class="line">d=min(d,dp[v][<span class="number">1</span>]-min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">dp[root][<span class="number">1</span>]+=cost[root];</span><br><span class="line">dp[root][<span class="number">2</span>]+=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id,m,fee;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id&gt;&gt;fee&gt;&gt;m;</span><br><span class="line">cost[id]=fee;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">vh[x]=<span class="number">1</span>;</span><br><span class="line">son[id].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(vh[++root]);</span><br><span class="line">dfs(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[root][<span class="number">1</span>],dp[root][<span class="number">2</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通#1594] 涂抹果酱</title>
      <link href="/is-zxy.github.io/2020/01/31/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/"/>
      <url>/is-zxy.github.io/2020/01/31/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/</url>
      
        <content type="html"><![CDATA[<p> Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个$N\times M$的矩形，它被划分成$N\times M$个边长为$1\times 1$的小正方形区域（可以把蛋糕当成$N$行$M$列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为$1,2,3$ 。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 $K$行的果酱，且无法修改。<br>现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数$mod\ 10^6$ 。若不存在满足条件的方案，请输出$0$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1\le N\times M \le 20$；</p><p>对于$60\%$的数据，$1\le N\le 1000,1\le M \le 3$；</p><p>对于$100\%$的数据，$1\le N \le 10000,1\le M \le 5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1594" target="_blank" rel="noopener">[一本通#1594]涂抹果酱</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三种果酱，且$m$较小，则考虑三进制状压。</p><p>先判断其给的第$K$行涂抹的果酱是否合法，不合法直接输出$0$。</p><p>定义$dp[i][j]$表示第$i$行状态为$j$的方案数，则易得（其中$check(l)$表示$l$是一个合法方案。）</p><script type="math/tex; mode=display">dp[i][j]=\sum_{l}^{check(l)}dp[i-1][l]</script><p>当$i-1=k$或$i=k$的情况需要单独考虑。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y) x=(x+y)%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,zk=<span class="number">0</span>,dp[N][<span class="number">310</span>],w[<span class="number">310</span>][<span class="number">10</span>],ans=<span class="number">0</span>,tot;</span><br><span class="line"><span class="keyword">bool</span> vh[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tot=<span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> b=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">w[i][j]=b%<span class="number">3</span>;</span><br><span class="line">b/=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(j&amp;&amp;w[i][j]==w[i][j<span class="number">-1</span>]) vh[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[i]) <span class="keyword">continue</span>;</span><br><span class="line">dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[<span class="number">1</span>][zk]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span>(w[x][i]==w[y][i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">zk=zk*<span class="number">3</span>+(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">if</span>(!vh[zk]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]||!check(j,zk)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][zk],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>==k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]||!check(j,zk)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][zk]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=k&amp;&amp;i<span class="number">-1</span>!=k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[l]||!check(j,l)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][l]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) add(ans,dp[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> 三进制 </tag>
            
            <tag> 一本通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU3001] Travelling</title>
      <link href="/is-zxy.github.io/2020/01/31/%5BHDU3001%5D-Travelling/"/>
      <url>/is-zxy.github.io/2020/01/31/%5BHDU3001%5D-Travelling/</url>
      
        <content type="html"><![CDATA[<p>有$n$个城市，$m$个道路，走每一个道路都需要一定费用，每个城市最多经过$2$次，求经过每个城市的最小费用值，若不能经过每个城市则输出$-1$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=n&lt;=10)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001" target="_blank" rel="noopener">Travelling</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每个城市可能经过$0$次，$1$次，$2$次，那么可以想到三进制状压。</p><p>定义$dp[i][j]$表示在状态$i$下，最后一个到达的城市为$j$的最小费用值。</p><p>定义$bits[k]$表示$3^k$，即到达$k$城市一次。</p><p>那么易得$dp[i+bits[k]][k]=min\{dp[i][j]+cost[j][k]\}$，前提是$dp[i][j]$已被处理出来，$j,k$间有道路相连，且到达$k$的次数小于$2$。</p><p>于是可以初始化$dp$数组为一个极大值，$cost$数组也为一个极大值，输入时覆盖掉。到达一个城市的次数，可以用一个二维数组记录一个数的三进制下的每一位的数字。</p><p>当$dp$过程中发现有一次每一个城市走过了时，便可以从该状态中获得答案，当然可能该状态并没有被拓展过，于是答案也初始化为一个极大值，最终判断是否为该极大值，若是的话，输出$-1$，反之输出答案值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 60010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,bits[N],visit[MAXN][N],cost[N][N],dp[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) bits[i]=bits[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bits[<span class="number">10</span>];i++) &#123;</span><br><span class="line"><span class="keyword">int</span> b=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">visit[i][j]=b%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> b/=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line"><span class="built_in">memset</span>(cost,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(cost));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cost[a<span class="number">-1</span>][b<span class="number">-1</span>]=cost[b<span class="number">-1</span>][a<span class="number">-1</span>]=min(c,cost[a<span class="number">-1</span>][b<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[bits[i]][i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bits[n];i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[i][j]) flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]==INF) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(cost[j][k]==INF||visit[i][k]==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">dp[i+bits[k]][k]=min(dp[i+bits[k]][k],dp[i][j]+cost[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) ans=min(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((ans==INF)?<span class="number">-1</span>:ans)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> HDU </tag>
            
            <tag> 三进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1273] 有线电视网</title>
      <link href="/is-zxy.github.io/2020/01/30/%5B%E6%B4%9B%E8%B0%B7P1273%5D-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91/"/>
      <url>/is-zxy.github.io/2020/01/30/%5B%E6%B4%9B%E8%B0%B7P1273%5D-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。</p><p>从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。</p><p>现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。</p><p>写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$2≤N≤3000,1≤M≤N-1$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1273" target="_blank" rel="noopener">P1273 有线电视网</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[root][i]$表示以$root$为根，有$i$个用户的赚钱数。</p><p>则对于每个根，将其子节点所附带的用户数看成一个个物品组，跑分组背包。</p><p>边界$dp[root][0]=0$，其余都初始化为一个极小的负值。</p><p>本题用邻接表较好操作。</p><p>物品组的数量可利用函数返回值来求。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> n,m,head[N],tot=<span class="number">0</span>,v[N],dp[N][N],js[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root&gt;n-m) &#123;</span><br><span class="line">dp[root][<span class="number">1</span>]=v[root];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> js=dfs(edge[i].to);</span><br><span class="line">sum+=js;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(j,js);k++) &#123;</span><br><span class="line">dp[root][j]=max(dp[root][j],dp[root][j-k]+dp[edge[i].to][k]-edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;c;</span><br><span class="line">add_edge(i,a,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF484A] Bits</title>
      <link href="/is-zxy.github.io/2020/01/30/%5BCF484A%5D-Bits/"/>
      <url>/is-zxy.github.io/2020/01/30/%5BCF484A%5D-Bits/</url>
      
        <content type="html"><![CDATA[<ul><li><p>$n$组询问，每次给出一个区间$l, r$，你需要输出在这个区间内二进制表示中$1$的个数最多的数</p></li><li><p>如有多个答案，输出最小的那个</p></li><li><p>$(n \leq10^4, 0\leq l, r \leq10^{18})$</p></li></ul><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF484A" target="_blank" rel="noopener">CF484A Bits</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于是在$[l,r]$区间内，即需要大于等于$l$且小于等于$r$，则可以直接在$l$上进行操作。</p><p>从$l$的二进制最低位开始，每一位都$|1$，直到再$|1$就比$r$大了为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll l,r,t=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">while</span>((l|t)&lt;=r) &#123;</span><br><span class="line">l=l|t;</span><br><span class="line">t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2001] 炮兵阵地</title>
      <link href="/is-zxy.github.io/2020/01/29/%5BNOI2001%5D-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/"/>
      <url>/is-zxy.github.io/2020/01/29/%5BNOI2001%5D-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个$N \times M$的地图由$N$行$M$列组成，地图的每一格可能是山地（用“$H$” 表示），也可能是平原（用“$P$”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><p><a href="https://postimg.cc/XXgC8BMP" target="_blank" rel="noopener"><img src="https://i.postimg.cc/tRKN9FB9/1881.jpg" alt="1881.jpg"></a></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N≤100,M≤10$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2704" target="_blank" rel="noopener">[NOI2001]炮兵阵地</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>状压。</p><p>每个方案都与上两行有关。</p><p>定义$dp[i][j][k]$表示第$i$行状态为$j$，$i-1$行状态为$k$时最多摆放的炮兵部队数量。</p><p>易得（其中$check(l)$表示第$i-2$行状态为$l$对于此方案是可行的。$sum[j]$表示状态$j$的炮兵数量，即二进制中$1$的个数。）</p><script type="math/tex; mode=display">dp[i][j][k]=max_{l}^{check(l)}\{dp[i-1][k][l]\}+sum[j]</script><p>但是这样的话，$dp$数组就要开到$dp[100][2^{10}][2^{10}]$，明显会爆空间。</p><p>然而并不是每一个状态都是可行的，相邻两个位置不能同时摆炮兵，据此可大略算出$10$列的话可行状态不超过$100$。因此后两维开到$100$，并用另一个数组记录可行状态，再进行$DP$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,p[N],dp[N][N][N],sum[N*<span class="number">10</span>],a[N],js=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i&amp;(i&gt;&gt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">2</span>))||(i&amp;(i&gt;&gt;<span class="number">2</span>))) <span class="keyword">continue</span>;</span><br><span class="line">a[++js]=i;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">sum[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=js;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=js;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[i],a[j])||!check(a[i],p[<span class="number">2</span>])||!check(a[j],p[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">dp[<span class="number">2</span>][i][j]=sum[a[i]]+sum[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=(s[i][j]==<span class="string">'P'</span>)?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">p[i]=(p[i]&lt;&lt;<span class="number">1</span>)+t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=js;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(p[i],a[j])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=js;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[j],a[k])||!check(p[i<span class="number">-1</span>],a[k])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=js;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[l],a[k])||!check(a[j],a[l])||!check(a[l],p[i<span class="number">-2</span>])) <span class="keyword">continue</span>;</span><br><span class="line">maxn=max(maxn,dp[i<span class="number">-1</span>][k][l]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j][k]=max(maxn+sum[a[j]],dp[i][j][k]);</span><br><span class="line">ans=max(ans,dp[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> NOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO06NOV] 玉米田Corn Fields</title>
      <link href="/is-zxy.github.io/2020/01/26/%5BUSACO06NOV%5D-%E7%8E%89%E7%B1%B3%E7%94%B0Corn-Fields/"/>
      <url>/is-zxy.github.io/2020/01/26/%5BUSACO06NOV%5D-%E7%8E%89%E7%B1%B3%E7%94%B0Corn-Fields/</url>
      
        <content type="html"><![CDATA[<p>农场主$John$新买了一块长方形的新牧场，这块牧场被划分成$M$行$N$列$(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)$，每一格都是一块正方形的土地。$John$打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p><p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是$John$不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p><p>$John$想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1 ≤ M ≤ 12,1 ≤ N ≤ 12) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1879" target="_blank" rel="noopener">[USACO06NOV]玉米田Corn Fields</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与互不侵犯多少有些相似。</p><p>定义$dp[i][j]$表示第$i$行的状态为$j$时的方案数，易得</p><script type="math/tex; mode=display">dp[i][j]=sum_{k}^{check(k)}dp[i-1][k]</script><p>边界$dp[0][0]=1$。</p><p>其中$check(k)$表示$k$为一个合法状态，前提也保证$j$为一个合法状态。</p><p>不相邻$\&amp; $一下就好，问题在于如何保证种的地方可以种。</p><p>还是$\&amp; $，若是合法，则$\&amp; $后应返回原值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y) x=(x+y)%MOD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,g[<span class="number">15</span>],dp[<span class="number">15</span>][<span class="number">5010</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;(i&lt;&lt;<span class="number">1</span>)||i&amp;(i&gt;&gt;<span class="number">1</span>)) p[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">g[i]=(g[i]&lt;&lt;<span class="number">1</span>)+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((j&amp;g[i])!=j||(p[j])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(j,k)||(k&amp;g[i<span class="number">-1</span>])!=k||p[k]) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) add(ans,dp[n][i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题还让我认识到了运算符的优先级，位运算符优先级要小于等于与不等于，因此要加括号。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CQOI2005] 珠宝</title>
      <link href="/is-zxy.github.io/2020/01/23/%5BCQOI2005%5D-%E7%8F%A0%E5%AE%9D/"/>
      <url>/is-zxy.github.io/2020/01/23/%5BCQOI2005%5D-%E7%8F%A0%E5%AE%9D/</url>
      
        <content type="html"><![CDATA[<p> 有一棵 $n$ 个结点的树，给每个点安排一个正整数编号，使得相邻点具有不同的编号，编号的总和尽量小。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$n\le 10$；</p><p>对于$40\%$的数据，$n\le 1000$；</p><p>对于$100\%$的数据，$1\le n\le 50000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5765" target="_blank" rel="noopener">[CQOI2005]珠宝</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显具有无后效性，于是树形DP。</p><p>定义$dp[root][x]$表示以$root$为根且$root$上数字为$x$的子树的最小编号总和。</p><p>于是易得（令$root$有$m$个儿子$son_{1\cdots m}$）</p><script type="math/tex; mode=display">dp[root][x]=min_{i=1}^m\{dp[son_i][k]\}+x\ ,\  k!=x</script><p>由于本题数据较小，$k$的枚举到$10$左右即可，不放心可开大些。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">15</span>],n,ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[g[root][i]]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> minn=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">10</span>;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j==k) <span class="keyword">continue</span>;</span><br><span class="line">minn=min(dp[g[root][i]][k],minn);</span><br><span class="line">&#125;</span><br><span class="line">dp[root][j]+=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) dp[root][i]+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">g[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) ans=min(dp[<span class="number">1</span>][i],ans);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> CQOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SCOI2005] 互不侵犯</title>
      <link href="/is-zxy.github.io/2020/01/21/%5BSCOI2005%5D-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"/>
      <url>/is-zxy.github.io/2020/01/21/%5BSCOI2005%5D-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/</url>
      
        <content type="html"><![CDATA[<p> 在$n\times n$的棋盘里面放$k$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到他周围的八个格子。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1 &lt;=N &lt;=9,0 &lt;= K &lt;= N^2)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1896" target="_blank" rel="noopener">SCOI2005 互不侵犯</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚学状压。</p><p>$1&lt;=n&lt;=9$，$0&lt;=k&lt;=n^2$，明显$dfs$过不了。</p><p>这时候状态压缩DP就出现了。</p><p>可以用$0$和$1$表示一个格子放没放国王，放了为$1$。</p><p>定义$dp[i][j][s]$表示前$i$行，上一行状态为$j$，这一行共放了$s$个国王的方案数。其中状态即为一二进制数的十进制表示，该二进制下的$0$和$1$即为状态。</p><p>令$j$的二进制下有$sum[j]$个$1$，即$sum[j]$个国王。</p><p>则$dp[i][j][sum[j]+p]=\sum_{p=0}^{k-sum[j]}dp[i-1][l][p]$，其中$l$为符合条件且不与$j$冲突的状态。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">1</span>&lt;&lt;N][N*N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,sum[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;y||(x&gt;&gt;<span class="number">1</span>)&amp;y||(x&lt;&lt;<span class="number">1</span>)&amp;y||x&amp;(x&lt;&lt;<span class="number">1</span>)||x&amp;(x&gt;&gt;<span class="number">1</span>)||y&amp;(y&lt;&lt;<span class="number">1</span>)||y&amp;(y&gt;&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">sum[i]++;</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&lt;=k) dp[<span class="number">1</span>][i][sum[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(j,l)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=k-sum[j];s++) &#123;</span><br><span class="line">dp[i][j][sum[j]+s]+=dp[i<span class="number">-1</span>][l][s];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) ans+=dp[n][i][k];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然有些麻烦，还可以提前预处理出符合条件的状态，这里懒得写了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> SCOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1122] 最大子树和</title>
      <link href="/is-zxy.github.io/2020/01/20/%5B%E6%B4%9B%E8%B0%B7P1122%5D-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%A0%91%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/01/20/%5B%E6%B4%9B%E8%B0%B7P1122%5D-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%A0%91%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：</p><p>一株奇怪的花卉，上面共连有$N$朵花，共有$N-1$条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p><p>老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$60\%$的数据，有$N≤1000$；</p><p>对于$100\%$的数据，有$N≤16000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1122" target="_blank" rel="noopener">P1122 最大子树和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[root]$表示以$root$为根的最大子树和。</p><p>易得（其中令$root$有$m$个儿子$son_{1\cdots m}$，$root$的美丽指数为$b_{root}$)</p><script type="math/tex; mode=display">dp[root]=\sum_{i=1}^mmax(0,dp[son_i])+b_{root}</script><p>上述与$0$比较的原因是美丽值可能为负。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"><span class="keyword">int</span> n,dp[N],b[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>,dp[root]=b[root];</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[g[root][i]]) &#123;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line">dp[root]+=max(dp[g[root][i]],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,dp[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">g[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通#1577] 数字转换</title>
      <link href="/is-zxy.github.io/2020/01/20/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
      <url>/is-zxy.github.io/2020/01/20/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p> 如果一个数$x$的约数和 $y$（不包括他本身）比他本身小，那么$x$可以变成$y$，$y$也可以变成$x$。$4$例如 可以变为$3$，$1$可以变为$7$。限定所有数字变换在不超过$n$的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$1\le n \le 50000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1577" target="_blank" rel="noopener">一本通#1577</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很明显数字间的变化关系为森林。</p><p>那么本题其实就是求这个森林内每棵树的最长链的最大值。</p><p>大数一定是小数的儿子，于是倒着推即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,factor[N],dp[N][<span class="number">2</span>],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n/i;j++) factor[i*j]+=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(factor[i]&lt;i) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][<span class="number">0</span>]+<span class="number">1</span>&gt;dp[factor[i]][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[factor[i]][<span class="number">1</span>]=dp[factor[i]][<span class="number">0</span>];</span><br><span class="line">dp[factor[i]][<span class="number">0</span>]=dp[i][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dp[i][<span class="number">0</span>]+<span class="number">1</span>&gt;dp[factor[i]][<span class="number">1</span>]) dp[factor[i]][<span class="number">1</span>]=dp[i][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(dp[i][<span class="number">0</span>]+dp[i][<span class="number">1</span>],ans);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 一本通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2016] 战略游戏</title>
      <link href="/is-zxy.github.io/2020/01/19/%5B%E6%B4%9B%E8%B0%B7P2016%5D-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/is-zxy.github.io/2020/01/19/%5B%E6%B4%9B%E8%B0%B7P2016%5D-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p><p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p><p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p><p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (0&lt;n&lt;=1500) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2016" target="_blank" rel="noopener">P2016 战略游戏</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与没有上司的舞会那题有些类似。</p><p>定义$dp[root][f]$，当$f=0$时表示$root$处不放士兵的以$root$为根的子树符合条件时的最少士兵数，当$f=1$时即为$root$处放士兵。</p><p>当$root$处不放士兵，那么它所有的儿子必须放。当$root$处放士兵，那么它儿子放不放都行。</p><p>于是可得状态转移方程（其中假设$root$有$m$个儿子$son_{1\cdots m}$</p><script type="math/tex; mode=display">dp[root][f]=\left\{\begin{aligned}\sum_{i=1}^mdp[son_i][1]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  && f=0 \\\sum_{i=1}^mmin(dp[son_i][1],dp[son_i][0]) && f=1\end{aligned}\right.</script><p>其中初值：$dp[root][0]=0,dp[root][1]=1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>;</span><br><span class="line">dp[root][<span class="number">1</span>]=<span class="number">1</span>,dp[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[g[root][i]]) &#123;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line">dp[root][<span class="number">0</span>]+=dp[g[root][i]][<span class="number">1</span>];</span><br><span class="line">dp[root][<span class="number">1</span>]+=min(dp[g[root][i]][<span class="number">0</span>],dp[g[root][i]][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id,s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sid;</span><br><span class="line">g[sid].push_back(id);</span><br><span class="line">g[id].push_back(sid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1352] 没有上司的舞会</title>
      <link href="/is-zxy.github.io/2020/01/18/%5B%E6%B4%9B%E8%B0%B7P1352%5D-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"/>
      <url>/is-zxy.github.io/2020/01/18/%5B%E6%B4%9B%E8%B0%B7P1352%5D-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<p> 某大学有$N$个职员，编号为$1-N$。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$，但是呢，如果某个职员的<strong>直接</strong>上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=N&lt;=6000) $</p><p>$ (-128&lt;=Ri&lt;=127) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">P1352 没有上司的舞会</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树形DP的入门题。</p><p>定义状态$dp[root][f]$表示以$root$为根的状态，若$f=0$表示$root$不选，若$f=1$表示$root$选。</p><p>那么易得状态转移方程（其中$son_i$表示$root$的儿子，设$root$有$m$个儿子）</p><script type="math/tex; mode=display">dp[root][f]=\left\{\begin{aligned}\sum_{i=1}^mmax(dp[son_i][0],dp[son_i][1]) && f=0 \\(\sum_{i=1}^mdp[son_i][0])+r[root]\ \ \ \ \ \ \ \ \ \ \ \  && f=1\end{aligned}\right.</script><p>最后比较输出两种方案的最大者即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,r[N],dp[N][<span class="number">2</span>],rt,vh[N];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=son[root].size();</span><br><span class="line"><span class="keyword">if</span>(!cnt) <span class="keyword">return</span> dp[root][<span class="number">1</span>]=r[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">dfs(son[root][i]);</span><br><span class="line"><span class="keyword">int</span> j=son[root][i];</span><br><span class="line">dp[root][<span class="number">0</span>]=max(dp[root][<span class="number">0</span>],max(dp[root][<span class="number">0</span>]+dp[j][<span class="number">0</span>],dp[root][<span class="number">0</span>]+dp[j][<span class="number">1</span>]));</span><br><span class="line">dp[root][<span class="number">1</span>]=dp[root][<span class="number">1</span>]+dp[j][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[root][<span class="number">1</span>]+=r[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;r[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">vh[x]=<span class="number">1</span>;</span><br><span class="line">son[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) &#123;</span><br><span class="line">rt=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max(dp[rt][<span class="number">1</span>],dp[rt][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2015] 二叉苹果树</title>
      <link href="/is-zxy.github.io/2020/01/17/%5B%E6%B4%9B%E8%B0%B7P2015%5D-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/"/>
      <url>/is-zxy.github.io/2020/01/17/%5B%E6%B4%9B%E8%B0%B7P2015%5D-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>有一颗苹果树，如果树枝有分叉，一定是分$2$叉（就是说没有只有一个儿子的结点）</p><p>这棵树共有$n$个结点（叶子点或者树枝分叉点），编号为$1-n$，树根编号一定是$1$。</p><p>现在这棵树枝条太多了，需要剪枝，但是一些树枝上长有苹果。</p><p>给定需要保留的树枝的数量$q$，求出最多能留住多少苹果。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1&lt;=Q&lt;= N,1&lt;N&lt;=100) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2015" target="_blank" rel="noopener">P2015 二叉苹果树</a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>今天才学的树形$DP$例题。</p><p>定义$dp[i][j]$表示以第$i$ 号结点为根，保留$j$个树枝的最多能留住的苹果数量。</p><p>那么最终答案即为$dp[1][q]$。</p><p>先把$dp$数组初值赋为$-1$。</p><p>然后利用分治(?)思想，对每个结点的左右子结点进行操作。</p><p>若该结点$i$为叶子结点，则直接$dp[i][0]=0$，然后跳出该层搜索，因为以该结点为根的没有树枝。</p><p>若不为，则对其左右子结点进行操作，然后将两个子节点的状态更新至该结点上。</p><p>即若$dp[son][j]!=-1$的话，那么$dp[i][j+1]=max(dp[i][j+1],dp[son][j]+value[son])$，即增加这个连接该儿子的树枝。（其中$value$为边权值，即苹果数量。）</p><p>同理，需要讨论连接两个儿子的数枝都增加的情况，即若$dp[son_{left}][j]!=-1$并且$dp[son_{right}][k]!=-1$的话，那么<script type="math/tex">dp[i][j+k+2]=max(dp[i][j+k+2],dp[son_{left}][j]+dp[son_{right}][k]+value[son_{left}]+value[son_{right}])</script></p><p>于是据此从根向下搜索然后向上上传状态最后输出$dp[1][q]$即可。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;node&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>,dp[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=edge[root].size(),ln,rn,lid=<span class="number">0</span>,rid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[edge[root][i].t]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!lid) &#123;</span><br><span class="line">ln=edge[root][i].num;</span><br><span class="line">lid=edge[root][i].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">rn=edge[root][i].num;</span><br><span class="line">rid=edge[root][i].t;</span><br><span class="line">&#125;</span><br><span class="line">dfs(edge[root][i].t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!lid) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[lid][i]!=<span class="number">-1</span>) dp[root][i+<span class="number">1</span>]=dp[lid][i]+ln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[rid][i]!=<span class="number">-1</span>) dp[root][i+<span class="number">1</span>]=max(dp[root][i+<span class="number">1</span>],dp[rid][i]+rn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i+j+<span class="number">2</span>&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[lid][i]!=<span class="number">-1</span>&amp;&amp;dp[rid][j]!=<span class="number">-1</span>) dp[root][i+j+<span class="number">2</span>]=max(dp[root][i+j+<span class="number">2</span>],dp[lid][i]+dp[rid][j]+ln+rn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">node p;</span><br><span class="line">p.t=y,p.num=z;</span><br><span class="line">edge[x].push_back(p);</span><br><span class="line">p.t=x;</span><br><span class="line">edge[y].push_back(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][q]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还可以把边权化为点权，过程与上面差不多，但略微简单了些。但是还是上面的好理解一些。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,g[N][N],l[N],r[N],value[N],dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[root][i]!=<span class="number">-1</span>&amp;&amp;!l[root]) &#123;</span><br><span class="line">value[i]=g[root][i];</span><br><span class="line">l[root]=i;</span><br><span class="line">g[root][i]=g[i][root]=<span class="number">-1</span>;</span><br><span class="line">son(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g[root][i]!=<span class="number">-1</span>&amp;&amp;l[root]) &#123;</span><br><span class="line">value[i]=g[root][i];</span><br><span class="line">r[root]=i;</span><br><span class="line">g[root][i]=g[i][root]=<span class="number">-1</span>;</span><br><span class="line">son(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[root][k]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[root][k];</span><br><span class="line"><span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!l[root]&amp;&amp;!r[root]) <span class="keyword">return</span> value[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;i++) &#123;</span><br><span class="line">dp[root][k]=max(dp[root][k],dfs(l[root],i)+dfs(r[root],k-i<span class="number">-1</span>)+value[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[root][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">-1</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">g[x][y]=g[y][x]=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,q+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>细节较多，需格外注意，如树枝上可能没有苹果。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2568] GCD</title>
      <link href="/is-zxy.github.io/2020/01/08/%5B%E6%B4%9B%E8%B0%B7P2568%5D-GCD/"/>
      <url>/is-zxy.github.io/2020/01/08/%5B%E6%B4%9B%E8%B0%B7P2568%5D-GCD/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，求$1&lt;=x,y&lt;=n$且$gcd(x,y)$为质数的数对$(x,y)$有多少对。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ 1&lt;=N&lt;=10^7 $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2568" target="_blank" rel="noopener">P2568 GCD</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设一组满足条件的$(x,y)$，$gcd(x,y)=p$，$p$为质数。</p><p>易得$gcd(\frac{x}{p},\frac{y}{p})=1$。</p><p>那么对于一个质数$p$只需求$1&lt;=\frac{x}{p},\frac{y}{p}&lt;=n$且$gcd(\frac{x}{p},\frac{y}{p})=1$的对数就行了。</p><p>互质的数的个数，便可以转化为欧拉函数。</p><p>由欧拉函数的定义，$[1,n]$内互质的数的对数可由$\sum_{i=1}^n\varphi(i)-1$求得。</p><p>于是对于一个质数$p$，其$[1,n]$内$gcd(x,y)=p$的对数即为$2\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i)-1$，乘$2$是因为求的是对数，减$1$是因为去掉了$x=y$的情况。</p><p>于是便可以$O(n)$处理处欧拉函数，然后前缀和优化，接着枚举$p$进行累加即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>,euler[N],prime[N],v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||i*prime[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[i*prime[j]]=euler[i]*euler[prime[j]];</span><br><span class="line"><span class="keyword">else</span> euler[i*prime[j]]=euler[i]*prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>]+euler[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans+=<span class="number">2</span>*sum[n/prime[i]]<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3373] 【模板】线段树2/[AHOI2009]维护序列</title>
      <link href="/is-zxy.github.io/2020/01/07/%5B%E6%B4%9B%E8%B0%B7P3373%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%912-AHOI2009-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/01/07/%5B%E6%B4%9B%E8%B0%B7P3373%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%912-AHOI2009-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一有$n$个元素的序列，输入$m$个命令，其中</p><p>$1\ x\ y\ k$表示将区间$[x,y]$内每个数乘上$k$。</p><p>$2\ x\ y\ k$表示将区间$[x,y]$内每个数加上$k$。</p><p>$3\ x\ y$输出区间$[x,y]$内每个数的和对$P$取模的值。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据：$n \le 8$，$m \le 10$<br>对于$ 70\%$的数据：$n \le 10^3$，$m \le 10^4$<br>对于$100\%$的数据：$n \le 10^5$，$m \le 10^5$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3373" target="_blank" rel="noopener">P3373 【模板】线段树 2</a></p><p><a href="https://www.luogu.com.cn/problem/P2023" target="_blank" rel="noopener">[AHOI2009]维护序列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>增加了一个区间乘的操作。</p><p>总体思想与线段树$1$差不多，延迟标记的运用，本题需要两个，一个乘，一个加。</p><p>但本题难点在于加与乘的顺序。</p><p>可以每次区间乘$k$的同时将加延迟标记也乘$k$，然后更新时乘上乘延迟标记再加上加延迟标记乘区间长度即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll mod;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,tag_add,tag_mul;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ta(x) tree[x].tag_add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tm(x) tree[x].tag_mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r,ta(p)=<span class="number">0</span>,tm(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sum(p);</span><br><span class="line">sum(p)%=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ta(ls)=(ta(p)+(ta(ls)*tm(p))%mod)%mod,ta(rs)=(ta(p)+(ta(rs)*tm(p))%mod)%mod;</span><br><span class="line">tm(ls)=(tm(p)*tm(ls))%mod,tm(rs)=(tm(p)*tm(rs))%mod;</span><br><span class="line"></span><br><span class="line">sum(ls)=((sum(ls)*tm(p))%mod+ta(p)*(r(ls)-l(ls)+<span class="number">1</span>))%mod;</span><br><span class="line">sum(rs)=((sum(rs)*tm(p))%mod+ta(p)*(r(rs)-l(rs)+<span class="number">1</span>))%mod;</span><br><span class="line"></span><br><span class="line">ta(p)=<span class="number">0</span>;</span><br><span class="line">tm(p)=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=(sum(p)+k*(r(p)-l(p)+<span class="number">1</span>)%mod)%mod;</span><br><span class="line">ta(p)=(ta(p)+k)%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">change_add(ls,l,r,k);</span><br><span class="line">change_add(rs,l,r,k);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_mul</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=(sum(p)*k)%mod;</span><br><span class="line">ta(p)=(ta(p)*k)%mod;</span><br><span class="line">tm(p)=(tm(p)*k)%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">change_mul(ls,l,r,k);</span><br><span class="line">change_mul(rs,l,r,k);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ((ask(ls,l,r)%mod)+(ask(rs,l,r)%mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line">ll k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">switch</span>(ins) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change_mul(<span class="number">1</span>,x,y,k);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change_add(<span class="number">1</span>,x,y,k);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题细节较多，我调了一个多小时。</p><p>第一，标记都不能直接更改，而是在原来的基础上进行加或乘。</p><p>第二，标记下传的时候，子节点的加延迟标记也要乘父节点的乘延迟标记（就是这个让我查了贼长时间）。</p><p>细节需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CQOI2006] 简单题</title>
      <link href="/is-zxy.github.io/2020/01/05/%5BCQOI2006%5D-%E7%AE%80%E5%8D%95%E9%A2%98/"/>
      <url>/is-zxy.github.io/2020/01/05/%5BCQOI2006%5D-%E7%AE%80%E5%8D%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>给定一有$n$个元素的数组，初始每个元素都为$0$。</p><p>输入$m$条指令，其中</p><p>$1\ x\ y$表示将区间$[x,y]$内的数反转（$0$变$1$，$1$变$0$）。</p><p>$2\ x$表示查询第$x$个元素的值。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$50\%$的数据，$1 ≤ n ≤ 10^{3}$,$1 ≤ m ≤ 10^4$；</p><p>对于$100\%$的数据，$1 ≤ n ≤ 10^5$,$1 ≤ m ≤ 5 × 10^5$，保证$L ≤ R$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5057" target="_blank" rel="noopener">[CQOI2006]简单题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然，一个位置如果被反转过奇数次则为$1$，反之则为$0$。</p><p>针对每个反转指令维护差分，查询则直接查询差分的前缀和$\&amp; 1$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(x;x&lt;=n;x+=lowbit(x)) a[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(x;x;x-=lowbit(x)) ans+=a[x];</span><br><span class="line"><span class="keyword">return</span> ans&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">if</span>(t&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">update(x,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(y&lt;n) update(y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CQOI </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SP1716] GSS3 - Can you answer these queries III</title>
      <link href="/is-zxy.github.io/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/"/>
      <url>/is-zxy.github.io/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/</url>
      
        <content type="html"><![CDATA[<p>$n$个数，$q$次操作。</p><p>操作$0\ x\ y$表示吧$A_x$修改为$y$。</p><p>操作$1\ l\ r$询问区间$[l,r]$的最大子段和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(N &lt;= 50000)$</p><p>$(M &lt;= 50000)$</p><p>$ (|y|&lt;=10000)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/SP1716" target="_blank" rel="noopener">SP1716 GSS3 - Can you answer these queries III</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线段树维护，维护区间和$sum$,区间最大子段和$dat$，紧靠左端的最大子段和$lmax$，紧靠右端的最大子段和$rmax$。</p><p>然后$build$与$change$的过程中维护这些即可。</p><p>节点$p$的最大子段和为左节点的最大子段和、右节点则最大子段和、左节点的紧靠右端的最大子段和加右节点的紧靠左端的最大子段和，这三者的最大值。</p><p>节点$p$的紧靠左端的最大子段和为左节点的紧靠左端的最大子段和，左节点的区间和加右节点的紧靠左端的最大子段和，这二者的最大值。</p><p>节点$p$的紧靠右端的最大子段和为右节点的紧靠右端的最大子段和，右节点的区间和加左节点的紧靠右端的最大子段和，这二者的最大值。</p><p>最后的$ask$，需要控制其子段为连续的，仍遵循上面的方法查询即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,lmax,rmax,dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(x) tree[x].lmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(x) tree[x].rmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line">&#125;tree[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=lm(p)=rm(p)=dat(p)=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">lm(p)=max(lm(p*<span class="number">2</span>),sum(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rm(p)=max(rm(p*<span class="number">2</span>+<span class="number">1</span>),sum(p*<span class="number">2</span>+<span class="number">1</span>)+rm(p*<span class="number">2</span>));</span><br><span class="line">dat(p)=max(dat(p*<span class="number">2</span>),max(dat(p*<span class="number">2</span>+<span class="number">1</span>),rm(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">sum(p)=lm(p)=rm(p)=dat(p)=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=x) change(p*<span class="number">2</span>,x,k);</span><br><span class="line"><span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">lm(p)=max(lm(p*<span class="number">2</span>),sum(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rm(p)=max(rm(p*<span class="number">2</span>+<span class="number">1</span>),sum(p*<span class="number">2</span>+<span class="number">1</span>)+rm(p*<span class="number">2</span>));</span><br><span class="line">dat(p)=max(dat(p*<span class="number">2</span>),max(dat(p*<span class="number">2</span>+<span class="number">1</span>),rm(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=r) <span class="keyword">return</span> ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;l) <span class="keyword">return</span> ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Segment_Tree ls,rs,ans;</span><br><span class="line">ls=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line">rs=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">ans.dat=max(ls.dat,max(rs.dat,ls.rmax+rs.lmax));</span><br><span class="line">ans.lmax=max(ls.lmax,ls.sum+rs.lmax);</span><br><span class="line">ans.rmax=max(rs.rmax,rs.sum+ls.rmax);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(ins) <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y).dat&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重题"><a href="#重题" class="headerlink" title="重题"></a>重题</h3><p><a href="https://www.luogu.com.cn/problem/P4513" target="_blank" rel="noopener">P4513 小白逛公园</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> SPOJ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树学习笔记</title>
      <link href="/is-zxy.github.io/2020/01/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/01/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线段树是一种以分治为主体思想的数据结构，主要对区间进行操作。</p><p>与之前所学习的树状数组相比，其好处在于更加通用，易扩展，不过码量较大。</p><a id="more"></a><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>正如其名，线段树是一个二叉树形结构，其每个点其实是一个区间。</p><p>根节点保存的区间为$[1,n]$，编号为$1$，其左节点编号为$1\times2=2$，保存区间为$[1,\lfloor\frac{1+n}{2}\rfloor]$；右节点编号为$1\times2+1=3$，保存区间为$[\lfloor\frac{1+n}{2}\rfloor,n]$。以此类推，直到区间长度为$1$为止(除法全部向下取整)。</p><p>根据此建立规则，发现编号最大可能到$4n$，所以数组至少要到$4n$。</p><p>建立、修改、查询之类的一系列操作均递归实现。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>给定一个有$n$个数的序列，对其进行$m$个操作。</p><p>输入$1\ x\ k$时，将第$x$个数加上$k$。</p><p>输入$2\ x\ y$时，输出区间$[x,y]$每个数的和。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">P3374 【模板】树状数组 1</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线段树维护区间和即可。</p><p>本题线段树过不了，主要为了熟悉线段树写法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">&#125;tree[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">sum(p)+=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=x) add(p*<span class="number">2</span>,x,k);</span><br><span class="line"><span class="keyword">else</span> add(p*<span class="number">2</span>+<span class="number">1</span>,x,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(ins%<span class="number">2</span>) add(<span class="number">1</span>,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是求区间的最大/最小值，或是其他奇奇怪怪的具有可加性的东西，则分析分析修改修改即可。这里就显示出了线段树的易扩展性。</p><h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>给定一个有$n$个数的序列，对其进行$m$个操作。</p><p>输入$1\ x\ y\ k$时，表示将区间$[x,y]$内每个数加上$k$。</p><p>输入$2\ x\ y$时，输出区间$[x,y]$的和。</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对区间$[l,r]$进行修改，若是朴素算法，则为$O(n)$，那线段树就没啥意义了。</p><p>想想之前学过的树状数组，树状数组的区间修改是利用差分思想，将区间修改转化为其擅长的单点修改，于是对于线段树，一种叫做“延迟标记”(lazy tag)的东西诞生了。</p><p>针对区间$[l,r]$进行修改，若是将其每个点都进行了修改，那么之后的查询若是没有查询到$[l,r]$的子区间的话，那么更新其每个点显然是不必要的。因此可以先只对$[l,r]$进行修改，将其加上一个标记，之后的查询过程中若是查到了子区间，先进行“标记下传”，即将修改的值传递到其子区间，然后再进行查询。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sum(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)) &#123;</span><br><span class="line">sum(p*<span class="number">2</span>)+=lazy(p)*(r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>)+=lazy(p)*(r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">lazy(p*<span class="number">2</span>)+=lazy(p);</span><br><span class="line">lazy(p*<span class="number">2</span>+<span class="number">1</span>)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)+=(r(p)-l(p)+<span class="number">1</span>)*k;</span><br><span class="line">lazy(p)+=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) change(p*<span class="number">2</span>,l,r,k);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y,k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">if</span>(!(ins&amp;<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change(<span class="number">1</span>,x,y,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间的范围之类的细节值得注意，特别是如此繁长的线段树代码。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p><a href="https://www.luogu.com.cn/problem/SP1716" target="_blank" rel="noopener">SP1716 GSS3 - Can you answer these queries III</a>（单点修改求区间最大连续子段和）。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1835] 素数密度</title>
      <link href="/is-zxy.github.io/2020/01/01/%5B%E6%B4%9B%E8%B0%B7P1835%5D-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/"/>
      <url>/is-zxy.github.io/2020/01/01/%5B%E6%B4%9B%E8%B0%B7P1835%5D-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定区间$[L,R],(L\le R\le 2147483647,R-L\le 1000000)$，计算出区间内素数的个数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1835" target="_blank" rel="noopener">P1835 素数密度</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$L,R$很大，于是直接处理素数肯定是不行的。</p><p>发现，$R-L$的值在可承受的范围内，于是可以先线性筛处理处$\sqrt{2147483647}$以内的所有素数，再用筛法把区间内的合数标记，最后扫一遍记录素数个数即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll l,r,prime[N+<span class="number">10</span>],v[N+<span class="number">10</span>],m=<span class="number">0</span>,ans=<span class="number">0</span>,vh[<span class="number">20</span>*N+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">primes(N);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">l=(l==<span class="number">1</span>?<span class="number">2</span>:l);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[i]&gt;<span class="built_in">sqrt</span>(r)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=max(<span class="number">2l</span>l,(l<span class="number">-1</span>)/prime[i]+<span class="number">1</span>);j&lt;=r/prime[i];j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[i]*j&gt;=l&amp;&amp;prime[i]*j&lt;=r) vh[prime[i]*j-l+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF546D] Soldier and Number Game</title>
      <link href="/is-zxy.github.io/2020/01/01/%5BCF546D%5D-Soldier-and-Number-Game/"/>
      <url>/is-zxy.github.io/2020/01/01/%5BCF546D%5D-Soldier-and-Number-Game/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，接下来有$n$组$a,b$，求$a!/b!$的质因子个数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF546D" target="_blank" rel="noopener">CF546D Soldier and Number Game</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$sum[x]$表示$x$的质因子个数。</p><p>易得$sum[xy]=sum[x]+sum[y]$。</p><p>那么就可以用线性筛求出$1$到$5000000$的$sum$值，阶乘的话，根据上面的式子，$sum[!x]=\sum_{i=1}^xsum[i]$，于是求前缀和即可。</p><p>最后针对每组$a,b$，前缀和相减。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>,prime[N],v[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">sum[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]*i&gt;n||prime[j]&gt;v[i]) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">sum[prime[j]*i]=sum[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">init(N);</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum[a]-sum[b]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性筛与积性函数学习笔记</title>
      <link href="/is-zxy.github.io/2019/12/29/%E7%BA%BF%E6%80%A7%E7%AD%9B%E4%B8%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2019/12/29/%E7%BA%BF%E6%80%A7%E7%AD%9B%E4%B8%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线性筛法是一种$O(n)$的筛质数算法。</p><p>然而最近我才知道，线性筛不仅仅是用来筛质数的，还能用来求积性函数。</p><a id="more"></a><h1 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h1><p>首先，之前学过的埃氏筛法是将合数标记的算法。</p><p>但是埃氏筛法会将重复的合数标记，这就造成了效率不够高。</p><p>而线性筛法就是不会重复标记合数的算法，因此使得效率由埃氏筛法的$O(n\log \log n)$变为$O(n)$。</p><p>主题思想为，在生成一个需要标记的合数时，每次只向现有的数乘上一个质因子，并且让它是这个合数的最小质因子。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其中$v[i]$表示数$i$的最小质因子，$prime[i]$表示第$i$个质数，$m$代表质数个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],m=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这便是在我写下这笔记之前的对线性筛的全部认知。</p><p>然而最近看到了线性筛求积性函数。</p><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>首先，积性函数的定义是：</p><p>一个积性函数$f(x)$，满足互质的两数$a,b$，$f(ab)=f(a)f(b)$。</p><p>“互质”这个条件，便可以想到线性筛了。</p><p>举几个积性函数的例子。</p><p>定义$v[i]$表示$i$的最小质因子。</p><p>定义$prime[i]$表示第$i$个质数。</p><p>定义$num[x]$表示$x$的最小质因子$p_i$对于因数个数的贡献，即$c_i$。</p><p>定义$factor[x]$表示$x$的因子个数。</p><p>定义$sum[x]$表示$x$的因子和。</p><p>定义$pow_{sum}[x]$表示$x$的最小质因子$p_i$对于因数和的贡献，即$\sum_{i=0}^{c_i}p_i^j$。</p><p>定义$euler[x]=\varphi(x)$。</p><h2 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h2><p>由算术基本定理，任意一个大于$1$的正整数都可以分解为有限个质数的乘积。</p><p>则$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$factor[x]=\prod_{i=1}^m (c_i+1)$，这个式子便是后面实现的关键所在。</p><p>关于$factor[x]$为积性函数，显然，证明略。</p><p>那么，就可以在用线性筛筛质数的过程中“顺便”求个积性函数了。</p><p>根据上面的线性筛写法，进行分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，因子个数为$1+1=2$,此时$num[i]=1$。</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">factor[i*prime[j]]=factor[i]/(num[i]+1)*(num[i]+2)</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">num[i*prime[j]]=num[i]+1</script></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">factor[i*prime[j]]=factor[i]* factor[prime[j]]</script><p>由于$prime[j]$即为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">num[i*prime[j]]=1</script></li></ul><p>完成。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],num[<span class="number">1000010</span>],factor[<span class="number">1000010</span>],m=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">factor[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">num[i]=<span class="number">1</span>;</span><br><span class="line">factor[i]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]*factor[prime[j]];</span><br><span class="line">num[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]/(num[i]+<span class="number">1</span>)*(num[i]+<span class="number">2</span>);</span><br><span class="line">num[i*prime[j]]=num[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="因数和"><a href="#因数和" class="headerlink" title="因数和"></a>因数和</h2><p>同上，$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$sum[x]=\prod_{i=1}^m(\sum_{j=0}^{c_i}p_i^{j})$，这个式子为后面实现的关键所在，同样，这玩意也是个积性函数。</p><p>那么，同上，线性筛，分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，因数和为$i+1$，此时$pow_{sum}[i]=i+1$。</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">sum[i*prime[j]]=sum[i]/pow_{sum}[i]*(pow_{sum}[i]*prime[j]+1)</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">pow_{sum}[i*prime[j]]=pow_{sum}[i]*prime[j]+1</script></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">sum[i*prime[j]]=sum[i]*sum[prime[j]]</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">pow_{sum}[i*prime[j]]=prime[j]+1</script></li></ul><p>完成。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],sum[<span class="number">1000010</span>],pow_sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">pow_sum[i]=i+<span class="number">1</span>;</span><br><span class="line">sum[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]*sum[prime[j]];</span><br><span class="line">pow_sum[i*prime[j]]=prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]/pow_sum[i]*(pow_sum[i]*prime[j]+<span class="number">1</span>);</span><br><span class="line">pow_sum[i*prime[j]]=pow_sum[i]*prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数$\varphi(x)$表示对于正整数$x$，小于或等于$x$的正整数中与$x$互质的数的个数，其中$\varphi(1)=1$。</p><p>同上，$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$\varphi(x)=x\prod_{i=1}^m(1-\frac{1}{p_i})$，这个式子是后面实现的关键。这玩意依旧是个积性函数。</p><p>令$euler[x]=\varphi(x)$。</p><p>同上，线性筛，分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，小于其的正整数均小于它，则$euler[i]=i-1$</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">euler[i*prime[j]]=eular[i]*prime[j]</script><p>(可由定义式推出)</p></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">euler[i*prime[j]]=euler[i]*euler[prime[j]]</script></li></ul><p>完成。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,prime[<span class="number">40010</span>],v[<span class="number">40010</span>],euler[<span class="number">40010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[prime[j]*i]=euler[prime[j]]*euler[i];</span><br><span class="line"><span class="keyword">else</span> euler[prime[j]*i]=prime[j]*euler[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是举了几个积性函数的例子，以后遇到其他的积性函数要灵活运用，貌似还有个啥狄利克雷卷积啥的东西，那便是之后的事了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3708] koishi的数学题</title>
      <link href="/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P3708%5D-koishi%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P3708%5D-koishi%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数$n$。</p><p>设$f(x)=\sum_{i=1}^nx\mod i$，输出$f(1),f(2),……,f(n)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 20\%$的数据，$n \le 1000$。<br>对于$ 60\%$的数据，$n \le 10^5$。<br>对于$100\%$的数据，$1 \le n \le 10^6$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3708" target="_blank" rel="noopener">P3708 koishi的数学题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>也就是$1-n$的剩余系依次相加。</p><p>每次向答案中加$n$，表示每个数的剩余系都向后移动了一个。</p><p>但是一定会有一些数加上$1$后大于其所对应剩余系的最大值。</p><p>这些数实质上也就是$n$的因子。</p><p>因此再减去$n$的因子和。</p><p>而因为因子和是积性函数，所以考虑线性筛。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,sum[<span class="number">1000010</span>],v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],pow_sum[<span class="number">1000010</span>],pow_low[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">sum[i]=i+<span class="number">1</span>;</span><br><span class="line">pow_sum[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(!(i%prime[j])) &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]/pow_sum[i]*(pow_sum[i]*prime[j]+<span class="number">1</span>);</span><br><span class="line">pow_sum[i*prime[j]]=pow_sum[i]*prime[j]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum[i*prime[j]]=sum[i]*sum[prime[j]];</span><br><span class="line">pow_sum[i*prime[j]]=prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ans=ans+n-sum[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来翻了翻题解，发现一个贼神奇的做法。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fem6gw95.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/fem6gw95.png"></p><p>妙啊。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4868] Preprefix sum</title>
      <link href="/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P4868%5D-Preprefix-sum/"/>
      <url>/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P4868%5D-Preprefix-sum/</url>
      
        <content type="html"><![CDATA[<p>给定一个序列$a$，有两种操作：</p><ol><li>$Modify\ \  i\ \ x$：把$a_i$改为$x$</li><li>$Query\ \ i$：查询前缀和$S[i]$的前缀和$SS[i]$，并输出。</li></ol><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1&lt;=N,M&lt;=100000$,且在任意时刻$0&lt;=A_i&lt;=100000$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4868" target="_blank" rel="noopener">P4868 Preprefix sum</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>易得$SS[n]=\sum_{i=1}^n(n-i+1)a_i=\sum_{i=1}^n(n+1)a_i-\sum_{i=1}^ni*a_i$</p><p>那么维护两个树状数组$sum_1$与$sum_2$即可。其中</p><p>$sum_1[n]=\sum_{i=1}^n a_i$</p><p>$sum_2[n]=\sum_{i=1}^n i*a_i$</p><p>每次$Modify$更新。</p><p>$Query$查询$i$时，用$(i+1)*sum_1[i]-sum_2[i]$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[<span class="number">100010</span>],sum_1[<span class="number">100010</span>],sum_2[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,ll y)</span> </span>&#123;</span><br><span class="line">ll ty=y*x;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) &#123;</span><br><span class="line">sum_1[x]+=y;</span><br><span class="line">sum_2[x]+=ty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x+<span class="number">1</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=t*sum_1[x]-sum_2[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">update(i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">string</span> ins;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">ll y;</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">"Modify"</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">update(x,y-a[x]);</span><br><span class="line">a[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF630C] Lucky Numbers</title>
      <link href="/is-zxy.github.io/2019/12/27/%5BCF630C%5D-Lucky-Numbers/"/>
      <url>/is-zxy.github.io/2019/12/27/%5BCF630C%5D-Lucky-Numbers/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，求不超过$n$位的只有数字$7$和$8$组成的数字有多少个。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p> $(1&lt;=n&lt;=55)$  </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF630C" target="_blank" rel="noopener">CF630C Lucky Numbers</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把$7$和$8$看作是$0$和$1$，那么其实$n$位的个数就是$2^n$个。</p><p>总方案数也就是$\sum_{i=1}^n2^i=2^{n+1}-2$。</p><p>本以为是个好题，看来又是恶意评分啊。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ull n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((ull)<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)-(ull)<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF702B] Powers of Two</title>
      <link href="/is-zxy.github.io/2019/12/26/%5BCF702B%5D-Powers-of-Two/"/>
      <url>/is-zxy.github.io/2019/12/26/%5BCF702B%5D-Powers-of-Two/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$n$的序列$a$，从中选取$a_i$，$a_j$，使得$a_i+a_j=2^x$，$(x∈N^+,i&lt;j)$。求序列中有多少对这样的数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p> $(1&lt;=n&lt;=10^{5})$ </p><p> $(1&lt;=a_{i}&lt;=10^{9})$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF702B" target="_blank" rel="noopener">CF702B Powers of Two</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对序列从小到大排序，去重，并令原序列中中数$i$的个数为$js[i]$，那么</p><p>当$a_i&lt;2^{x-1}$时，根据乘法原理，对数即为$js[a_i]*js[2^x-a_i]$。</p><p>当$a_{i}<script type="math/tex">=</script>2^{x-1}$时，则对数为$C_{js[a_i]}^{2}$，即为$\frac{js[a_i]\times(js[a_i]-1)}{2}$。</p><p>当$a_i&gt;2^{x-1}$无须考虑，与第一种情况重复。</p><p>范围$10^9$，则只需要到$2^{30}$，时间复杂度约为$O(30n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,t[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>,ll&gt; js;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> maxn)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++) &#123;</span><br><span class="line"><span class="keyword">if</span>(*it&gt;maxn) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(maxn==*it) ans+=(js[*it]*(js[*it]<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=js[*it]*js[maxn*<span class="number">2</span>-*it];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) t[i]=t[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">a.insert(x);</span><br><span class="line">js[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) work(t[i]/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO09DEC] 牛收费路径</title>
      <link href="/is-zxy.github.io/2019/12/25/%5BUSACO09DEC%5D-%E7%89%9B%E6%94%B6%E8%B4%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/is-zxy.github.io/2019/12/25/%5BUSACO09DEC%5D-%E7%89%9B%E6%94%B6%E8%B4%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>给定$n$个点，$m$个双向边，点有点权，边有边权。有$k$个询问，要求$s_i$到$t_i$的最小费用，其中费用定义为经过所有边权和与经过所有点的点权最大值之和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1 &lt;= N &lt;= 250)$</p><p>$ (1 &lt;= M &lt;= 10000) $</p><p>$ (1 &lt;= A_j &lt;= N,1 &lt;= B_j &lt;= N) $</p><p>$(1 &lt;= L_j &lt;= 100,000)$</p><p>$(1 &lt;= C_i &lt;= 100000) $</p><p>$ (1 &lt;= K &lt;= 10,000) $</p><p>$ (1 &lt;= s_i &lt;= N; 1 &lt;= t_i &lt;= N; s_i != t_i)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2966" target="_blank" rel="noopener">[USACO09DEC]牛收费路径</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>范围很小，$250$，便考虑$Floyd$。</p><p>本题难点就在于点权$value$的处理。可以在跑$Floyd$的同时对点权最大进行处理。</p><p>目前在求$i$到$j$以$k$为中继点的最短路径$d[i][j]$，那么此时$i$到$j$的最小费用$ans[i][j]$便可表为</p><p>$min(ans[i][j],d[i][j]+max(value[i],value[j],value[k]))$。</p><p>为了保证此时$value[i]$、$value[j]$、$value[k]$中有$i$到$j$的最小费用路径中的最大点权，可以将各点按照点权值从小到大排序，这样$Floyd$一遍，然后针对每个询问输出解即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,t[<span class="number">310</span>],d[<span class="number">310</span>][<span class="number">310</span>],ans[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value,id;</span><br><span class="line">&#125;p[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.value==y.value) <span class="keyword">return</span> x.id&lt;y.id;</span><br><span class="line"><span class="keyword">return</span> x.value&lt;y.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">ans[i][j]=min(ans[i][j],d[i][j]+max(p[i].value,max(p[j].value,p[k].value)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;p[i].value,p[i].id=i;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t[p[i].id]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">x=t[x],y=t[y];</span><br><span class="line">d[x][y]=d[y][x]=min(z,d[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Floyd();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">x=t[x],y=t[y];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USACO </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
