<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[USACO08FEB] Hotel G</title>
      <link href="/is-zxy.github.io/2020/03/22/%5BUSACO08FEB%5D-Hotel-G/"/>
      <url>/is-zxy.github.io/2020/03/22/%5BUSACO08FEB%5D-Hotel-G/</url>
      
        <content type="html"><![CDATA[<p>参考样例，第一行输入$n$，$m$ ，$n$代表有$n$个房间，编号为$1\sim n$，开始都为空房，$m$表示以下有$m$行操作，以下 每行先输入一个数$i$，表示一种操作：</p><p>若$i$为$1$，表示查询房间，再输入一个数$x$，表示在$1\sim n$房间中找到长度为$x$的连续空房，输出连续$x$个房间中左端的房间号，尽量让这个房间号最小，若找不到长度为$x$的连续空房，输出$0$，并且在这$x$个空房间中住上人。</p><p>若$i$为$2$，表示退房，再输入两个数$x$，$y$ 代表房间号$x\sim x+y-1$退房，即让房间为空。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 50,000$</p><p>$1\le m\le 50,00$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2894" target="_blank" rel="noopener">[USACO08FEB]Hotel G</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>觉得很类似<a href="http://zxyer.xyz/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/" target="_blank" rel="noopener">[SP1716] GSS3 - Can you answer these queries III</a>。</p><p>需要维护的信息：一个区间的最大连续空房个数，一个区间左端的最大连续空房个数，一个区间右端的最大连续空房个数，lazytag。</p><p>由于change有两种操作，退房与入住，所以当lazytag=1时表示退房，lazytag=2时表示入住。</p><p>本题的重点在于查询操作的写法，分类讨论区间左中右哪里满足最大连续空房个数大于等于$x$，但一定注意要<strong>左中右</strong>顺序，因为要求输出最左端的房间号。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,lmax,rmax,sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(x) tree[x].lmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(x) tree[x].rmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">lm(p)=rm(p)=s(p)=r-l+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)==<span class="number">1</span>) &#123;</span><br><span class="line">lm(ls)=rm(ls)=s(ls)=r(ls)-l(ls)+<span class="number">1</span>;</span><br><span class="line">lm(rs)=rm(rs)=s(rs)=r(rs)-l(rs)+<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">lazy(ls)=lazy(rs)=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">lm(ls)=rm(ls)=s(ls)=lm(rs)=rm(rs)=s(rs)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">lazy(ls)=lazy(rs)=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s(ls)==r(ls)-l(ls)+<span class="number">1</span>) lm(p)=s(ls)+lm(rs);</span><br><span class="line"><span class="keyword">else</span> lm(p)=lm(ls);</span><br><span class="line"><span class="keyword">if</span>(s(rs)==r(rs)-l(rs)+<span class="number">1</span>) rm(p)=s(rs)+rm(ls);</span><br><span class="line"><span class="keyword">else</span> rm(p)=rm(rs);</span><br><span class="line">s(p)=max(max(s(ls),s(rs)),rm(ls)+lm(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=<span class="number">0</span>;</span><br><span class="line">lazy(p)=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">push_up(ls,l,r);</span><br><span class="line">push_up(rs,l,r);</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">lm(p)=rm(p)=s(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">push_down(ls,l,r);</span><br><span class="line">push_down(rs,l,r);</span><br><span class="line">update(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) <span class="keyword">return</span> l(p);</span><br><span class="line"><span class="keyword">if</span>(s(ls)&gt;=x) <span class="keyword">return</span> ask(ls,x);</span><br><span class="line"><span class="keyword">if</span>(rm(ls)+lm(rs)&gt;=x) <span class="keyword">return</span> r(ls)-rm(ls)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ask(rs,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> op,x,y;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(s(<span class="number">1</span>)&lt;x) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> l=ask(<span class="number">1</span>,x);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">push_up(<span class="number">1</span>,l,l+x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">push_down(<span class="number">1</span>,x,x+y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1471] 方差</title>
      <link href="/is-zxy.github.io/2020/03/21/%5B%E6%B4%9B%E8%B0%B7P1471%5D-%E6%96%B9%E5%B7%AE/"/>
      <url>/is-zxy.github.io/2020/03/21/%5B%E6%B4%9B%E8%B0%B7P1471%5D-%E6%96%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<p>有一包含$n$个数的序列，对其进行$m$次操作，有如下三种操作：</p><p>操作1：$1\;x\;y\;k$，表示将第$x$到第$y$项每项加上$k$，$k$为一实数。</p><p>操作2：$2\;x\;y$，表示求出第$x$到第$y$项这一子数列的平均数。</p><p>操作3：$3\;x\;y$，表示求出第$x$到第$y$项这一子数列的方差。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n,m\le 100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1471" target="_blank" rel="noopener">P1471 方差</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>操作$1,2$很好搞。</p><p>将方差的式子拆开就会发现需要维护区间平方和以及区间和，这样就又变成了一个区间修改的线段树问题。</p><script type="math/tex; mode=display">\begin{align}s^2 &= \frac{1}{n}\sum_{i=1}^n(A_i-\bar{A})^2 \\s^2 &= \frac{1}{n}\sum_{i=1}^n(A_i^2-2\bar{A}A_i+\bar{A}^2) \\s^2 &= \frac{1}{n}\left[\sum_{i=1}^nA_i^2-2\bar{A}\sum_{i=1}^nA_i+n\bar{A}^2\right]\end{align}</script><p>据此维护即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,op,x,y;</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">double</span> sum,ssum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ss(x) tree[x].ssum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s(p);</span><br><span class="line">ss(p)=s(p)*s(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">ss(p)=ss(ls)+ss(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line">ss(ls)+=<span class="number">2</span>*s(ls)*lazy(p)+(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">ss(rs)+=<span class="number">2</span>*s(rs)*lazy(p)+(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p)*lazy(p);</span><br><span class="line">s(ls)+=(r(ls)-l(ls)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">s(rs)+=(r(rs)-l(rs)+<span class="number">1</span>)*lazy(p);</span><br><span class="line">lazy(ls)+=lazy(p);</span><br><span class="line">lazy(rs)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">ss(p)+=<span class="number">2</span>*s(p)*x+(r(p)-l(p)+<span class="number">1</span>)*x*x;</span><br><span class="line">s(p)+=(r(p)-l(p)+<span class="number">1</span>)*x;</span><br><span class="line">lazy(p)+=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r,x);</span><br><span class="line">change(rs,l,r,x);</span><br><span class="line">s(p)=s(ls)+s(rs);</span><br><span class="line">ss(p)=ss(ls)+ss(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask_s</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> s(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask_s(ls,l,r)+ask_s(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask_ss</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> ss(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask_ss(ls,l,r)+ask_ss(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change(<span class="number">1</span>,x,y,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;ask_s(<span class="number">1</span>,x,y)/(y-x+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">double</span> qsum=ask_s(<span class="number">1</span>,x,y);</span><br><span class="line"><span class="keyword">double</span> ave=qsum/(y-x+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;(ask_ss(<span class="number">1</span>,x,y)<span class="number">-2</span>*ave*qsum+(y-x+<span class="number">1</span>)*ave*ave)/(y-x+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2574] XOR的艺术</title>
      <link href="/is-zxy.github.io/2020/03/20/%5B%E6%B4%9B%E8%B0%B7P2574%5D-XOR%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/is-zxy.github.io/2020/03/20/%5B%E6%B4%9B%E8%B0%B7P2574%5D-XOR%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><ol><li>拥有一个伤害串，是一个长度为$n$的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从$1$开始。</li><li>给定一个范围$[l,r]$，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</li><li>会修改伤害串中的数值，修改的方法是把 $[l,r]$中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</li></ol><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 10\%$的数据，保证$n, m \leq 10$。</p><p>另有$30\%$的数据，保证$n, m \leq 2 \times 10^3$。</p><p>对于$100\%$的数据，保证$2 \leq n, m \leq 2 \times 10^5$，$0 \leq op \leq 1$，$1 \leq l \leq r \leq n$，$S$中只含字符 <code>0</code> 和字符 <code>1</code>。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2574" target="_blank" rel="noopener">P2574 XOR的艺术</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然是个数据结构题。</p><p>考虑线段树，由于涉及区间修改，需要lazytag。</p><p>此处能lazytag的依据是，一个区间”翻转”两次相当于没有翻转。</p><p>操作过程很好想，不再赘述。</p><p>注意标记下传。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,op,l,r;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=s[tot++]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(ls)+sum(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy(p)) <span class="keyword">return</span> ;</span><br><span class="line">sum(ls)=r(ls)-l(ls)+<span class="number">1</span>-sum(ls);</span><br><span class="line">sum(rs)=r(rs)-l(rs)+<span class="number">1</span>-sum(rs);</span><br><span class="line">lazy(ls)^=<span class="number">1</span>;</span><br><span class="line">lazy(rs)^=<span class="number">1</span>;</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=r(p)-l(p)+<span class="number">1</span>-sum(p);</span><br><span class="line">lazy(p)^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line">change(ls,l,r);</span><br><span class="line">change(rs,l,r);</span><br><span class="line">sum(p)=sum(ls)+sum(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">return</span> ask(ls,l,r)+ask(rs,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">if</span>(!op) change(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多倍经验"><a href="#多倍经验" class="headerlink" title="多倍经验"></a>多倍经验</h3><p><a href="https://www.luogu.com.cn/problem/P3870" target="_blank" rel="noopener">[TJOI2009]开关</a></p><p><a href="https://www.luogu.com.cn/problem/P2846" target="_blank" rel="noopener">[USACO08NOV]Light Switching </a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TJOI2018] 数学计算</title>
      <link href="/is-zxy.github.io/2020/03/20/%5BTJOI2018%5D-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
      <url>/is-zxy.github.io/2020/03/20/%5BTJOI2018%5D-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>小豆现在有一个数$x$，初始值为$1$。小豆有$Q$次操作，操作有两种类型：</p><p>$1\;m$：$x=x\times m$输出$x\%mod$；</p><p>$2\;pos$：$x= x/$第$pos$次操作所乘的数（保证第$pos$次操作一定为类型$1$,对于每一个类型$1$的操作至多会被除一次）输出$x\%mod$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$1\leq Q\leq500$</p><p>对于$100\%$的数据，$1\leq Q\leq100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4588" target="_blank" rel="noopener">[TJOI2018]数学计算</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用线段树维护一个长度为$Q$的序列。</p><p>初始时全为$1$，操作时单点修改即可，答案即为线段树的根节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,Q,op;</span><br><span class="line">ll m,mod;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d(x) tree[x].data</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r,d(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,ll v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">d(p)=v;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) change(ls,x,v);</span><br><span class="line"><span class="keyword">else</span> change(rs,x,v);</span><br><span class="line">d(p)=mul(d(ls),d(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">1</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;Q,&amp;mod);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;op,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">change(<span class="number">1</span>,i,m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">change(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> TJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF743C] Vladik and fractions</title>
      <link href="/is-zxy.github.io/2020/03/20/%5BCF743C%5D-Vladik-and-fractions/"/>
      <url>/is-zxy.github.io/2020/03/20/%5BCF743C%5D-Vladik-and-fractions/</url>
      
        <content type="html"><![CDATA[<p>请找出一组合法的解使得$\frac {1}{x} + \frac{1}{y} + \frac {1}{z} = \frac {2}{n}$成立<br>其中$x,y,z$为正整数并且互不相同</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le n\le 10^4$，要求答案$x,y,z\le 2\times 10^9$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF743C" target="_blank" rel="noopener">CF743C Vladik and fractions</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没想出来，看了题解，妙啊..</p><p>当$n&gt;0$时</p><script type="math/tex; mode=display">\frac{1}{n(n+1)}=\frac{1}{n}-\frac{1}{n+1}</script><p>移项</p><script type="math/tex; mode=display">\frac{1}{n}=\frac{1}{n+1}+\frac{1}{n(n+1)}</script><p>两边同时加$\frac{1}{n}$</p><script type="math/tex; mode=display">\frac{2}{n}=\frac{1}{n}+\frac{1}{n+1}+\frac{1}{n(n+1)}</script><p>于是得解。</p><p>由于$x,y,z$互不相同，所以$n=1$时特判输出$-1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;n+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n*(n+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正向不好解决时，考虑反向推。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 构造 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO04OPEN] MooFest</title>
      <link href="/is-zxy.github.io/2020/03/19/%5BUSACO04OPEN%5D-MooFest/"/>
      <url>/is-zxy.github.io/2020/03/19/%5BUSACO04OPEN%5D-MooFest/</url>
      
        <content type="html"><![CDATA[<p>每一年，约翰的$N$只奶牛参加奶牛狂欢节。这是一个全世界奶牛都参加的大联欢。狂欢节包括很多有趣的活动，比如干草堆叠大赛、跳牛栏大赛，奶牛之间有时还相互扎屁股取乐。当然，她们会排成一列嚎叫，来欢庆她们的节日。奶牛们的叫声实在刺耳，以致于每只奶牛的听力都受到不同程度的损伤。现在告诉你奶牛$i$的听力为$v_i$，这表示如果奶牛$j$想说点什么让她听到，必须用高于$ v_i \times dis(i,j)$的音量。因此，如果奶牛$i$和$j$想相互交谈，她们的音量必须不小于$\max (v_i,v_j) \times dis(i,j)$。其中$dis(i,j)$表示她们间的距离。</p><p>现在$N$只奶牛都站在一条直线上了，每只奶牛还有一个坐标$x_i$。如果每对奶牛都在交谈，并且使用最小音量，那所有$N(N-1)/2$对奶牛间谈话的音量之和为多少？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>因为原数据下$O(N^2)$算法可以通过，所以新添加了一些增强数据。</p><p>原数据作为子任务$1$，新添加的数据作为子任务$2$。</p><ul><li>子任务$1$（$1$分）：$1 \leq N,V_i,x_i \leq 2 \times 10^4$。</li><li>子任务$2$（$99$分）：$1 \leq N,V_i,x_i \leq 5 \times 10^4$。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5094" target="_blank" rel="noopener">[USACO04OPEN]MooFest</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接模拟的暴力$O(N^2)$算法肯定是过不了的。</p><p>考虑排序。将奶牛按$v$的值从小到大进行排序，这样依次处理，这样便可以保证目前正处理的奶牛的$v$值是所有被处理过的最大的。那么还需要解决的问题就是求出被处理过的奶牛中坐标比处理中的奶牛坐标小、大的个数以及坐标总和。可以考虑树状数组在线维护，只需两个，维护比其小坐标数与和，比其大可通过其求出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll v[N],x[N],js[N],sum[N],s=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll v,x;</span><br><span class="line">&#125;cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.v&lt;y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll t=x;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;N;x+=lowbit(x)) js[x]+=<span class="number">1</span>,sum[x]+=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask_js</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=js[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask_sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=sum[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;cow[i].v&gt;&gt;cow[i].x;</span><br><span class="line"></span><br><span class="line">sort(cow+<span class="number">1</span>,cow+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> as=ask_sum(cow[i].x),aj=ask_js(cow[i].x);</span><br><span class="line">ans+=(aj*cow[i].x-as)*cow[i].v;</span><br><span class="line">ans+=(s-as-(i<span class="number">-1</span>-aj)*cow[i].x)*cow[i].v;</span><br><span class="line">update(cow[i].x);</span><br><span class="line">s+=cow[i].x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JSOI2008] 星球大战</title>
      <link href="/is-zxy.github.io/2020/03/17/%5BJSOI2008%5D-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/"/>
      <url>/is-zxy.github.io/2020/03/17/%5BJSOI2008%5D-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。</p><p>某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。</p><p>但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。</p><p>现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1197" target="_blank" rel="noopener">[JSOI2008]星球大战</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据每次打击的目标，删边再搞？</p><p>显然过于暴力，铁定TLE。</p><p>难道非要在线吗？</p><p>考虑离线做法。</p><p>将打击对象全部读入后，倒序处理。当处理到底$i$个目标时$(i\in[1,k])$，将与第$i+1$个目标相连的所有路给修起来。特别的，当处理第$k$个目标时，将所有不与这$k$个目标相连的路给修起来。然后每次并查集求出连通块数量存入数组。</p><p>最后正序输出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],k,atk[N],vset[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].u=u;</span><br><span class="line">edge[tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(vset[i]==i) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(edge[i].u==x||edge[i].v==x) &#123;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">vh[atk[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">ans[k]=ask()-k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">vh[atk[i+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">build(atk[i+<span class="number">1</span>]);</span><br><span class="line">ans[i]=ask()-i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交后，TLE了7个点。</p><p>发现这是个傻逼写法。build函数写的有大问题，既然修与$x$连通的点，为何还需要遍历所有边？于是改了改build函数，还是TLE。</p><p>考虑优化，发现每次加入一个点，其连通块的个数其实是可以从未加入此点时的连通块个数得出来的。即build函数中，连通了$x$次，那么连通块的个数就减少了$x-1$个。因为每连通一次，连通块就减少一个。而刚加入这个点时，连通块增加了一个，于是就是减少了$x-1$个连通块。</p><p>这样大大优化后，便可以AC了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,head[N],k,atk[N],vset[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].u=u;</span><br><span class="line">edge[tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].u]||vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(vset[i]==i) ans++;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[edge[i].v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(edge[i].u==x||edge[i].v==x) &#123;</span><br><span class="line"><span class="keyword">int</span> fu=find(edge[i].u),fv=find(edge[i].v);</span><br><span class="line"><span class="keyword">if</span>(fu!=fv) &#123;</span><br><span class="line">vset[fu]=fv;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">vh[atk[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">ans[k]=ask()-k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">vh[atk[i+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=build(atk[i+<span class="number">1</span>]);</span><br><span class="line">ans[i]=ans[i+<span class="number">1</span>]+<span class="number">1</span>-tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSOI </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2013] 随机数生成器</title>
      <link href="/is-zxy.github.io/2020/03/16/%5BSDOI2013%5D-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/is-zxy.github.io/2020/03/16/%5BSDOI2013%5D-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>小W喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有$P$页，页码范围为$0 \cdots P-1$。</p><p>小W很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用NOI2012上学习的线性同余法生成一个序列，来决定每天具体读哪一页。</p><p>我们用$X_i$来表示通过这种方法生成出来的第$i$个数，也即小W第$i$天会读哪一页。这个方法需要设置$3$个参数$a,b,X_1$，满足$0\leq a,b,X_1\leq p-1$，且$a,b,X_1$都是整数。按照下面的公式生成出来一系列的整数：$X_{i+1} \equiv aX_i+b \pmod p$其中$\bmod$表示取余操作。</p><p>但是这种方法可能导致某两天读的页码一样。</p><p>小W要读这本书的第$t$页，所以他想知道最早在哪一天能读到第$t$页，或者指出他永远不会读到第$t$页。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$0≤a≤P−1,0≤b≤P−1,2≤P≤10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3306" target="_blank" rel="noopener">[SDOI2013]随机数生成器</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分类讨论一下。</p><ul><li><p>当$a=0$时，$X_i,i\ge 2$一直为$b$，判断$b$是否等于$t$即可。</p></li><li><p>当$a=1$时，$X_{i+1}=X_i+b$，显然是个等差数列，$X_n=X_1+(n-1)b$。</p><p>那么所求的天数$n$即为满足$X_1+(n-1)b\equiv t\pmod p$的最小非负整数解。</p><p>这可以用扩欧进行求解。</p></li><li><p>当$a\ge1$时，$X_{i+1}=aX_i+b$。</p><p>待定系数法搞一下，设$X_{i+1}+k=a(X_i+k)$，解得$k=\frac{b}{a-1}$。</p><p>代入即</p><script type="math/tex; mode=display">X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1})</script><p>那么数列$Y_n=X_n+\frac{b}{a-1}$为一个公比为$a$的等比数列。</p><p>由于$X_1$已知，可以求出$Y_1=X_1+\frac{b}{a-1}$。</p><p>那么</p><script type="math/tex; mode=display">Y_n=(X_1+\frac{b}{a-1})a^{n-1}</script></li></ul><p>  则</p><script type="math/tex; mode=display">  X_n=(X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}</script><p>  则所求的天数$n$即为满足</p><script type="math/tex; mode=display">  (X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}\equiv t\pmod p</script><p>  稍微移个项，化个简</p><script type="math/tex; mode=display">  \begin{align}  (X_1+\frac{b}{a-1})a^{n-1} &\equiv t+\frac{b}{a-1}\pmod p \\  a^{n-1} &\equiv \frac{t+\frac{b}{a-1}}{X_1+\frac{b}{a-1}}\pmod p \\  a^{n-1} &\equiv \frac{at-t+b}{aX_1-X_1+b}\pmod p \\  a^{n-1} &\equiv (at-t+b)\times (aX_1-X_1+b)^{-1}\pmod p  \end{align}</script><p>  注意不能两边同乘一个$a$过去，否则会出带问题！会解出来$0$的。这里只需解出来后加一即可。由于$p$为质数，所以可以用$BSGS$求出$n$的值。</p><p>  其中$(aX_1-X_1+b)^{-1}$表示模$p$意义下的逆元，由于保证$p$为质数，可用费马小定理求出来。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p+p)%p)*((y%p+p)%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll p,a,b,X_1,t,x,y;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(x,mul(t,t));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)),tmp=b,t=quickp(a,k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=mul(tmp,a);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=mul(tmp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>,&amp;p,&amp;a,&amp;b,&amp;X_1,&amp;t);</span><br><span class="line"><span class="keyword">if</span>(X_1==t) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!a) &#123;</span><br><span class="line"><span class="keyword">if</span>(b==t) <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>) &#123;</span><br><span class="line">ll Y=((t+b-X_1)%p+p)%p,gcd=EXGCD(b,p,x,y),ans;</span><br><span class="line"><span class="keyword">if</span>(Y%gcd) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x*=Y/gcd;</span><br><span class="line">ans=(x%p+p)%p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,!ans?p:ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll A=a,B=mul(mul(a,t)-t+b,quickp(mul(mul(a,X_1)-X_1+b,<span class="number">1</span>),p<span class="number">-2</span>));</span><br><span class="line">ll ans=BSGS(A,B,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交了十几遍，结果发现错误原因是求$a\not=1$时的式子时，用自己写的<code>mul</code>操作后可能为负…..于是把<code>mul</code>给改了，保证俩大于$0$。代码中的<code>mul(a,X_1)-X_1+b,1)</code>也是为了保证其大于$0$而这样写的。<del>果然我太弱了呢</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4884] 多少个1？</title>
      <link href="/is-zxy.github.io/2020/03/15/%5B%E6%B4%9B%E8%B0%B7P4884%5D-%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F/"/>
      <url>/is-zxy.github.io/2020/03/15/%5B%E6%B4%9B%E8%B0%B7P4884%5D-%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>给定整数$K$和质数$m$，求最小的正整数$N$，使得$11\cdots1$（$N$个$1$）$ \equiv K \pmod m$</p><p>说人话：就是$111…1111 \bmod m =K$</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$30\%$的数据保证$m\leq 10^6$</p><p>$60\%$的数据保证$m\leq 5\times 10^7$</p><p>$100\%$的数据保证$2\leq m\leq 10^{11},0\leq K&lt; m$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4884" target="_blank" rel="noopener">P4884 多少个1？</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>令$11\cdots1$（$N$个$1$）等于$Q$。</p><p>即</p><script type="math/tex; mode=display">Q\equiv K\pmod m</script><p>则</p><script type="math/tex; mode=display">9Q \equiv 9K\pmod m</script><p>而$9Q=10^N-1$，则</p><script type="math/tex; mode=display">10^N-1\equiv 9K\pmod m</script><p>即</p><script type="math/tex; mode=display">10^N\equiv 9K+1\pmod m</script><p>保证$m$为质数了，所以直接BSGS即可。</p><p>$m\le 10^{11}$，可能爆long long。需要写个龟速乘。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll k,m,ans;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll x,ll y,ll p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(x,plus(t,t));</span><br><span class="line"><span class="keyword">return</span> plus(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y,ll p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> gsc(x,gsc(t,t,p),p);</span><br><span class="line"><span class="keyword">return</span> gsc(t,t,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll tmp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=gsc(tmp,a,p);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=gsc(tmp,t,p);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">ans=BSGS(<span class="number">10</span>,<span class="number">9</span>*k+<span class="number">1</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2011] 计算器</title>
      <link href="/is-zxy.github.io/2020/03/15/%5BSDOI2011%5D-%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/is-zxy.github.io/2020/03/15/%5BSDOI2011%5D-%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>你被要求设计一个计算器完成以下三项任务：</p><ol><li>给定$y,z,p$，计算$ y^z \bmod p$的值；</li><li>给定$ y,z,p$，计算满足$ xy \equiv z \pmod p$的最小非负整数$ x$；</li><li>给定$ y,z,p$，计算满足$ y^x \equiv z \pmod p$的最小非负整数$ x$。</li></ol><p>为了拿到奖品，全力以赴吧！</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>测试点共分为三类，各类测试点占总测试点的比例如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$K=$</th><th style="text-align:center">测试点占比</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$20\%$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$35\%$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$45\%$</td></tr></tbody></table></div><p>所有数据均满足：$1 \leq y,z,p \leq 10^9$，$p$是质数，$1 \leq T \leq 10$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2485" target="_blank" rel="noopener">[SDOI2011]计算器</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于保证$p$是质数，所以导致本题及其好做。</p><p>对于第一项任务，快速幂即可。</p><p>对于第二项任务，EXGCD即可。</p><p>对于第三项任务，BSGS即可。</p><p>调了两小时找不出错，最后发现变量名（y）重复了….崩溃….<del>果然我是个制杖呢</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,k;</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line">ll k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll tmp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">tmp=mul(tmp,a);</span><br><span class="line">vh[tmp]=j;</span><br><span class="line">&#125;</span><br><span class="line">tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">tmp=mul(tmp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[tmp]) <span class="keyword">return</span> ((i*k-vh[tmp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">ll a,z,p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;z&gt;&gt;p;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;quickp(a,z,p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">2</span>) &#123;</span><br><span class="line">ll gcd=EXGCD(a,p,x,y);</span><br><span class="line"><span class="keyword">if</span>(z%gcd) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Orz, I cannot find x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;((x*(z/gcd))%p+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">3</span>) &#123;</span><br><span class="line">ll ans=BSGS(a,z,p);</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Orz, I cannot find x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">work(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
            <tag> SDOI </tag>
            
            <tag> EXGCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS及EXBSGS算法学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/15/BSGS%E5%8F%8AEXBSGS%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/15/BSGS%E5%8F%8AEXBSGS%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>BSGS是用来解决离散对数问题的一种算法。</p><p>离散对数问题是这样一个问题，它是要求解模方程</p><script type="math/tex; mode=display">a^x\equiv b\pmod p</script><a id="more"></a><h1 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h1><p>首先来看$p$为质数的情况。</p><p>因为$a$与$p$互质，由费马小定理得$a^{p-1}=1\pmod p$。</p><p>取模值循环出现，于是可以判断，若有解的话，$x\in[0,p-2]$。</p><p>设$k=\lceil \sqrt p \rceil$，令$x=ik-j$，$i\in[0,k],j\in[0,k-1]$，这样$x$便能取遍$[0,p-2]$内所有数。</p><p>则原式变为</p><script type="math/tex; mode=display">\begin{align}a^{ik-j} &\equiv b\pmod p \\a^{ik} &\equiv b\times a^j\pmod p\end{align}</script><p>于是可以分别算出左面式子的所有值和右面式子的所有值，当出现相等的情况说明有解为$ik-j$。</p><p>这过程可用map实现。</p><h2 id="例题-洛谷P4028-New-Product"><a href="#例题-洛谷P4028-New-Product" class="headerlink" title="例题 [洛谷P4028] New Product"></a>例题 [洛谷P4028] New Product</h2><p>LiM有一家手工糕点店，因为糕点既实惠又好吃，于是积累了$P$个常客。（$P$为质数）</p><p>每次这家店出$NewProduct$（新品）的时候，都会做很多个，这$P$个人都会支持，支持方法是：</p><p><strong>每个人买的数量都相同，而且买的总数要尽量多</strong></p><p>这家店共有$B$个工人，一分钟可以生产已经生产的数量的$A$倍。</p><p>（注：一开始有一个已制作的$New Product$作为制作样品）</p><p>而当制作完毕，抢购（只考虑常客）完后：</p><p><strong>为了考虑工人们，最后要剩下正好$B$个。</strong></p><p>下面给出已知条件，请你帮LiM算算最少要工作多长时间吧！</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$20\%$的数据，$T=1$，所有条件$\le 100$。</p><p>对于$100\%$的数据，$T\le 5000$，所有条件$\le 50000$。$P$为质数！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>板子板子板子。</p><p>求$A^x\equiv B\pmod P$。</p><p>按照上述过程瞎搞即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,p,a,b;</span><br><span class="line"><span class="built_in">map</span> &lt;ll,<span class="keyword">int</span>&gt; vh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t=quickp(x,y/<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">vh.clear();</span><br><span class="line"><span class="keyword">if</span>(!(a%p)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">b%=p;</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">ll temp=b,t=quickp(a,k,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">temp=mul(temp,a);</span><br><span class="line">vh[temp]=j;</span><br><span class="line">&#125;</span><br><span class="line">temp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">temp=mul(temp,t);</span><br><span class="line"><span class="keyword">if</span>(vh[temp]) <span class="keyword">return</span> ((i*k-vh[temp])%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">int</span> ans=BSGS(p,a,b);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Couldn't Produce!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P2485" target="_blank" rel="noopener">[SDOI2011]计算器</a></td><td><a href="https://www.luogu.com.cn/record/31799231" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P4884" target="_blank" rel="noopener">[洛谷P4884]多少个1？</a></td><td><a href="https://www.luogu.com.cn/record/31800689" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3306" target="_blank" rel="noopener">[SDOI2013]随机数生成器</a></td><td><a href="https://www.luogu.com.cn/record/31834345" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3846" target="_blank" rel="noopener">[TJOI2007]可爱的质数</a></td><td><a href="https://www.luogu.com.cn/record/31799504" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><h1 id="EXBSGS算法"><a href="#EXBSGS算法" class="headerlink" title="EXBSGS算法"></a>EXBSGS算法</h1><p>咕咕咕</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2018] 屠龙勇士</title>
      <link href="/is-zxy.github.io/2020/03/14/%5BNOI2018%5D-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/"/>
      <url>/is-zxy.github.io/2020/03/14/%5BNOI2018%5D-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<p>小 D 最近在网上发现了一款小游戏。游戏的规则如下：</p><ul><li>游戏的目标是按照编号$ 1 \rightarrow n$顺序杀掉$ n$条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加$ p_i$，直至生命值非负。只有在攻击结束后且当生命值 <strong>恰好</strong> 为$ 0$时它才会死去。</li><li>游戏开始时玩家拥有$ m$把攻击力已知的剑，每次面对巨龙时，玩家只能选择一 把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。 小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格， 于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：</li><li>每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 <strong>攻击力最低</strong> 的一把剑作为武器。</li><li>机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的$ x$次，使巨龙的生命值减少$ x \times ATK$。</li><li>之后，巨龙会不断使用恢复能力，每次恢复$ p_i$生命值。若在使用恢复能力前或某一次恢复后其生命值为$ 0$，则巨龙死亡，玩家通过本关。</li></ul><p>那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数$ x$设置为多少，才能用最少的攻击次数通关游戏吗？</p><p>当然如果无论设置成多少都无法通关游戏，输出$ -1$即可。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><div class="table-container"><table><thead><tr><th><strong>测试点编号</strong></th><th>$n$</th><th>$m$</th><th>$p_i$</th><th>$a_i$</th><th><strong>攻击力</strong></th><th><strong>其他限制</strong></th></tr></thead><tbody><tr><td>1</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$=1$</td><td>无</td></tr><tr><td>2</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$=1$</td><td>无</td></tr><tr><td>3</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无</td></tr><tr><td>4</td><td>$\le 10^5$</td><td>$=1$</td><td>$=1$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无</td></tr><tr><td>5</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>6</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>7</td><td>$\le 10^3$</td><td>$\le 10^3$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>特性 1</td></tr><tr><td>8</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>9</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>10</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>11</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>12</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>13</td><td>$=1$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>14</td><td>$=10^5$</td><td>$=10^5$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>无特殊限制</td></tr><tr><td>15</td><td>$=10^5$</td><td>$=10^5$</td><td>$=1$</td><td>$\le 10^8$</td><td>$\le 10^6$</td><td>无特殊限制</td></tr><tr><td>16</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>所有$p_i$是质数</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>17</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>所有$p_i$是质数</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>18</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>19</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr><tr><td>20</td><td>$\le 10^5$</td><td>$\le 10^5$</td><td>无特殊限制</td><td>$\le 10^{12}$</td><td>$\le 10^6$</td><td>特性 1</td></tr></tbody></table></div><p>特性 1 是指：对于任意的$ i$，$a_i \le p_i$。</p><p>特性 2 是指：$\operatorname{lcm}(p_i) \le 10^6$，即所有$ p_i$的 <strong>最小公倍数</strong> 不大于$ 10^6$。</p><p>对于所有的测试点，$T \le 5$，所有武器的攻击力$ \le 10^6$，所有$ p_i$的最小公倍数$ \le 10^{12}$。</p><p>保证$ T, n, m$均为正整数。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">[NOI2018]屠龙勇士</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，肯定要决定面对每条龙的剑。这个可以用multiset+upper_bound预处理出来。</p><p>定义面对龙$i$时剑的攻击力为$b[i]$。</p><p>那么对于每条龙$i$，其问题转化为$b[i]\times x+p[i]\times y=a[i]$，可变为同余方程$b[i]\times x\equiv a[i] \pmod{p[i]}$。</p><p>$x$即为满足$1\sim n$所有方程的最小解。</p><p>这个同余方程发现，其$x$前带有系数。但我们前面学过的中国剩余定理只能解决$x$无系数的。</p><p>于是想办法把系数给搞掉。</p><p>假设同余方程$b[i]\times x+p[i]\times y=a[i]$，已经求出一个特解$x_0$，则通解即为$x=x_0+\frac{p[i]}{gcd(b[i],p[i])}\times t,t\in Z$。</p><p>即$x\equiv x_0\pmod{\frac{p[i]}{gcd(b[i],p[i])}}$。成功把系数搞没了。</p><p>于是便把这道题变成了一个EXCRT的板子题。</p><p>注意快速乘，直接乘爆longlong。</p><p>注意$p[i]=1$的情况，这时取模为$0$，答案应为$\max_{i=1}^n\{\lceil\frac{a[i]}{b[i]}\rceil\}$，特判一下即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><del>好繁长啊我好菜</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y,mod) ((x%mod)+(y%mod))%mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y,mod) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line">ll a[N],p[N],atk[N],b[N],qa[N],qb[N],x,y,ans,maxn;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">multiset</span> &lt;ll&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll x,ll y,ll mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(x,y/<span class="number">2</span>,mod);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(x,plus(t,t,mod),mod);</span><br><span class="line"><span class="keyword">return</span> plus(t,t,mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readp_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;atk[i];</span><br><span class="line">s.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">ll x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">s.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">multiset</span> &lt;ll&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">it=s.upper_bound(a[i]);</span><br><span class="line"><span class="keyword">if</span>(it!=s.begin()) it--;</span><br><span class="line">b[i]=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert(atk[i]);</span><br><span class="line">maxn=max(maxn,(a[i]+b[i]<span class="number">-1</span>)/b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(b[i],p[i],x,y);</span><br><span class="line"><span class="keyword">if</span>(a[i]%gcd) flag=<span class="literal">false</span>;</span><br><span class="line">qb[i]=p[i]/gcd;</span><br><span class="line">qa[i]=(gsc(x,(a[i]/gcd),qb[i])+qb[i])%qb[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXCRT</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ans=a[<span class="number">1</span>];</span><br><span class="line">ll m=b[<span class="number">1</span>],x,y,js=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(m,b[i],x,y),c=(plus(a[i],-ans,b[i])+b[i])%b[i];</span><br><span class="line"><span class="keyword">if</span>(c%gcd) &#123;</span><br><span class="line">ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">c/=gcd;</span><br><span class="line">x=gsc(x,c,b[i]);</span><br><span class="line">ans+=m*x;</span><br><span class="line">m*=b[i]/gcd;</span><br><span class="line">ans=(ans%m+m)%m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line">maxn=<span class="number">0</span>;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">readp_init();</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXCRT(qa,qb,n);</span><br><span class="line"><span class="keyword">if</span>(ans) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;max(ans,maxn)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> NOI </tag>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TJOI2009] 猜数字</title>
      <link href="/is-zxy.github.io/2020/03/11/%5BTJOI2009%5D-%E7%8C%9C%E6%95%B0%E5%AD%97/"/>
      <url>/is-zxy.github.io/2020/03/11/%5BTJOI2009%5D-%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>现有两组数字，每组$k$个。</p><p>第一组中的数字分别用$ a_1,a_2,\cdots ,a_k$表示，第二组中的数字分别用$ b_1,b_2,\cdots ,b_k$表示。</p><p>其中第二组中的数字是两两互素的。求最小的$ n\in \mathbb{N}$，满足对于$ \forall i\in [1,k]$，有$ b_i | (n-a_i)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1≤k≤10，|a_i|\le 10^9$，$1\le b_i\le 6\times 10^3$，$\prod_{i=1}^k b_i\le 10^{18}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">[TJOI2009]猜数字</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>裸的不能再裸的CRT。</p><p>唯一需要注意的是求解过程中可能爆longlong，要龟速乘（其实和快速幂差不多）。</p><p>龟速乘调用负数时需注意，调换一下顺序。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%m)+(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%m)*(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],m=<span class="number">1</span>,x,y,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line">ll t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksc</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=ksc(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(plus(t,t),x);</span><br><span class="line"><span class="keyword">return</span> plus(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">m*=b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(m/b[i],b[i]);</span><br><span class="line">x=(x%b[i]+b[i])%b[i];</span><br><span class="line">ans=plus(ans,ksc(a[i],ksc(m/b[i],x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 中国剩余定理 </tag>
            
            <tag> TJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理(CRT)及扩展中国剩余定理(EXCRT)学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/11/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT-%E5%8F%8A%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-EXCRT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/11/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-CRT-%E5%8F%8A%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-EXCRT-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>其实CRT很早就学过了<del>但是由于本人太蒻了，忘了</del>。</p><p>于是复习一遍，顺带学习学习EXCRT。</p><a id="more"></a><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>《孙子算经》中有“物不知数”问题：“今有物不知其数，三三数之余二，五五数之余三，七七数之余二，问物几何？”即一个整数除以三余二，除以五余三，除以七余二，求这个整数。</p><p>这个问题可以表示成如下的同余方程组</p><script type="math/tex; mode=display">\begin{cases}x\equiv 2\pmod 3 \\x\equiv 3\pmod 5 \\x\equiv 2\pmod 7\end{cases}</script><p>该问题的解显然有无数个。设有一个解为$x_0$，则$x=k\times 105+x_0$均为问题的解。</p><p>考虑以下三个特征方程</p><p>$\begin{cases}x\equiv 1\pmod 3 \\x\equiv 0\pmod 5 \\x\equiv 0\pmod 7\end{cases}\qquad\begin{cases}x\equiv 0\pmod 3 \\x\equiv 1\pmod 5 \\x\equiv 0\pmod 7\end{cases}\qquad\begin{cases}x\equiv 0\pmod 3 \\x\equiv 0\pmod 5 \\x\equiv 1\pmod 7\end{cases}$</p><p>用扩欧求解方程$35m_1\equiv 1\pmod3$，$21m_2\equiv 1\pmod5$，$15m_3\equiv 1\pmod 7$</p><p>解出$m_1,m_2,m_3$后，原同余方程的一个解即为</p><script type="math/tex; mode=display">[2\times (m_1 \times 35)+3\times (m_2\times 21)+2\times (m_3\times 15)]\%105=23</script><hr><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>设自然数$m_1,m_2,\cdots,m_r$两两互质，并记$N=\prod_{i=1}^rm_i$，则同余方程组</p><script type="math/tex; mode=display">\begin{cases} x\equiv b_1\pmod {m_1} \\x\equiv b_2\pmod {m_2} \\\qquad\quad\cdots \\\qquad\quad\cdots \\x\equiv b_r\pmod {m_r}\end{cases}</script><p>在模$N$同余的意义下有唯一解。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>考虑方程组$(1\le i\le r)$：$\begin{cases} x\equiv 0\pmod{m_1} \\ \qquad\quad \cdots \\ x\equiv 0\pmod{m_{i-1}} \\ x\equiv 1\pmod{m_i} \\ x\equiv 0\pmod{m_{i+1}} \\ \quad\qquad\cdots \\ x\equiv 0\pmod{m_{r}}\end{cases}$</p><p>由于各个$m_i(1\le i\le r)$两两互质，将这个方程组作变量替换，令$x=\frac{N}{m_i}\times y$，于是原方程组等同于同余方程$\frac{N}{m_i}\times y\equiv 1\pmod {m_i}$，可用扩欧算出$y$。若要解得特解$x_i$，只要令：$x_i=\frac{N}{m_i}\times y_i$，则方程组的解为$x_0=\sum_{i=1}^r b_i\times x_i\pmod N$，在模$N$意义下唯一。</p><h3 id="例题-洛谷P1495-【模板】中国剩余定理-CRT-曹冲养猪"><a href="#例题-洛谷P1495-【模板】中国剩余定理-CRT-曹冲养猪" class="headerlink" title="例题 [洛谷P1495] 【模板】中国剩余定理(CRT)/曹冲养猪"></a>例题 [洛谷P1495] 【模板】中国剩余定理(CRT)/曹冲养猪</h3><p>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有$16$头母猪，如果建了$3$个猪圈，剩下$1$头猪就没有地方安家了。如果建造了$5$个猪圈，但是仍然有$1$头猪没有地方去，然后如果建造了$7$个猪圈，还有$2$头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n\le 10$</p><p>$b_i\le a_i\le 1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1495" target="_blank" rel="noopener">P1495 【模板】中国剩余定理(CRT)/曹冲养猪</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>仿照上面的过程求解即可。</p><p>注意将解通过取模移至最小正整数解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%m)+(y%m))%m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%m)*(y%m))%m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],x,y,m=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line">ll t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">m*=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(m/a[i],a[i]);</span><br><span class="line">x=(x%a[i]+a[i])%a[i];</span><br><span class="line">ans=plus(ans,mul(m/a[i],mul(x,b[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/UVA756" target="_blank" rel="noopener">UVA756 Biorhythms</a></td><td><a href="https://www.luogu.com.cn/record/24153513" target="_blank" rel="noopener">√</a></td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P3868" target="_blank" rel="noopener">[TJOI2009]猜数字</a></td><td><a href="https://www.luogu.com.cn/record/31636980" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><p>上面的算法对于模数是有限制条件的，即两两互质。</p><p>那么如果不两两互质呢？</p><p>先从含有两个方程的同余方程组考虑。</p><script type="math/tex; mode=display">\begin{cases}x\equiv b_1\pmod{m_1} \\x\equiv b_2\pmod{m_2}\end{cases}</script><p>令$x=k_1\times m_1+b_1=k_2\times m_2+b_2$。</p><p>那么考虑此式</p><script type="math/tex; mode=display">\begin{align}m_1\times k_1+b_1&=m_2\times k_2+b_2 \\m_1\times k_1-m_2\times k_2 &=b_2-b_1\end{align}</script><p>根据裴蜀定理，若有整数解，则$\gcd(m_1,m_2)|(b_2-b_1)$。反之则不存在整数解。</p><p>当其存在整数解时，假设已经利用扩欧求出一组特殊解$(k_1’,k_2’)$，其对应的$x=x_0$。令$d=\gcd(m_1,m_2)$。</p><p>则原式化为</p><script type="math/tex; mode=display">k_1\times \frac{m_1}{g}-k_2\times \frac{m_2}{g}=\frac{b_2-b_1}{g}</script><p>那么该不定方程通解为</p><script type="math/tex; mode=display">\begin{cases}k_1=\frac{m_2}{g}t+k_1' \\k_2=\frac{m_1}{g}t+k_2'\end{cases}</script><p>其中$t\in Z$。</p><p>往回代入$x$中，则</p><script type="math/tex; mode=display">\begin{align}x&= k_1\times m_1+b_1 \\&= x_0+\frac{m_1\times m_2}{g}t \\&= x_0+\operatorname{lcm}(m_1,m_2)\times t\end{align}</script><p>则最终解即为$x_0+\operatorname{lcm}(m_1,m_2)\times t\pmod{\operatorname{lcm}(m_1,m_2)}$</p><p>扩展到含有$n$个方程的同余方程组，便可以两个两个合并。</p><p>例如</p><script type="math/tex; mode=display">\begin{cases}x\equiv b_1\pmod{m_1} \\x\equiv b_2\pmod{m_2} \\x\equiv b_3\pmod{m_3} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>合并前两个</p><script type="math/tex; mode=display">\begin{cases}x\equiv x_0+\operatorname{lcm}(m_1,m_2)\times t \pmod{\operatorname{lcm}(m_1,m_2)} \\x\equiv b_3\pmod{m_3} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>合并目前的前两个</p><script type="math/tex; mode=display">\begin{cases}x\equiv x_0+\operatorname{lcm}(m_1,m_2,m_3)\times t\pmod{\operatorname{lcm}(m_1,m_2,m_3)} \\x\equiv b_4\pmod{m_4} \\\qquad\quad \cdots \\x\equiv b_n\pmod{m_n}\end{cases}</script><p>……</p><p>这样逐一合并到只剩最后一个即可。</p><h3 id="例题-洛谷P4777-【模板】扩展中国剩余定理（EXCRT）"><a href="#例题-洛谷P4777-【模板】扩展中国剩余定理（EXCRT）" class="headerlink" title="例题 [洛谷P4777] 【模板】扩展中国剩余定理（EXCRT）"></a>例题 [洛谷P4777] 【模板】扩展中国剩余定理（EXCRT）</h3><p>给定$ n$组非负整数$ a_i, b_i$，求解关于$ x$的方程组的最小非负整数解。</p><script type="math/tex; mode=display">\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \\ x\equiv b_2\ ({\rm mod}\ a_2) \\ ... \\ x \equiv b_n\ ({\rm mod}\ a_n)\end{cases}</script><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100 \%$的数据，$1 \le n \le {10}^5$，$1 \le a_i \le {10}^{12}$，$0 \le b_i &lt; a_i$，保证所有$ a_i$ 的最小公倍数不超过$ {10}^{18}$。</p><p><strong>请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。</strong></p><p>数据保证有解。</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4777" target="_blank" rel="noopener">P4777 【模板】扩展中国剩余定理（EXCRT）</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>乘法会溢出，所以龟速乘。</p><p>其余仿照上面操作即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y,mod) ((x%mod)*(y%mod))%mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y,mod) ((x%mod)+(y%mod))%mod</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],b[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gsc</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll t=gsc(a,b/<span class="number">2</span>,mod);</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="keyword">return</span> plus(t,plus(t,a,mod),mod);</span><br><span class="line"><span class="keyword">return</span> plus(t,t,mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EXGCD</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ll gcd=EXGCD(b,a%b,x,y),t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXCRT</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ans=a[<span class="number">1</span>];</span><br><span class="line">ll m=b[<span class="number">1</span>],x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll gcd=EXGCD(m,b[i],x,y),c=(plus(a[i],-ans,b[i])+b[i])%b[i];</span><br><span class="line">c/=gcd;</span><br><span class="line">x=gsc(x,c,b[i]);</span><br><span class="line">ans+=m*x;</span><br><span class="line">m*=b[i]/gcd;</span><br><span class="line">ans=(ans%m+m)%m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i]&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">EXCRT(a,b,n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><div class="table-container"><table><thead><tr><th>习题名称</th><th>完成情况</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">[NOI2018]屠龙勇士</a></td><td><a href="https://www.luogu.com.cn/record/31749065" target="_blank" rel="noopener">√</a></td></tr></tbody></table></div><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>教练的讲义。</p><p><a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem#i-4" target="_blank" rel="noopener">扩展欧几里得算法与中国剩余定理</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 中国剩余定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1373] 小a与uim之大逃离</title>
      <link href="/is-zxy.github.io/2020/03/10/%5B%E6%B4%9B%E8%B0%B7P1373%5D-%E5%B0%8Fa%E4%B8%8Euim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/"/>
      <url>/is-zxy.github.io/2020/03/10/%5B%E6%B4%9B%E8%B0%B7P1373%5D-%E5%B0%8Fa%E4%B8%8Euim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>瞬间，地面上出现了一个$n\times m$的巨幅矩阵，矩阵的每个格子上有一坨$0\sim k$不等量的魔液。怪物各给了小a和uim一个魔瓶，说道，你们可以从矩阵的任一个格子开始，每次向右或向下走一步，从任一个格子结束。开始时小a用魔瓶吸收地面上的魔液，下一步由uim吸收，如此交替下去，并且要求最后一步必须由uim吸收。魔瓶只有$k$的容量，也就是说，如果装了$k+1$那么魔瓶会被清空成零，如果装了$k+2$就只剩下$1$，依次类推。怪物还说道，最后谁的魔瓶装的魔液多，谁就能活下来。小a和uim感情深厚，情同手足，怎能忍心让小伙伴离自己而去呢？沉默片刻，小a灵机一动，如果他俩的魔瓶中魔液一样多，不就都能活下来了吗？小a和他的小伙伴都笑呆了！</p><p>现在他想知道他们都能活下来有多少种方法。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n,m&lt;=800,1&lt;=k&lt;=15$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1373" target="_blank" rel="noopener">P1373 小a和uim之大逃离</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>状态的设计十分重要。</p><p>定义$dp[i][j][l][f]$。</p><p>若$f=0$表示第$i$行第$j$列的魔液被小a吸取后小a与uim魔液差值为$l$的方案总数。</p><p>若$f=1$表示第$i$行第$j$列的魔液被uim吸取后小a与uim莫邪差值为$l$的方案总数。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j][l][0]=dp[i-1][j][l-a[i][j]][1]+dp[i][j-1][l-a[i][j]][1] \\dp[i][j][l][1]=dp[i-1][j][l+a[i][j]][0]+dp[i][j-1][l+a[i][j]][0]</script><p>由于可以从任意一个格子开始，初始化$dp[i][j][a[i][j]][0]=1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,a[N][N],dp[N][N][<span class="number">20</span>][<span class="number">2</span>],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">a[i][j]%=k;</span><br><span class="line">dp[i][j][a[i][j]][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;k;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][j][l][<span class="number">0</span>]=plus(dp[i<span class="number">-1</span>][j][(l-a[i][j]+k)%k][<span class="number">1</span>],dp[i][j][l][<span class="number">0</span>]);</span><br><span class="line">dp[i][j][l][<span class="number">1</span>]=plus(dp[i<span class="number">-1</span>][j][(l+a[i][j]+k)%k][<span class="number">0</span>],dp[i][j][l][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j<span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][j][l][<span class="number">0</span>]=plus(dp[i][j<span class="number">-1</span>][(l-a[i][j]+k)%k][<span class="number">1</span>],dp[i][j][l][<span class="number">0</span>]);</span><br><span class="line">dp[i][j][l][<span class="number">1</span>]=plus(dp[i][j<span class="number">-1</span>][(l+a[i][j]+k)%k][<span class="number">0</span>],dp[i][j][l][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=plus(ans,dp[i][j][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2008] 硬币购物</title>
      <link href="/is-zxy.github.io/2020/03/09/%5BHAOI2008%5D-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/"/>
      <url>/is-zxy.github.io/2020/03/09/%5BHAOI2008%5D-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>硬币购物一共有$4$种硬币。面值分别为$c_1,c_2,c_3,c_4$。某人去商店买东西，去了$tot$次。每次带$d_i$枚$c_i$硬币，买$s_i$的价值的东西。请问每次有多少种付款方法。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$d_i,s&lt;=100000$</p><p>$tot&lt;=1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1450" target="_blank" rel="noopener">[HAOI2008]硬币购物</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的思想太棒了。（好吧就是容斥原理）</p><p>若用多重背包，明显TLE飞了。</p><p>先当完全背包做，预处理出$100000$内面值的总方案数，$dp[i]+=dp[i-c[i]]$</p><p>考虑第$i$种硬币，其非法方案数，即超出额定的数量的方案数数量为$dp[s-(d[i]+1)*c[i]]$。</p><p>根据容斥原理，减去一种硬币的非法方案数，加上两种硬币的非法方案数，减去三种硬币的非法方案数，加上四种硬币的非法方案数即可得解。这个过程可以用一种类似状压的方式来实现。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">5</span>],tot,d[<span class="number">5</span>],bit[<span class="number">16</span>],lg[<span class="number">16</span>];</span><br><span class="line">ll dp[N],s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=c[i];j&lt;N;j++) dp[j]+=dp[j-c[i]];</span><br><span class="line">&#125;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;tot;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(tot) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">ll ans=dp[s];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i,js=<span class="number">0</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">js++;</span><br><span class="line">sum+=(d[lg[lowbit(j)]+<span class="number">1</span>]+<span class="number">1</span>)*c[lg[lowbit(j)]+<span class="number">1</span>];</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;s) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(js&amp;<span class="number">1</span>) ans-=dp[s-sum];</span><br><span class="line"><span class="keyword">else</span> ans+=dp[s-sum];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">tot--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAOI </tag>
            
            <tag> 背包 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2016] 排列计数</title>
      <link href="/is-zxy.github.io/2020/03/09/%5BSDOI2016%5D-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/"/>
      <url>/is-zxy.github.io/2020/03/09/%5BSDOI2016%5D-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求有多少种长度为$ n $的序列$ A$，满足以下条件：</p><p>$1\sim n $这$ n $个数在序列中各出现了一次</p><p>若第$ i $个数$ A[i] $的值为$ i$，则称$ i $是稳定的。序列恰好有$ m $个数是稳定的</p><p>满足条件的序列可能很多，序列数对$ 10^9+7$取模。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$T\le 500000$</p><p>$n\le 1000000$</p><p>$m\le 1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4071" target="_blank" rel="noopener">[SDOI2016]排列计数</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意显然，$1\sim n$中有$n-m$个数错排，$m$个数不错排的总方案数。</p><p>显然，总方案数为$C_n^m\times D(n-m)$。</p><p>预处理出阶乘和错排数，卢卡斯瞎搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) ((x%p)*(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> plus(x,y) ((x%p)+(y%p))%p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll f[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">d[<span class="number">0</span>]=<span class="number">1</span>,d[<span class="number">1</span>]=<span class="number">0</span>,d[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i++) &#123;</span><br><span class="line">f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line">d[i]=mul(i<span class="number">-1</span>,plus(d[i<span class="number">-1</span>],d[i<span class="number">-2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(t,mul(t,x));</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> mul(mul(f[n],quickp(f[m],p<span class="number">-2</span>)),quickp(f[n-m],p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mul(Laucs(n,m),d[n-m]));</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JLOI2014] 松鼠的新家</title>
      <link href="/is-zxy.github.io/2020/03/08/%5BJLOI2014%5D-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/"/>
      <url>/is-zxy.github.io/2020/03/08/%5BJLOI2014%5D-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。</p><p>松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，……，最后到$a_n$，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。</p><p>维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。</p><p>因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$2&lt;= n &lt;=300000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3258" target="_blank" rel="noopener">[JLOI2014]松鼠的新家</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>十分裸的树上差分。</p><p>需要注意重复经过的问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],head[N],lg[N],tot=<span class="number">0</span>,f[N][<span class="number">20</span>],depth[N],cnt[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,v;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].v!=from) dfs(now,edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v!=f[now][<span class="number">0</span>]) &#123;</span><br><span class="line">get_ans(edge[i].v);</span><br><span class="line">cnt[now]+=cnt[edge[i].v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) cnt[a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l=LCA(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">cnt[a[i]]++,cnt[a[i+<span class="number">1</span>]]++,cnt[l]--;</span><br><span class="line"><span class="keyword">if</span>(f[l][<span class="number">0</span>]) cnt[f[l][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line">get_ans(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;cnt[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JLOI </tag>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO15DEC] Max Flow P</title>
      <link href="/is-zxy.github.io/2020/03/07/%5BUSACO15DEC%5D-Max-Flow-P/"/>
      <url>/is-zxy.github.io/2020/03/07/%5BUSACO15DEC%5D-Max-Flow-P/</url>
      
        <content type="html"><![CDATA[<p>FJ给他的牛棚的$N(2≤N≤50,000)$个隔间之间安装了$N-1$根管道，隔间编号从$1$到$N$。所有隔间都被管道连通了。</p><p>FJ有$K(1≤K≤100,000)$条运输牛奶的路线，第i条路线从隔间$s_i$运输到隔间$t_i$。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3128" target="_blank" rel="noopener">[USACO15DEC]Max Flow P</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是求访问次数最多的点。</p><p>而涉及区间修改，一个点一个点修改显然超时。</p><p>于是考虑差分，原序列即为差分的前缀和。</p><p>对于一条路径$s_i$到$t_i$，这是条链。具体过程即为$s_i-&gt;LCA(s_i,t_i)-&gt;t_i$。</p><p>用$cnt$来差分。对于每个路线，$cnt[s_i]++,cnt[t_i]++，cnt[LCA(s_i,t_i)]—,cnt[f[LCA(s_i,t_i)]]—$，该结论可将路径分为两部分来看而得出。</p><p>最后用一种类似树形DP的方法，由叶到根，搞出最大的访问次数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,head[N],depth[N],f[N][<span class="number">20</span>],lg[N],tot=<span class="number">0</span>,d[N],cnt[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=f[now][<span class="number">0</span>]) &#123;</span><br><span class="line">get_ans(edge[i].to);</span><br><span class="line">cnt[now]+=cnt[edge[i].to];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,cnt[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">int</span> l=LCA(x,y);</span><br><span class="line">cnt[x]++,cnt[y]++,cnt[l]--;</span><br><span class="line"><span class="keyword">if</span>(f[l][<span class="number">0</span>]) cnt[f[l][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line">get_ans(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO19DEC] Milk Visits S</title>
      <link href="/is-zxy.github.io/2020/03/06/%5BUSACO19DEC%5D-Milk-Visits-S/"/>
      <url>/is-zxy.github.io/2020/03/06/%5BUSACO19DEC%5D-Milk-Visits-S/</url>
      
        <content type="html"><![CDATA[<p>Farmer John 计划建造$ N$个农场，用$ N-1$条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。</p><p>Farmer John 的$ M$个朋友经常前来拜访他。在朋友$ i$拜访之时，Farmer John 会与他的朋友沿着从农场$ A_i$到农场$ B_i$之间的唯一路径行走（可能有$ A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。</p><p>请求出每个朋友在拜访过后是否会高兴。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100\%$的数据，$1 \leq N \leq 10^5$，$1 \leq M \leq 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5836" target="_blank" rel="noopener">[USACO19DEC]Milk Visits S</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不妨令根为$1$。</p><p>定义$g[x],h[x]$分别表示从$1$到$x$路径上$G$牛和$H$牛的个数。</p><p>易得点$u$到点$v$路径上$G$牛的总数为</p><script type="math/tex; mode=display">g[u]+g[v]-g[LCA(u,v)]-g[f[0][LCA(u,v)]]</script><p>其中$f[x][y]$表示$y$的第$2^{x-1}$个祖先。</p><p>$H$牛个数同理。</p><p>判断路径上是否有询问的牛类型即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,head[MAXN],tot=<span class="number">0</span>,g[MAXN],h[MAXN],f[N][MAXN],lg[MAXN],depth[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,v;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">string</span> s,ans=(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].v=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">depth[to]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][to]=from;</span><br><span class="line">g[to]=g[from],h[to]=h[from];</span><br><span class="line"><span class="keyword">if</span>(s[to<span class="number">-1</span>]==<span class="string">'H'</span>) h[to]++;</span><br><span class="line"><span class="keyword">else</span> g[to]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[to]];i++) f[i][to]=f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][to]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[to];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].v!=from) dfs(to,edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[lg[depth[x]-depth[y]]][x];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][x]!=f[i][y]) &#123;</span><br><span class="line">x=f[i][x];</span><br><span class="line">y=f[i][y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">char</span> ins;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;ins;</span><br><span class="line"><span class="keyword">int</span> L=LCA(u,v);</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">'H'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(h[u]+h[v]-h[L]-h[f[<span class="number">0</span>][L]]) ans+=<span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">'G'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[u]+g[v]-g[L]-g[f[<span class="number">0</span>][L]]) ans+=<span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂句整理</title>
      <link href="/is-zxy.github.io/2020/03/06/%E6%9D%82%E5%8F%A5%E6%95%B4%E7%90%86/"/>
      <url>/is-zxy.github.io/2020/03/06/%E6%9D%82%E5%8F%A5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>看番和看书时记下的一些东西<del>感觉莫名有些沙雕呢</del></p><a id="more"></a><hr><h3 id="《挪威的森林》-【日】村上春树"><a href="#《挪威的森林》-【日】村上春树" class="headerlink" title="《挪威的森林》 【日】村上春树"></a>《挪威的森林》 【日】村上春树</h3><ol><li><p>死并非生的对立面，而作为生的一部分永存。</p></li><li><p>我在切身感受那一团薄雾样的东西的朝朝暮暮送走了十八岁的春天，同时努力使自己避免陷入深刻。我隐约感觉到，深刻未必是接近真实的同义词。但无论我怎样认为，死都是深刻的事实。在这令人窒息般的背反性当中，我重复着这种永无休止的圆周式思考。如今想来，那真是奇特的日日夜夜，在活得好端端的青春时代，居然凡事都以死为轴心旋转不休。</p></li><li><p>哪里会有人喜欢孤独，不过是不喜欢失望。</p></li><li><p>“不要同情自己！”他说，“同情自己是卑劣懦夫干的勾当。”<br>“我一定牢记。”我说。然后我们握手告别，他奔往新的天地，我则退回自己的泥沼。</p></li><li><p>无论熟知怎样的哲理，也无以消除所爱之人的死带来的悲哀。无论怎样的哲理，怎样的真诚，怎样的柔情，也无法排遣这种悲哀。我们唯一能做到的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理，在继之而来的意外悲哀面前，又是那样的软弱无力——我形影相吊地倾听这暗夜的涛声和凤鸣，日复一日地如此冥思苦索。</p></li><li><p>木月照旧十七，直子依然二十一，永远地。</p></li><li><p>“我已成为过去的人。你眼前存在的不过是我往日的记忆碎片。我心目中最宝贵的东西早在很久以前就已寿终正寝。我不过是按照过去的记忆坐卧行止罢了。”</p></li><li><p>死并非生的对立面，死潜伏在我们的生之中。</p></li><li><p>人生不需要理想，需要的是行为规范。</p></li></ol><hr><h3 id="《活着》-余华"><a href="#《活着》-余华" class="headerlink" title="《活着》 余华"></a>《活着》 余华</h3><ol><li><p>这辈子想起来也是很快就过来了，过得平平常常，我爹指望我光耀祖宗，他算是看错人了，我啊，就是这样的命。年轻时靠着祖上留下的钱风光了一阵子，往后就越过越落魄了，这样反倒好，看看我身边的人，龙儿和春生，他们也只是风光了一阵子，到头来命都丢了。做人还是平常些好，争这个争那个，争来争去赔了自己的命。像我这样，说起来是越混越没出息，可寿命长，我认识的人一个挨着一个死去，我还活着。</p></li><li><p>我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤着他们的子女，土地召唤着黑暗降临。</p></li><li><p>人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。</p></li></ol><hr><h3 id="《百年孤独》-【哥伦比亚】加西亚·马尔克斯"><a href="#《百年孤独》-【哥伦比亚】加西亚·马尔克斯" class="headerlink" title="《百年孤独》 【哥伦比亚】加西亚·马尔克斯"></a>《百年孤独》 【哥伦比亚】加西亚·马尔克斯</h3><ol><li><p>一天夜里，他相信已破译出一则有关马孔多未来的预言。它会变成一座光明的城市，矗立着玻璃建造的高楼大厦，却没有布恩迪亚家的丝毫血脉存留。</p></li><li><p>走向墓地的路上，细雨绵绵不断，阿尔卡蒂奥望见星期三的曙光闪现在地平线上。留恋之情随着晨雾散去，取而代之的是强烈的好奇感。</p></li><li><p>尼卡诺尔神甫在病榻上不禁感慨：“这实在荒唐，基督信仰的卫士摧毁教堂，共济会的人却下令重建。”</p></li><li><p>沉默寡言的奥雷里亚诺·布恩迪亚上校对家中重新焕发的活力视若无睹，约略懂得幸福晚年的秘诀不过是与孤独签下不失尊严的协定罢了。</p></li><li><p>无论何时，或睡或醒，从最庄严到最卑下的时刻，她都会想起贝丽卡，因为孤独已经为她筛选记忆，将生活在她心中累积的无数垃圾尽行焚毁，并净化、升华了其他记忆，即那些最苦涩的记忆，使其永久存留。</p></li><li><p>她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。</p></li><li><p>这列无辜的黄色火车注定要为马孔多带来无数疑窦与明证，无数甜蜜与不幸，无数变化、灾难与怀念。</p></li><li><p>一个人不是在该死的时候死，而是在能死的时候死。</p></li><li><p>同一血脉的两个孤独者之间的接近与友谊无涉，却有助于他们承受将两人分离又联合的神秘孤独。</p></li><li><p>过去都是假的，回忆没有归路，春天总是一去不返，最疯狂执著的爱情也终究是过眼云烟。</p></li><li><p>这是往昔的最后遗存，这往昔日渐衰落却不会彻底消亡，因为它是在自身之中无休无止地败落下去，每过一刻便向彻底灭亡更近一步，却永远无法抵达最后的终结。</p></li><li><p>他看到羊皮卷卷首的提要在尘世时空中完美显现：家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉。</p></li><li><p>他再次跳读去寻索自己死亡的日期和情形，但没等看到最后一行便已明白自己不会再走出这房间，因为可以预料这座镜子之城——或蜃景之城——将在奥雷里亚诺·巴比伦全部译出羊皮卷之时被飓风抹去，从世人记忆中根除，羊皮卷上所记载的一切自永远至永远不会再重复，因为注定经受百年孤独的家族不会有第二次机会在大地上出现。</p></li></ol><hr><h3 id="《人间失格》-【日】太宰治"><a href="#《人间失格》-【日】太宰治" class="headerlink" title="《人间失格》 【日】太宰治"></a>《人间失格》 【日】太宰治</h3><ol><li><p>平常他们说不定都隐藏着这种本性，可一有机会，他们就像温顺地卧在地上歇息的牛，会突然甩动尾巴拍死肚皮上的牛虻一样，在暴怒中暴露出人可怕的本性。</p></li><li><p>对讨厌的事不能说讨厌，对喜欢的事情也像行窃一样战战兢兢，从而在极度苦涩的滋味和难以言表的痛苦中苦闷得不能自拔。</p></li><li><p>归根结底，诉诸他人终究都是徒劳。</p></li><li><p>在我迄今为止的人生中，曾好多次希望被别人杀死，却从未想过要杀死别人。因为我觉得，这反而会给可怕的对手带去幸福。</p></li><li><p>胆小鬼连幸福都害怕，碰到棉花都会受伤，有时也会被幸福伤害。</p></li><li><p>所谓的世人，究竟指的是什么？是人的复数吗？哪里存在着世人的实体呢？不过，我一直把它视为坚强、严厉和可怕的东西，如今听崛木这么一说，我差点脱口而出：“所谓的世人，不就是你吗？”</p></li><li><p>对于现在的我，既没有幸福，也没有不幸。<br>只是，一切都将消逝。</p></li></ol><hr><h3 id="《末日时在做什么？有没有空？可以来拯救吗？》"><a href="#《末日时在做什么？有没有空？可以来拯救吗？》" class="headerlink" title="《末日时在做什么？有没有空？可以来拯救吗？》"></a>《末日时在做什么？有没有空？可以来拯救吗？》</h3><ol><li><p>我曾经发誓要永远和他在一起，能如此发誓，让我无比幸福。我曾经认为自己喜欢的这个人，能有如此感受，让我无比幸福。他曾经对我说：“我一定会让你幸福。”，能听到他那样说，让我无比幸福。那个人，分了这么多的幸福给我，所以，我敢肯定，现在的我，不管别人怎么说，都一定是世界上最幸福的女孩。</p></li><li><p>对不起，你们当中……有超过一半人我已经记不得了。忘掉的名字还能重新再记，但是，失去的回忆，已经不可能再回来了。</p></li><li><p>抱歉，我已经绝对不可能再获得幸福了。因为我发现，其实我早就被幸福包围了。</p></li><li><p>珂：<font color=CornflowerBlue>我曾经发誓要永远和他在一起，能够如此发誓，让我无比幸福。</font><br>威：<font color=Crimson>我曾经发誓要永远和她在一起，能够如此发誓，让我心获安详。</font><br>珂：<font color=CornflowerBlue>我曾经以为自己喜欢这个人</font><br>威：<font color=Crimson>我曾经觉得自己非常珍视她</font><br>珂：<font color=CornflowerBlue>能有如此感受，让我无比幸福。</font><br>威：<font color=Crimson>能有如此感受，让我无比喜悦。</font><br>珂：<font color=CornflowerBlue>他曾经对我说：我一定会让你幸福</font><br>威：<font color=Crimson>我曾经对她说：我一定会让你幸福</font><br>珂：<font color=CornflowerBlue>能听到他那样说，让我无比幸福。</font><br>威：<font color=Crimson>能够对她那么说，让我心获满足。</font><br>珂：<font color=CornflowerBlue>那个人，分了这么多的幸福给我</font><br>威：<font color=Crimson>我从她那，得到了这么多的东西，可是我却……</font><br>珂：<font color=CornflowerBlue>所以，我敢肯定……现在的我……不管别人怎么说，都一定是世界上最幸福的女孩。</font></p></li></ol><hr><h3 id="《解忧杂货店》-【日】东野圭吾"><a href="#《解忧杂货店》-【日】东野圭吾" class="headerlink" title="《解忧杂货店》 【日】东野圭吾"></a>《解忧杂货店》 【日】东野圭吾</h3><ol><li>有一天，我对他说：<br>“我比任何人都爱你，想要永远和你在一起。如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望坚持我的梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘记过你，但请让我去追逐梦想吧。”<br>听完这番话，病床上的他流下泪来。他对我说：<br>“我早就在等你这句话了。看到你为了我而烦恼，我很难过。让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[CF1320B] Navigation System</title>
      <link href="/is-zxy.github.io/2020/03/05/%5BCF1320B%5D-Navigation-System/"/>
      <url>/is-zxy.github.io/2020/03/05/%5BCF1320B%5D-Navigation-System/</url>
      
        <content type="html"><![CDATA[<p>给出$ 2\le n\le2\cdot 10^5$个节点，$2\le m\le2\cdot 10^5$条边的有向图，路径$ p_1,\cdots,p_k$，路径中没有重复元素，边$ (p_i,p_{i+1})$总是存在。</p><p>定义$ s=p_1,t=p_k,p_i\le n$</p><p>有一个导航系统，若当前在节点$ u$，会构造一条从$ u$到$ t$的最短路径（这种路径可能不止一条，但导航系统只会选其中一条），设导航系统规划的下一个节点为$ w$，实际行走的下一个节点为$ v$ 。</p><ul><li>$w=v$不会触发重构。</li><li>$w\neq v$会触发重构。</li></ul><p>实际行走路线为$ p$，求可能的最少重构次数和最多重构次数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF1320B" target="_blank" rel="noopener">CF1320B Navigation System</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>建立反向图，由于边权为1，所以bfs出每个点到$p_k$的距离$dis$。</p><p>对于一个点$p_i$，如果$dis[p_i]-1=dis[p_{i+1}]$，则说明$p_{i+1}$在$p_i$到终点的最短路上，然后看以$p_i$为起始点的边，其边终点$k(k≠p_{i+!})$，是否$dis[k]=dis[p_i]-1$，若等于，则说明可以重构，maxans++。</p><p>若$dis[p_i]-1≠dis[p_{i+1}]$，则maxans++,minans++。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N],Reg[N];</span><br><span class="line"><span class="keyword">int</span> n,m,k,p[N],q[N],dis[N],minans=<span class="number">0</span>,maxans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">q[head]=x,dis[x]=<span class="number">0</span>,vh[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail) &#123;</span><br><span class="line"><span class="keyword">int</span> s=Reg[q[head]].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[Reg[q[head]][i]]) &#123;</span><br><span class="line">vh[Reg[q[head]][i]]=<span class="number">1</span>;</span><br><span class="line">dis[Reg[q[head]][i]]=dis[q[head]]+<span class="number">1</span>;</span><br><span class="line">q[++tail]=Reg[q[head]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">Reg[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">bfs(p[k]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> s=g[p[i]].size();</span><br><span class="line"><span class="keyword">if</span>(dis[p[i+<span class="number">1</span>]]==dis[p[i]]<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[p[i]][j]==p[i+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dis[g[p[i]][j]]==dis[p[i]]<span class="number">-1</span>) &#123;</span><br><span class="line">maxans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> maxans++,minans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minans&lt;&lt;<span class="string">" "</span>&lt;&lt;maxans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF1320A] Journey Planning</title>
      <link href="/is-zxy.github.io/2020/03/05/%5BCF1320A%5D-Journey-Planning/"/>
      <url>/is-zxy.github.io/2020/03/05/%5BCF1320A%5D-Journey-Planning/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的序列$ b$。</p><p>设$ b$的一个子序列$ c$的长度为$ m$，它的第$ i$个元素在原序列的下标为$ c_i$，要求对于任意$ 1\leq i&lt;m$，$c_{i+1}-c_i=b_{c_{i+1}}-b_{c_i}$。</p><p>此时这个子序列的贡献为$ \sum_{i=1}^m{b_{c_i}}$。</p><p>求出所有合法的子序列的贡献中最大的贡献。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ ( 1 \le n \le 2 \cdot 10^5)$</p><p>$( 1 \le b_i \le 4 \cdot 10^5)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF1320A" target="_blank" rel="noopener">CF1320A Journey Planning</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>。</p><p>考场上傻了，写了个暴力TLE算法。</p><p>将式子移项，得$b_{c_i+1}-c_{i+1}=b_{c_i}-c_i$。</p><p>于是建立map，将$b_i-i$值相等的$b_i$值存起来取最大的即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,ll&gt; js;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll b[N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">js[b[i]-i]+=b[i];</span><br><span class="line">ans=max(ans,js[b[i]-i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2012]Longge的问题</title>
      <link href="/is-zxy.github.io/2020/03/03/%5BSDOI2012%5D-Longge%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/is-zxy.github.io/2020/03/03/%5BSDOI2012%5D-Longge%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Longge 的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。现在问题来了：给定一个整数$N$，你需要求出$\sum\limits_{i=1}^N \gcd(i, N)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 60\%$的数据，$1\leq N\leq 2^{16}$。</p><p>对于$100\%$的数据，$1\leq N\leq 2^{32}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2303" target="_blank" rel="noopener">[SDOI2012]Longge的问题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^N\gcd(i,N)</script><p>即求</p><script type="math/tex; mode=display">\begin{align}\sum_{d|n}d\sum_{i=1}^N[\gcd(i,N)==d]&= \sum_{d|n}d\sum_{i=1}^{\frac{N}{d}}[\gcd(i,\frac{N}{d})=1] \\&= \sum_{d|n}d\varphi(\frac{N}{d})\end{align}</script><p>但是观察本题$N$范围，开不了数组，于是不能用线性筛求欧拉函数。</p><p>所以要用到欧拉函数的性质，即</p><script type="math/tex; mode=display">\varphi(n)=n\prod_{i=1}^m(1-\frac{1}{p_i}),n=\prod_{i=1}^mp_i^{c_i}</script><p>其中$p$为质数。</p><p>于是可以$O(\sqrt{N})$求出$n$的所有约数，$O(\sqrt{N})$求$\varphi$，约数个数约为$logN$个，时间复杂度$O(\sqrt{N}\cdot logN)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N (1&lt;&lt;31)+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">ll ans=x,s=<span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x%i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!(x%i)) x/=i;</span><br><span class="line">ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>) ans=ans/x*(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">ll sn=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=sn;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(n%i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i*i==n) ans+=phi(i)*i;</span><br><span class="line"><span class="keyword">else</span> ans+=phi(i)*(n/i)+phi(n/i)*i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整除分块学习笔记</title>
      <link href="/is-zxy.github.io/2020/03/02/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/03/02/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>貌似是莫比乌斯反演的前置知识，那么先学一下好了。</p><a id="more"></a><h1 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h1><p>看这个式子</p><script type="math/tex; mode=display">\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor</script><p>显然可以$O(n)$求解。</p><p>那么是否有更高效的方法呢？</p><p>有的——整除分块，$O(\sqrt{n})$。</p><p>显然，对于$i\in [i,n]$，有很多$\lfloor \frac{n}{i} \rfloor$的值是相等的，且呈块状分布。</p><p>显然，相等的值的个数最多为$2\sqrt{n}$个。</p><p>一个重要的结论：若$\forall i\in[l,r]$，$\lfloor \frac{n}{i} \rfloor$都相等，那么$r=\left\lfloor\frac{n}{\lfloor\frac{n}{l}\rfloor}\right\rfloor$。</p><p>简单证明一下：</p><p>令$\lfloor \frac{n}{l} \rfloor=k$</p><p>因为</p><script type="math/tex; mode=display">\lfloor \frac{n}{k} \rfloor \le \frac{n}{k}</script><p>所以</p><script type="math/tex; mode=display">\frac{n}{\lfloor \frac{n}{k}\rfloor} \ge \frac{n}{\frac{n}{k}}=k</script><p>即</p><script type="math/tex; mode=display">\begin{align}\frac{n}{\lfloor \frac{n}{k}\rfloor} &\ge k \\\left\lfloor\frac{n}{\lfloor\frac{n}{k}\rfloor}\right\rfloor &\ge k\end{align}</script><p>根据单调性，易得$\left\lfloor\frac{n}{\lfloor\frac{n}{k}\rfloor}\right\rfloor=k$，此则说明$r$取$\lfloor \frac{n}{k} \rfloor $是满足条件的，此时$[l,r]$内其值都为$k$。</p><p>那么现在还需证明的就是$r$取$\lfloor \frac{n}{k} \rfloor +1$是不满足条件的，即$\left\lfloor \frac{n}{\lfloor \frac{n}{k}\rfloor +1}\right\rfloor &lt;k$。</p><script type="math/tex; mode=display">\left\lfloor \frac{n}{\lfloor \frac{n}{k}\rfloor +1}\right\rfloor<k⟺\frac{n}{\lfloor \frac{n}{k}\rfloor +1}<k⟺\lfloor \frac{n}{k}\rfloor\times k+k>n</script><p>设$n=q\times k+r\ (0\le r&lt; k)$。</p><p>则$\lfloor \frac{n}{k} \rfloor\times k +k=\lfloor q+\frac{r}{k}\rfloor \times k+k=q\times k+r+k&gt;n$</p><p>证毕。</p><p>于是便可用两个指针$l,r$来进行求和，每次求$r$，移动$l$即可。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CQOI2007-余数求和"><a href="#CQOI2007-余数求和" class="headerlink" title="[CQOI2007]余数求和"></a>[CQOI2007]余数求和</h2><p>给出正整数$n$和$k$计算$ G(n, k)=k\ \bmod\ 1 + k\ \bmod\ 2 + k\ \bmod\ 3 + \cdots + k\ \bmod\ n$的值。其中$ k\ \bmod\ i$表示$k$除以$i$的余数。</p><p>例如$ G(10, 5)=5\ \bmod\ 1 + 5\ \bmod\ 2 + 5\ \bmod\ 3 + 5\ \bmod\ 4 + 5\ \bmod\ 5 \cdots + 5\ \bmod\ 10=29$ 。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$30\%:n,k≤1000$</p><p>$60\%: n , k \le 10^6$</p><p>$100\%: n , k \le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2261" target="_blank" rel="noopener">[CQOI2007]余数求和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>即求</p><script type="math/tex; mode=display">\sum_{i=1}^n(k\bmod i)</script><p>化简</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n(k\bmod i) &=\sum_{i=1}^n(k-i\times\lfloor \frac{k}{i}\rfloor) \\&= n\times k-\sum_{i=1}^n i\times\lfloor \frac{k}{i}\rfloor\end{align}</script><p>后式可整除分块求出，前式可直接求出。于是便可$O(\sqrt{n})$求解。</p><p>本题有几个注意点，当$n&gt;k$时会出现$\lfloor \frac{k}{i} \rfloor=0$的情况，这样便出现了$\frac{k}{0}$，所以$n$应取$n,k$中的较小值，这样是没有影响的。</p><p>$\left\lfloor\frac{k}{\lfloor\frac{k}{l}\rfloor}\right\rfloor$也有可能大于$n$，也要判断一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">sum=n*k;</span><br><span class="line">n=min(n,k);</span><br><span class="line"><span class="keyword">for</span>(ll l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">r=min(k/(k/l),n);</span><br><span class="line">sum-=(k/l)*(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整除分块可快速处理形如$\sum_{i=1}^nf(\lfloor \frac{n}{i} \rfloor)$的式子。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/jszjinshengzhi/luogu-p2261cqoi2007-yu-shu-qiu-hu" target="_blank" rel="noopener">jszjinshengzhi的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 整除分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF813D] Two Melodies</title>
      <link href="/is-zxy.github.io/2020/03/02/%5BCF813D%5D-Two-Melodies/"/>
      <url>/is-zxy.github.io/2020/03/02/%5BCF813D%5D-Two-Melodies/</url>
      
        <content type="html"><![CDATA[<p>给定一个$n$，以及$n$个数$ a_1,a_2,a_3,\cdots,a_n$，定义一个$Melody$子序列(和”最长上升子序列”中的”子序列”定义一样，是指在原序列中相对顺序不变但是不一定连续的一段子序列)如下:</p><p>对于任意相邻的两个元素，一定满足这两个元素差为$1$或者两个元素除$7$同余。</p><p>请在原序列中找出两个无重复部分的$Melody$子序列并且选出的两个长度加起来最大。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$( 2&lt;=n&lt;=5000)$</p><p>$( 1&lt;=a_{i}&lt;=10^{5})$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF813D" target="_blank" rel="noopener">CF813D Two Melodies</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道很好的DP。</p><p>定义$dp[i][j]$表示一个子序列以$a_i$结尾，一个子序列以$a_j$结尾，两个子序列的最大长度和。</p><p>由于是对称的，所以不妨设$i&lt;j$。</p><p>于是易得</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i][0],dp[i][k])+1,j\in(i,n],k\in[1,j)</script><p>其中$a[k]$是与$a[j]$相差为$1$或同余于$7$的数。</p><p>于是易得一个$O(n^3)$的TLE算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N][N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxn=dp[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;j;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(a[k]-a[j])==<span class="number">1</span>||a[k]%<span class="number">7</span>==a[j]%<span class="number">7</span>) maxn=max(maxn,dp[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j]=maxn+<span class="number">1</span>;</span><br><span class="line">dp[j][i]=dp[i][j];</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，可以用两个桶记录，$mod[k]$表示模$7$得$k$的最大$dp$值，$num[l]$表示$a[k]=l,k\in[1,j)$的最大$dp$值。于是状转方程变为</p><script type="math/tex; mode=display">dp[i][j]=\max(dp[i][0],num[j-1],num[j+1],mod[j\%7])+1</script><p>每次求出一个$dp$值都更新$mod$与$num$，转移时直接拿来用，时间复杂度$O(n^2)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N][N],ans=<span class="number">0</span>,num[MAXN],mod[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                                          </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="built_in">memset</span>(mod,<span class="number">0</span>,<span class="keyword">sizeof</span>(mod));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">num[a[j]]=max(num[a[j]],dp[i][j]);</span><br><span class="line">mod[a[j]%<span class="number">7</span>]=max(mod[a[j]%<span class="number">7</span>],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">dp[i][j]=max(dp[i][<span class="number">0</span>],max(num[a[j]<span class="number">-1</span>],max(num[a[j]+<span class="number">1</span>],mod[a[j]%<span class="number">7</span>])))+<span class="number">1</span>;</span><br><span class="line">dp[j][i]=dp[i][j];</span><br><span class="line">num[a[j]]=max(num[a[j]],dp[i][j]);</span><br><span class="line">mod[a[j]%<span class="number">7</span>]=max(mod[a[j]%<span class="number">7</span>],dp[i][j]);</span><br><span class="line">ans=max(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P6160] [Cnoi2020]向量</title>
      <link href="/is-zxy.github.io/2020/03/01/%5B%E6%B4%9B%E8%B0%B7P6160%5D-%5BCnoi2020%5D-%E5%90%91%E9%87%8F/"/>
      <url>/is-zxy.github.io/2020/03/01/%5B%E6%B4%9B%E8%B0%B7P6160%5D-%5BCnoi2020%5D-%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>以氷屋为原点，三月精的位置分别记作向量$\vec{a}$, $\vec{b}$, $\vec{c}$。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j3u0l3no.png" alt="img"></p><p>由定义可知，$|\vec{a}|=r_1$, $|\vec{b}|=r_2$, $|\vec{c}|=r_3$。</p><p>现在 Cirno 分配给你的任务是计算其 <strong>破坏极限指数</strong> $\sigma$。</p><p>$\sigma=\min\{\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{c}\cdot\vec{a}\}$</p><p>其中「$\cdot$」表示 <strong>向量内积</strong>。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul><li>Subtask1($ 20\%$) : $r_1=r_2=r_3$</li><li>Subtask2($ 40\%$) : $r_1,r_2,r_3 \le 10$</li><li>Subtask3($ 40\%$) : $r_1,r_2,r_3 \le 10^9$</li></ul><p>对于$ 100\%$的数据$ 0 &lt; r_1 \le r_2 \le r_3 \le 10^9$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6160" target="_blank" rel="noopener">P6160 [Cnoi2020]向量</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考场上把我整懵了的一题。</p><p>于是考场上打了20分半径相等的情况。</p><p>正解居然是$O(1)$的…好强。</p><script type="math/tex; mode=display">\begin{align}\vec{a}\cdot\vec{b}+\vec{b}\cdot\vec{c}+\vec{c}\cdot\vec{a} &= \frac{1}{2}(|\vec{a}+\vec{b}+\vec{c}|^2-\vec{a}^2-\vec{b}^2-\vec{c}^2) \\&= \frac{1}{2}|\vec{a}+\vec{b}+\vec{c}|^2-\frac{1}{2}(\vec{a}^2+\vec{b}^2+\vec{c}^2)\end{align}</script><p>后项明显为定值，于是考虑最小化前项。</p><p>当$r_3&lt; r_2+r_1$时，可以构造矢量三角形，则前式最小值为$\vec{a}+\vec{b}+\vec{c}=\vec{0}$。</p><p>当$r_3\ge r_2+r_1$时，$|\vec{a}+\vec{b}+\vec{c}|\ge r_3-r_2-r_1$。</p><p>据此求解即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> a,b,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c&lt;a+b) <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;<span class="number">-0.5</span>*(a*a+b*b+c*c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;<span class="number">0.5</span>*(c-a-b)*(c-a-b)<span class="number">-0.5</span>*(a*a+b*b+c*c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（没错就是这么短）</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2398] GCD SUM</title>
      <link href="/is-zxy.github.io/2020/02/29/%5B%E6%B4%9B%E8%B0%B7P2398%5D-GCD-SUM/"/>
      <url>/is-zxy.github.io/2020/02/29/%5B%E6%B4%9B%E8%B0%B7P2398%5D-GCD-SUM/</url>
      
        <content type="html"><![CDATA[<p>求</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)</script><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$n\leq 3000$。</p><p>对于$ 60\%$的数据，$7000\leq n\leq 7100$。</p><p>对于$ 100\%$的数据，$n\leq 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2398" target="_blank" rel="noopener">P2398 GCD SUM</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和<a href="https://www.luogu.com.cn/problem/P2568" target="_blank" rel="noopener">P2568 GCD</a>做法很像。</p><p>硬算肯定TLE。</p><p>有很多组数的最大公因数是同一个数，据此产生思路。</p><p>对于$x,y$满足$gcd(x,y)=1$，则$gcd(kx,ky)=k$。</p><p>根据上题，$[1,n]$内最大公因数为$p$的对数为$2\sum_{i=1}^{\lfloor \frac{n}{p} \rfloor}\varphi(i)-1$。</p><p>于是该式答案即为$\sum_{i=1}^ni\times(2\sum_{j=1}^{\lfloor \frac{n}{i} \rfloor}\varphi(j)-1)$</p><p>线性筛$O(n)$求出欧拉函数，前缀和优化即可。$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,euler[N],prime[N],v[N],tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++tot]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||i*prime[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[i*prime[j]]=euler[i]*euler[prime[j]];</span><br><span class="line"><span class="keyword">else</span> euler[i*prime[j]]=euler[i]*prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+euler[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=i*(sum[n/i]*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2134] 百日旅行</title>
      <link href="/is-zxy.github.io/2020/02/28/%5B%E6%B4%9B%E8%B0%B7P2134%5D-%E7%99%BE%E6%97%A5%E6%97%85%E8%A1%8C/"/>
      <url>/is-zxy.github.io/2020/02/28/%5B%E6%B4%9B%E8%B0%B7P2134%5D-%E7%99%BE%E6%97%A5%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>小明和小红还剩下$N$天的假期，小明可以安排旅行的计划。如果连续$X$天旅游，小明需要花旅行费用$P\times X^2$元；如果连续$X$天不旅游，小明需要请小红吃饭，花费为$Q\times X$元。（$P,Q$都是输入的常数）</p><p>请你帮小明写一个程序，计算出假期里他至少需要花费多少元。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$数据，$N&lt;=20$。</p><p>对于$90\%$数据，$N&lt;=1000,P&lt;=2000,Q&lt;=10000$。</p><p>对于剩下的$10\%$数据，$N&lt;=200000,Q&lt;=P&lt;=10000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2134" target="_blank" rel="noopener">P2134 百日旅行</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][k]$，当$k$为$0$时表示前$i$天的最后一段旅游的最小费用，$k$为$1$反之。</p><p>易得</p><script type="math/tex; mode=display">dp[i][k]=\left\{\begin{aligned}&\min\{dp[j][1]+P(i-j)^2\},j\in[0,i) && k=0\\&\min\{dp[j][0]+Q(i-j)\},j\in[0,i) && k=1\end{aligned}\right.</script><p>于是可得$O(n^2)$算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,p,q,dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll x=i-j;</span><br><span class="line">dp[i][<span class="number">0</span>]=min(dp[i][<span class="number">0</span>],dp[j][<span class="number">1</span>]+(x*x*p));</span><br><span class="line">dp[i][<span class="number">1</span>]=min(dp[i][<span class="number">1</span>],dp[j][<span class="number">0</span>]+(x*q));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[n][<span class="number">1</span>],dp[n][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T了一个点。</p><p>观察数据范围，发现最后一个点虽然$n$特别大，但是保证了$Q\le P$，于是可以特判，A掉本题。</p><p>但还是来个正规的做法吧。</p><p>先取$k=0$的情况。</p><script type="math/tex; mode=display">\begin{align}dp[j][1]+P(i-j)^2&= dp[j][1]+P(i^2-2ij+j^2) \\&= dp[j][1]+Pi^2-2Pij+Pj^2\end{align}</script><p>令$l&lt;j&lt;i$，当决策$j$比决策$l$优时，则</p><script type="math/tex; mode=display">\begin{align}dp[j][1]-2Pij+Pj^2 &\le dp[l][1]-2Pil+Pl^2 \\dp[j][1]+Pj^2-(dp[l][1]+Pl^2) &\le 2Pi(j-l) \\\frac{dp[j][1]+Pj^2-(dp[l][1]+Pl^2)}{j-l} &\le 2Pi\end{align}</script><p>明显斜率优化。$2Pi$递增，则单调队列维护下凸壳即可。</p><p>在看$k=1$的情况。</p><script type="math/tex; mode=display">dp[j][0]+Q(i-j)</script><p>这个东西。。不讲了，明显取前面的最小的。</p><p>于是可得$O(n)$的算法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,p,q,dp[N][<span class="number">2</span>],minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> que[N],head,tail;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dp[y][<span class="number">1</span>]+p*y*y-(dp[x][<span class="number">1</span>]+p*x*x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">head=tail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[i][<span class="number">1</span>]=minn+q*i;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(que[head],que[head+<span class="number">1</span>])&lt;=<span class="number">2</span>*p*i*X(que[head],que[head+<span class="number">1</span>])) head++;</span><br><span class="line">dp[i][<span class="number">0</span>]=dp[que[head]][<span class="number">1</span>]+p*(i-que[head])*(i-que[head]);</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(que[tail<span class="number">-1</span>],que[tail])*X(que[tail],i)&gt;=Y(que[tail],i)*X(que[tail<span class="number">-1</span>],que[tail])) tail--;</span><br><span class="line">que[++tail]=i;</span><br><span class="line">minn=min(minn,dp[i][<span class="number">0</span>]-q*i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[n][<span class="number">1</span>],dp[n][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CEOI2004] 锯木厂选址</title>
      <link href="/is-zxy.github.io/2020/02/25/%5BCEOI2004%5D-%E9%94%AF%E6%9C%A8%E5%8E%82%E9%80%89%E5%9D%80/"/>
      <url>/is-zxy.github.io/2020/02/25/%5BCEOI2004%5D-%E9%94%AF%E6%9C%A8%E5%8E%82%E9%80%89%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>从山顶上到山底下沿着一条直线种植了$n$棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。</p><p>木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。</p><p>你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ 2≤n≤20000 $</p><p>$ 1≤w_i≤10000,0≤d_i≤10000 $</p><p>保证所有树运到山脚的锯木厂所需要的费用小于$2×10^9$分。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4360" target="_blank" rel="noopener">[CEOI2004]锯木厂选址</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>问题可转化为$n+1$个地方放$3$个锯木厂。</p><p>定义$dp[k][i]$表示第$i$个地方放置第$k$个锯木厂，前$i$个地方的最小运输费用。</p><p>定义$sum$为$d$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">dp[k][i]=\min\{dp[k-1][j]+\sum_{l=j+1}^{i-1}[(sum[i-1]-sum[l-1])\times w[l]]\}</script><p>最终答案即为$dp[3][n+1]$。</p><p>于是$O(n^3)$的算法诞生了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w[N],d[N],dp[<span class="number">5</span>][N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=j+<span class="number">1</span>;l&lt;i;l++) s+=(sum[i<span class="number">-1</span>]-sum[l<span class="number">-1</span>])*w[l];</span><br><span class="line">dp[k][i]=min(dp[k][i],dp[k<span class="number">-1</span>][j]+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$\min$内的式子单独提出来看看</p><script type="math/tex; mode=display">\begin{align}dp[k-1][j]+\sum_{l=j+1}^{i-1}[(sum[i-1]-sum[l-1])\times w[l]]&= dp[k-1][j]+\sum_{l=j+1}^{i-1}(sum[i-1]\times w[l])-\sum_{l=j+1}^{i-1}(sum[l-1]\times w[l]) \\&= dp[k-1][j]+sum[i-1]\sum_{l=j+1}^{i-1}w[l]-\sum_{l=j+1}^{i-1}(sum[l-1]\times w[l])\end{align}</script><p>定义$sw$表示$w$的前缀和，$suw[i]$表示$sum[i-1]\times w[i]$的前缀和。</p><p>于是可化为</p><script type="math/tex; mode=display">dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j])</script><p>则</p><script type="math/tex; mode=display">dp[k][i]=\min\{dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j])\}</script><p>于是可得$O(n^2)$的算法。开$O2$居然水过了..</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll w[N],d[N],dp[<span class="number">5</span>][N],sum[N],sw[N],suw[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">sw[i]=sw[i<span class="number">-1</span>]+w[i];</span><br><span class="line">suw[i]=suw[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]*w[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">dp[k][i]=min(dp[k][i],dp[k<span class="number">-1</span>][j]+sum[i<span class="number">-1</span>]*(sw[i<span class="number">-1</span>]-sw[j])-(suw[i<span class="number">-1</span>]-suw[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将$\min$内的式子提出来</p><script type="math/tex; mode=display">\begin{align}&\ \ \ \ \ dp[k-1][j]+sum[i-1]\times (sw[i-1]-sw[j])-(suw[i-1]-suw[j]) \\&=dp[k-1][j]+sum[i-1]\times sw[i-1]-sum[i-1]\times sw[j]-suw[i-1]+suw[j]\end{align}</script><p>剔除常量</p><script type="math/tex; mode=display">dp[k-1][j]-sum[i-1]\times sw[j]+suw[j]</script><p>令$l&lt;j&lt;i$，当决策$j$比决策$l$更优时</p><script type="math/tex; mode=display">\begin{align}dp[k-1][j]-sum[i-1]\times sw[j]+suw[j] &\le dp[k-1][l]-sum[i-1]\times sw[l]+suw[l] \\dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l]) &\le sum[i-1]\times sw[j]-sum[i-1]\times sw[l] \\dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l]) &\le sum[i-1]\times (sw[j]-sw[l]) \\\frac{dp[k-1][j]+suw[j]-(dp[k-1][l]+suw[l])}{sw[j]-sw[l]} &\le sum[i-1]\end{align}</script><p>明显，斜率优化。</p><p>$sum$递增，即斜率递增。横坐标也单调递增，则单调队列维护下凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N];</span><br><span class="line">ll w[N],d[N],dp[<span class="number">5</span>][N],sum[N],sw[N],suw[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dp[k<span class="number">-1</span>][y]+suw[y]-(dp[k<span class="number">-1</span>][x]+suw[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">X</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sw[y]-sw[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+d[i];</span><br><span class="line">sw[i]=sw[i<span class="number">-1</span>]+w[i];</span><br><span class="line">suw[i]=suw[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]*w[i];</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">sum[n]=sum[n<span class="number">-1</span>],sw[n]=sw[n<span class="number">-1</span>],suw[n]=suw[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++) &#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(q[head],q[head+<span class="number">1</span>],k)&lt;=sum[i<span class="number">-1</span>]*X(q[head],q[head+<span class="number">1</span>])) head++;</span><br><span class="line">dp[k][i]=dp[k<span class="number">-1</span>][q[head]]+sum[i<span class="number">-1</span>]*sw[i<span class="number">-1</span>]-sum[i<span class="number">-1</span>]*sw[q[head]]-suw[i<span class="number">-1</span>]+suw[q[head]];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;Y(q[tail<span class="number">-1</span>],q[tail],k)*X(q[tail],i)&gt;=Y(q[tail],i,k)*X(q[tail<span class="number">-1</span>],q[tail])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">3</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> CEOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[IOI2000] 邮局</title>
      <link href="/is-zxy.github.io/2020/02/25/%5BIOI2000%5D-%E9%82%AE%E5%B1%80/"/>
      <url>/is-zxy.github.io/2020/02/25/%5BIOI2000%5D-%E9%82%AE%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。</p><p>邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。</p><p>你要编写一个程序，已知村庄的个数$V$、村庄的位置$X$和邮局的数量$P$，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \leq P \leq 300$</p><p>$P \leq V \leq 3000$.</p><p>$1 \leq X \leq 10000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4767" target="_blank" rel="noopener">[IOI2000]邮局</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先将坐标排个序。</p><p>定义$dp[i][j]$表示前$i$个村庄放$j$个邮局的前$i$个村庄的最小距离总和，$w(i,j)$表示村庄区间$[i,j]$内放一个村庄时该区间的最小距离总和。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=\min\{dp[k][j-1]+w(k+1,i)\},k\in[0,i)</script><p>那么关键就在于$w(k+1,i)$的处理了。</p><p>基本的数学知识，若村庄数为奇数，放中位数处距离和最小。若村庄为偶数，放中间两个村庄之间任意一处均可。</p><p>于是便可得一个$O(PV^3)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;mid;i++) ans+=X[mid]-X[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++) ans+=X[i]-X[mid];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[k][j<span class="number">-1</span>]+w(k+<span class="number">1</span>,i),dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再想想，可以提前预处理出$w$，其实这个$w$是可以$O(V^2)$递推出来的，根据放置一个邮局，邮局位置总是在中位数处，便可推得</p><script type="math/tex; mode=display">w[l][r]=w[l][r-1]+X[r]-X[\lfloor\frac{l+r}{2}\rfloor]</script><p>于是又可以得到一个$O(PV^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=V;l++) &#123;</span><br><span class="line">w[l][l]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=V;r++) &#123;</span><br><span class="line">w[l][r]=w[l][r<span class="number">-1</span>]+X[r]-X[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i],dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实$w$是满足四边形不等式的。</p><p>由上面$w$的递推式，可得$w[l][r+1]-w[l][r]=X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ $①</p><p>那么$w[l+1][r+1]-w[l+1][r]=X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor]\ $②</p><p>用①$-$②，得</p><script type="math/tex; mode=display">X[r+1]-X[\lfloor\frac{l+r+1}{2}\rfloor]-(X[r+1]-X[\lfloor\frac{l+r+2}{2}\rfloor])=X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]</script><p>$X$坐标递增，则$X[\lfloor\frac{l+r+2}{2}\rfloor]-X[\lfloor\frac{l+r+1}{2}\rfloor]\ge 0$</p><p>即</p><script type="math/tex; mode=display">\begin{align}w[l][r+1]-w[l][r]-(w[l+1][r+1]-w[l+1][r]) &\ge 0 \\w[l][r+1]-w[l][r]-w[l+1][r+1]+w[l+1][r] &\ge 0 \\w[l][r+1]+w[l+1][r] &\ge w[l][r]+w[l+1][r+1]\end{align}</script><p>因此$w$满足四边形不等式，且明显，对于$a\le b\le c\le d$，$w[a][d]\ge w[b][c]$，故$dp$满足四边形不等式。</p><p>因为$dp$满足四边形不等式，所以对于$dp[i][j]$的最优决策$d[i][j]$，$d[i][j-1]\le d[i][j]\le d[i+1][j]$</p><p>于是状态转移$dp[i][j]$时，从$[dp[i][j-1],d[i+1][j]]$中找最优决策。</p><p>由于要用到$dp[i+1][j]$，所以倒序求解。</p><p>时间复杂度$O(PV)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,P,X[MAXN],dp[MAXN][N],w[MAXN][MAXN],d[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=V;l++) &#123;</span><br><span class="line">w[l][l]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r=l+<span class="number">1</span>;r&lt;=V;r++) &#123;</span><br><span class="line">w[l][r]=w[l][r<span class="number">-1</span>]+X[r]-X[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="built_in">cin</span>&gt;&gt;X[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">sort(X+<span class="number">1</span>,X+V+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=P;j++) &#123;</span><br><span class="line">d[V+<span class="number">1</span>][j]=V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=V;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line"><span class="keyword">int</span> minn=INF,minid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=d[i][j<span class="number">-1</span>];k&lt;=d[i+<span class="number">1</span>][j];k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i]&lt;minn) &#123;</span><br><span class="line">minn=dp[k][j<span class="number">-1</span>]+w[k+<span class="number">1</span>][i];</span><br><span class="line">minid=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j]=minn;</span><br><span class="line">d[i][j]=minid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[V][P]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOI </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策单调性优化DP学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/21/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/21/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>设$w(x,y)$是定义在整数集合上的二元函数。若对于定义域上的任意整数$a,b,c,d$，其中$a\le b\le c\le d$，都有$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$成立，则称函数$w$满足<strong>四边形不等式</strong>。</p><a id="more"></a><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>设$w(x,y)$是定义在整数集合上的二元函数。若对于定义域上的任意整数$a,b$，其中$a&lt;b$，都有$w(a,b+1)+w(a+1,b)\ge w(a,b)+w(a+1,b+1)$成立，则函数$w$满足四边形不等式。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>对于$a&lt;c$，有$w(a,c+1)+w(a+1,c)\ge w(a,c)+w(a+1,c+1)$</p><p>对于$a+1&lt;c$，有$w(a+1,c+1)+w(a+2,c)\ge w(a+1,c)+w(a+2,c+1)$</p><p>两式相加，得到$w(a,c+1)+w(a+2,c)\ge w(a,c)+w(a+2,c+1)$</p><p>以此类推，对于任意的$a\le b\le c$，有$w(a,c+1)+w(b,c)\ge w(a,c)+w(b,c+1)$</p><p>同理，对任意的$a\le b\le c\le d$，有$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$</p><hr><h1 id="一维线性DP的四边形不等式优化"><a href="#一维线性DP的四边形不等式优化" class="headerlink" title="一维线性DP的四边形不等式优化"></a>一维线性DP的四边形不等式优化</h1><p>在状转方程$f[i]=\min\{f[j]+w(j,i)\},j\in[0,i)$中，若函数$w$满足四边形不等式，则$f$具有决策单调性。</p><h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h2><p>定义$p[i]$表示$i$的最优决策点。</p><p>$\forall i\in[1,n],\forall j\in[0,p[i]-1]$，根据$p[i]$为$i$的最优决策点，则有</p><script type="math/tex; mode=display">f[p[i]]+w(p[i],i)\le f[j]+w(j,i)</script><p>$\forall i’\in[i+1,n]$，因为$w$满足四边形不等式，则有</p><script type="math/tex; mode=display">w(j,i')+w(p[i],i)\ge w(j,i)+w(p[i],i')</script><p>移项，可得</p><script type="math/tex; mode=display">v(p[i],i')-w(p[i],i)\le w(j,i')-w(j,i)</script><p>与第一个不等式相加，可得</p><script type="math/tex; mode=display">f[p[i]]+w(p[i],i')\le f[j]+w(j,i')</script><p>即$i’$的最优决策点一定大于等于$p[i]$。故$f$具有决策单调性。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>那么知道其有决策单调性后，有什么应用呢？</p><p>既然其有决策单调性，定义$p[i]$表示$i$的最优决策点，则$p$内一定是非严格单调递增的。</p><p>那么根据此性质，满足决策单调性的题目主要有两种处理手法。</p><h3 id="方法一：单调队列"><a href="#方法一：单调队列" class="headerlink" title="方法一：单调队列"></a>方法一：单调队列</h3><p>可以用单调队列维护决策集合$p$。</p><p>当求出一个新的$f[i]$时，考虑$i$可以作为哪些$f[i’]\ (i’&gt;i)$的最优决策。根据决策单调性，我们一定可以找到一个位置，在该位置之前，$p$内存储的决策都比$i$要优，其后都比$i$差。于是便可以将该位置及其后面的部分全部变为$i$，即此时它们的最优决策均为$i$。</p><p>一个位置一个位置的修改效率很低，所以可以建立一个队列，代替$p$。队列中保存三个量$(j,l,r)$，表示$p[l$~$r]$的值都是$j$。</p><p>对于每个$i\in[1,n]$，执行以下操作：</p><ol><li><p>检查队头：设队头为$(j_0,l_0,r_0)$，若$r_0=i-1$，则删除队头（因为队头不需要了，$f[i]$之前的值已经被求出）。否则则令$l_0=i$。</p></li><li><p>取队头保存的最优决策$j$进行状态转移，计算出$f[i]$。</p></li><li><p>尝试插入新决策$i$，步骤如下</p><p>(1) 取出队尾，即为$(j_t,l_t,r_t)$</p><p>(2) 若对于$f[l_t]$来说，$i$是比$j_t$更优的决策，即$f[i]+w(i,l_t)\le f[j_t]+w(j_t,l_t)$，记$pos=l_t$，删除队尾，返回步骤(1)。</p><p>(3) 若对于$f[r_t]$来说，$i$是比$j_t$更优的决策，即$f[j_t]+w(j_t,r_t)\le f[i]+w(i,r_t)$，去往步骤(5)。</p><p>(4) 否则，则在$[l_t,r_t]$上二分查找出位置$pos$，在此之前决策比$i$优，在此之后决策$i$更优，将$[l_t,r_t]$修改为$[l_t,pos-1]$，去往步骤(5)。</p><p>(5) 把三元组$(i,pos,n)$插入队尾。</p></li></ol><p>时间复杂度$O(n\ log\ n)$。</p><h3 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h3><p>假设已知$[l,r]$的最优决策在$[L,R]$上。</p><p>定义$mid=\frac{l+r}{2}$，设$dp[mid]$的最优决策为$p$，根据决策单调性，可知$[l,mid-1]$的最优决策在$[L,p]$内，$[mid+1,r]$的最优决策在$[p,R]$内。</p><p>于是将问题分割成了同类型的规模更小的问题，便可递归分治。</p><p>时间复杂度$O(n\ log\ n)$</p><h2 id="例题-POI2011-Lightning-Conductor"><a href="#例题-POI2011-Lightning-Conductor" class="headerlink" title="例题 [POI2011]Lightning Conductor"></a>例题 [POI2011]Lightning Conductor</h2><p>给定一个长度为$ n$的序列$\{a_n\}$，对于每个$i\in [1,n]$，求出一个最小的非负整数$p$，使得 $\forall j\in[1,n]$，都有$a_j\le a_i+p-\sqrt{|i-j|}$。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1 \le n \le 5\times 10^{5}$，$0 \le a_i \le 10^{9}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3515" target="_blank" rel="noopener">[POI2011]Lightning Conductor</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><script type="math/tex; mode=display">\begin{align}a_j &\le a_i+p-\sqrt{|i-j|},\forall j\in[1,n] \\p &\ge a_j+\sqrt{|i-j|}-a_i,\forall j\in[1,n]\end{align}</script><p>而$p$为非负整数，则</p><script type="math/tex; mode=display">p=\lceil \max\{ a_j+\sqrt{|i-j|}\}\rceil-a_i,\forall j\in[1,n]</script><p>那么问题便转变为求$\lceil \max\{ a_j+\sqrt{|i-j|}\}\rceil,\forall j\in[1,n]$。</p><p>可以考虑做两次，正做一次，将序列翻转再做一次，结果取两次的最大值，这样便可以去掉绝对值</p><script type="math/tex; mode=display">\lceil \max\{ a_j+\sqrt{i-j}\}\rceil,\forall j\in[1,i)</script><p>定义$dp[i]=\lceil \max\{ a_j+\sqrt{i-j}\}\rceil$。</p><p>此处的$w(j,i)$即为$\sqrt{i-j}$。</p><p>定义$a+1&lt;c$。</p><script type="math/tex; mode=display">w(a,c)=\sqrt{c-a}</script><script type="math/tex; mode=display">w(a+1,c)=\sqrt{c-a-1}</script><script type="math/tex; mode=display">w(a,c+1)=\sqrt{c-a+1}</script><script type="math/tex; mode=display">w(a+1,c+1)=\sqrt{c-a}</script><p>则</p><script type="math/tex; mode=display">\begin{align}w(a,c+1)+w(a+1,c)-[w(a,c)+w(a+1,c+1)] &=\sqrt{c-a-1}+\sqrt{c-a+1}-2\sqrt{c-a}\end{align}</script><p>令$d=c-a$，原式变为</p><script type="math/tex; mode=display">\sqrt{d-1}+\sqrt{d+1}-2\sqrt{d}=(\sqrt{d+1}-\sqrt{d})-(\sqrt{d}-\sqrt{d-1})</script><p>而函数$f(x)=\sqrt{x}-\sqrt{x-1}$单调递减</p><p>则该式恒小于$0$。</p><p>即$w(a,c+1)+w(a+1,c)\le w(a,c)+w(a+1,c+1)$。</p><p>可推广到对于$a\le b\le c\le d$，$w(a,d)+w(b,c) \le w(a,c)+w(b,d)$。</p><p>可以发现，这东西与四边形不等式的符号相反。将上面的证明过程符号取反（因为本题求的是$\max$），便可证明$dp$满足决策单调性。</p><p>于是采用上面两种方法实现即可。</p><p>由于函数$sqrt$较慢，且本题反复调用，可提前预处理出$\sqrt{1}$~$\sqrt{n}$。</p><h3 id="代码（单调队列）"><a href="#代码（单调队列）" class="headerlink" title="代码（单调队列）"></a>代码（单调队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,head,tail,a[N];</span><br><span class="line"><span class="keyword">double</span> dp[N],sqr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,p;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">double</span>(a[j])+sqr[i-j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=q[t].r+<span class="number">1</span>,l=q[t].l,r=q[t].r;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(w(q[t].p,mid)&lt;=w(x,mid)) ans=mid,r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">q[tail].l=max(q[tail].l,i);</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;w(i,q[tail].l)&gt;=w(q[tail].p,q[tail].l)) tail--;</span><br><span class="line"><span class="keyword">if</span>(head&gt;tail) &#123;</span><br><span class="line">q[++tail].l=i;</span><br><span class="line">q[tail].r=n;</span><br><span class="line">q[tail].p=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> pos=binary_search(tail,i);</span><br><span class="line"><span class="keyword">if</span>(pos&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">q[tail].r=pos<span class="number">-1</span>;</span><br><span class="line">q[++tail].l=pos;</span><br><span class="line">q[tail].r=n;</span><br><span class="line">q[tail].p=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">insert(i);</span><br><span class="line"><span class="keyword">if</span>(head&lt;=tail&amp;&amp;q[head].r&lt;i) head++;</span><br><span class="line"><span class="keyword">else</span> q[head].l=i;</span><br><span class="line">dp[i]=max(dp[i],w(q[head].p,i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sqr[i]=<span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(a[i],a[n-i+<span class="number">1</span>]),swap(dp[i],dp[n-i+<span class="number">1</span>]);</span><br><span class="line">work();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)<span class="built_in">ceil</span>(dp[i])-a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（分治）"><a href="#代码（分治）" class="headerlink" title="代码（分治）"></a>代码（分治）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="keyword">double</span> dp[N],sqr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">double</span>(a[j])+sqr[i-j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,p;</span><br><span class="line"><span class="keyword">double</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=min(mid,R);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(w(i,mid)&gt;maxn) maxn=w(i,mid),p=i;</span><br><span class="line">&#125;</span><br><span class="line">dp[mid]=max(dp[mid],maxn);</span><br><span class="line">work(l,mid<span class="number">-1</span>,L,p);</span><br><span class="line">work(mid+<span class="number">1</span>,r,p,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sqr[i]=<span class="built_in">sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) swap(a[i],a[n-i+<span class="number">1</span>]),swap(dp[i],dp[n-i+<span class="number">1</span>]);</span><br><span class="line">work(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)<span class="built_in">ceil</span>(dp[i])-a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二维区间DP的四边形不等式优化"><a href="#二维区间DP的四边形不等式优化" class="headerlink" title="二维区间DP的四边形不等式优化"></a>二维区间DP的四边形不等式优化</h1><p>区间DP会经常遇到下面这样的状态转移方程</p><script type="math/tex; mode=display">f[i][j]=\min_{i\le k<j}\{f[i][k]+f[k+1][j]+w(i,j)\}</script><p>对此也可用四边形不等式进行优化。</p><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><p>在状态转移方程$f[i][j]=\min_{i\le k&lt;j}\{f[i][k]+f[k+1][j]+w(i,j)\}$中（特别地，$f[i][i]=w(i,i)=0$），如果下面这两个条件成立</p><ol><li>$w$满足四边形不等式</li><li>对于任意的$a\le b\le c\le d$，有$w(a,d)\ge w(b,c)$。</li></ol><p>那么$f$也满足四边形不等式。</p><p><del>证明过于繁琐，记结论吧233</del></p><h2 id="定理（二维决策单调性）"><a href="#定理（二维决策单调性）" class="headerlink" title="定理（二维决策单调性）"></a>定理（二维决策单调性）</h2><p>在状态转移方程$f[i][j]=\min_{i\le k&lt;j}\{f[i][k]+f[k+1][j]+w(i,j)\}$中（特别地，$f[i][i]=w(i,i)=0$），记$p[i][j]$表示令$f[i][j]$取到最小值的$k$值。</p><p>如果$f$满足四边形不等式，那么对于任意$i&lt;j$，有$p[i][j-1]\le p[i][j]\le p[i+1][j]$。</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>简记$p[i][j]=p$，对于任意的$i&lt;k\le p$，因为$f$满足四边形不等式，则</p><script type="math/tex; mode=display">\begin{align}f[i][p]+f[i+1][k] &\ge f[i][k]+f[i+1][p] \\f[i+1][k]-f[i+1][p] &\ge f[i][k]-f[i][p]\end{align}</script><p>而$p$为最优决策，则</p><script type="math/tex; mode=display">\begin{align}f[i][k]+f[k+1][j]+w(i,j) &\ge f[i][p]+f[p+1][j]+w(i,j) \\f[i][k]+f[k+1][j] &\ge f[i][p]+f[p+1][j]\end{align}</script><p>因此</p><script type="math/tex; mode=display">\begin{align}&\ \ \ \ \ (f[i+1][k]+f[k+1][j]+w(i+1,j))-(f[i+1][p]+f[p+1][j]+w(i+1,j)) \\&= (f[i+1][k]-f[i+1,p])+(f[k+1][j]-f[p+1][j]) \\&\ge (f[i][k]-f[i][p])+(f[k+1][j]-f[p+1][j]) \\&= (f[i][k]+f[k+1][j])-(f[i][p]+f[p+1][j]) \\&\ge 0\end{align}</script><p>这意味着对于$f[i+1][j]$，$p$比任意的$k\le p$更优。因此$p[i+1][j]\ge p[i][j]$。</p><p>同理可证$p[i][j-1]\le p[i][j]$。</p><h3 id="例题-NOI1995-石子合并"><a href="#例题-NOI1995-石子合并" class="headerlink" title="例题 [NOI1995]石子合并"></a>例题 [NOI1995]石子合并</h3><p>在一个圆形操场的四周摆放$N$堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的$2$堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出一个算法,计算出将$ N$堆石子合并成$1 $堆的最小得分和最大得分。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\le N\le 100,0\le a_i\le 20$</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">[NOI1995]石子合并</a> </p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先本题的数据范围$O(N^3)$的算法是可以过的。</p><p>若$N\le 1000$的话，就需要优化了。</p><p>定义$fmax$与$fmin$表示最大最小得分，$sum$为$a$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">fmax[l][r]=\max_{l\le k< r}\{f[l][k],f[k+1][r]\}+sum[r]-sum[l-1] \\fmin[l][r]=\min_{l\le k< r}\{f[l][k],f[k+1][r]\}+sum[r]-sum[l-1]</script><p>明显$w(l,r)=sum[r]-sum[l-1]$满足四边形不等式。于是求$fmin$可以采用四边形不等式优化。</p><p>但是$fmax$不满足四边形不等式。动手推推，发现取得最大值的决策只能在$f[l+1][r]$和$f[l][r-1]$中，取两者最大值作为决策即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,minf[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],a[N&lt;&lt;<span class="number">1</span>],sum[N&lt;&lt;<span class="number">1</span>],maxf[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],p[N&lt;&lt;<span class="number">1</span>][N&lt;&lt;<span class="number">1</span>],minsco=INF,maxsco=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">a[i+n]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++) &#123;</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">p[i][i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=(n&lt;&lt;<span class="number">1</span>);l++) &#123;</span><br><span class="line"><span class="keyword">int</span> r=l+len<span class="number">-1</span>,minn=INF,minid;</span><br><span class="line">maxf[l][r]=max(maxf[l+<span class="number">1</span>][r],maxf[l][r<span class="number">-1</span>])+sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=p[l][r<span class="number">-1</span>];k&lt;=p[l+<span class="number">1</span>][r];k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(minf[l][k]+minf[k+<span class="number">1</span>][r]+sum[r]-sum[l<span class="number">-1</span>]&lt;minn) &#123;</span><br><span class="line">minn=minf[l][k]+minf[k+<span class="number">1</span>][r]+sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">minid=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minf[l][r]=minn;</span><br><span class="line">p[l][r]=minid;</span><br><span class="line"><span class="keyword">if</span>(len==n) &#123;</span><br><span class="line">minsco=min(minsco,minf[l][r]);</span><br><span class="line">maxsco=max(maxsco,maxf[l][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minsco&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxsco&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>若是考场上遇到了疑似能四边形不等式优化的题，可以打表判断其是否符合四边形不等式，毕竟考场时间有限。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《算法竞赛进阶指南》</p><p><a href="https://www.cnblogs.com/Xing-Ling/p/11317315.html" target="_blank" rel="noopener">【学习笔记】动态规划—各种 DP 优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HAOI2007] 理想的正方形</title>
      <link href="/is-zxy.github.io/2020/02/21/%5BHAOI2007%5D-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/is-zxy.github.io/2020/02/21/%5BHAOI2007%5D-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>有一个$a\times b$的整数组成的矩阵，现请你从中找出一个$n\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>（1）矩阵中的所有数都不超过$1,000,000,000$</p><p>（2）$20\%$的数据$2&lt;=a,b&lt;=100,n&lt;=a,n&lt;=b,n&lt;=10$</p><p>（3）$100\%$的数据$2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2216" target="_blank" rel="noopener">[HAOI2007]理想的正方形</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一个二维的RMQ问题。</p><p>明显可以二维ST表解决，时间复杂度$O(ab\log n)$。</p><p>其实也是一个二维的滑动窗口问题，可用单调队列解决，时间复杂度会更优。咕咕咕。</p><h3 id="代码（ST表）"><a href="#代码（ST表）" class="headerlink" title="代码（ST表）"></a>代码（ST表）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,n,s[N][N],minf[N][N][<span class="number">15</span>],maxf[N][N][<span class="number">15</span>],lg[N],ans=INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=lg[n];k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=a;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=b;j++) &#123;</span><br><span class="line">minf[i][j][k]=min(minf[i][j][k<span class="number">-1</span>],min(minf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j][k<span class="number">-1</span>],min(minf[i][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>],minf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>])));</span><br><span class="line">maxf[i][j][k]=max(maxf[i][j][k<span class="number">-1</span>],max(maxf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j][k<span class="number">-1</span>],max(maxf[i][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>],maxf[i+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][j+(<span class="number">1</span>&lt;&lt;k<span class="number">-1</span>)][k<span class="number">-1</span>])));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=lg[n];</span><br><span class="line"><span class="keyword">return</span> max(maxf[i][j][t],max(maxf[i][j+n-(<span class="number">1</span>&lt;&lt;t)][t],max(maxf[i+n-(<span class="number">1</span>&lt;&lt;t)][j][t],maxf[i+n-(<span class="number">1</span>&lt;&lt;t)][j+n-(<span class="number">1</span>&lt;&lt;t)][t])))-min(minf[i][j][t],min(minf[i][j+n-(<span class="number">1</span>&lt;&lt;t)][t],min(minf[i+n-(<span class="number">1</span>&lt;&lt;t)][j][t],minf[i+n-(<span class="number">1</span>&lt;&lt;t)][j+n-(<span class="number">1</span>&lt;&lt;t)][t])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(minf,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(minf));</span><br><span class="line"><span class="built_in">memset</span>(maxf,<span class="number">0</span>,<span class="keyword">sizeof</span>(maxf));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i][j];</span><br><span class="line">minf[i][j][<span class="number">0</span>]=maxf[i][j][<span class="number">0</span>]=s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a-n+<span class="number">1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b-n+<span class="number">1</span>;j++) &#123;</span><br><span class="line">ans=min(ans,ask(i,j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAOI </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3398] 仓鼠找sugar</title>
      <link href="/is-zxy.github.io/2020/02/20/%5B%E6%B4%9B%E8%B0%B7P3398%5D-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/"/>
      <url>/is-zxy.github.io/2020/02/20/%5B%E6%B4%9B%E8%B0%B7P3398%5D-%E4%BB%93%E9%BC%A0%E6%89%BEsugar/</url>
      
        <content type="html"><![CDATA[<p>小仓鼠的和他的基（mei）友（zi）sugar住在地下洞穴中，每个节点的编号为$1$~$n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？</p><p>小仓鼠那么弱，还要天天被zzq大爷虐，请你快来救救他吧！</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$20\%$的数据$n&lt;=200,q&lt;=200$</p><p>$40\%$的数据$n&lt;=2000,q&lt;=2000$</p><p>$70\%$的数据$n&lt;=50000,q&lt;=50000$</p><p>$100\%$的数据$n&lt;=100000,q&lt;=100000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3398" target="_blank" rel="noopener">P3398 仓鼠找sugar</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求两条树上最短路的交点。</p><p>动手模拟模拟，发现若两路径若有交点，则较深的两点的LCA一定在另一条路径上。</p><p>那么如何判断一点在一条路径上呢？</p><p>树上的最短路是一条链，链上任意一点到链两边距离相等，于是便可以据此判断两点的LCA是否在另一条路径上。</p><p>接下来的问题就是如何求两点间距离。</p><p>定义$depth[x]$表示点$x$的深度。</p><p>其实很容易得到，点$x$与点$y$的距离$dis(x,y)=depth[x]+depth[y]-2\times depth[LCA(x,y)]$。</p><p>这里的距离是在本题边权为$1$的情况而定的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">25</span>],head[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> depth[x]+depth[y]<span class="number">-2</span>*depth[LCA(x,y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"><span class="keyword">int</span> lab=LCA(a,b),lcd=LCA(c,d);</span><br><span class="line"><span class="keyword">if</span>(depth[lab]&gt;depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dis(lab,c)+dis(lab,d)==depth[c]+depth[d]<span class="number">-2</span>*depth[lcd]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(depth[lab]==depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(lab==lcd) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(depth[lab]&lt;depth[lcd]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dis(lcd,a)+dis(lcd,b)==depth[a]+depth[b]<span class="number">-2</span>*depth[lab]) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO08OCT] 牧场散步Pasture Walking</title>
      <link href="/is-zxy.github.io/2020/02/19/%5BUSACO08OCT%5D-%E7%89%A7%E5%9C%BA%E6%95%A3%E6%AD%A5Pasture-Walking/"/>
      <url>/is-zxy.github.io/2020/02/19/%5BUSACO08OCT%5D-%E7%89%A7%E5%9C%BA%E6%95%A3%E6%AD%A5Pasture-Walking/</url>
      
        <content type="html"><![CDATA[<p>有$N(2&lt;=N&lt;=1000)$头奶牛，编号为$1$到$W$，它们正在同样编号为$1$到$N$的牧场上行走.为了方便，我们假设编号为$i$的牛恰好在第i号牧场上.</p><p>有一些牧场间每两个牧场用一条双向道路相连，道路总共有$N - 1$条，奶牛可以在这些道路 上行走.第i条道路把第$A_i$个牧场和第$B_i$个牧场连了起来$(1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N)$，而它的长度 是$ 1 &lt;= L_i &lt;= 10,000$。在任意两个牧场间，有且仅有一条由若干道路组成的路径相连.也就是说，所有的道路构成了一棵树。</p><p>奶牛们十分希望经常互相见面.它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出$Q(1 &lt; Q &lt; 1000)$对点之间的路径长度，每对点以一个询问$p_1$,$p_2$$ (1 &lt;= p1 &lt;= N; 1 &lt;= p2 &lt;= N)$。 的形式给出。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$  (2 &lt;= N &lt;= 1,000) $</p><p>$ (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) $</p><p>$ (1 &lt;= L_i &lt;= 10,000) $</p><p>$ (1 &lt;= p_1 &lt;= N; 1 &lt;= p_2 &lt;= N) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2912" target="_blank" rel="noopener">[USACO08OCT]牧场散步Pasture Walking</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两点间路径长度即到其LCA的路径长度之和。</p><p>定义$f[x][i]$表示点$x$的第$2^i$级祖先，$dis[x][i]$表示点$x$到其第$2^i$级祖先的路径长度。</p><p>易得</p><script type="math/tex; mode=display">dis[x][i]=dis[x][i-1]+dis[f[x][i-1]][i-1]</script><p>于是跑个倍增LCA，过程中计算答案即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,head[N],tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">15</span>],dis[N][<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">dis[now][<span class="number">0</span>]=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) &#123;</span><br><span class="line">f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">dis[now][i]=dis[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]+dis[now][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) <span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) &#123;</span><br><span class="line">ans+=dis[x][lg[depth[x]-depth[y]]];</span><br><span class="line">x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">ans+=dis[x][i]+dis[y][i];</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans+dis[x][<span class="number">0</span>]+dis[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;LCA(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOIP2013] 货车运输</title>
      <link href="/is-zxy.github.io/2020/02/18/%5BNOIP2013%5D-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/"/>
      <url>/is-zxy.github.io/2020/02/18/%5BNOIP2013%5D-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p>A 国有$n$座城市，编号从$1$到$n$，城市之间有$m$条双向道路。每一条道路对车辆都有重量限制，简称限重。</p><p>现在有$q$辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$1 \le n &lt; 1000$，$1 \le m &lt; 10,000$，$1\le q&lt; 1000$；</p><p>对于$ 60\%$的数据，$1 \le n &lt; 1000$，$1 \le m &lt; 5\times 10^4$，$1 \le q&lt; 1000$；</p><p>对于$ 100\%$的数据，$1 \le n &lt; 10^4$，$1 \le m &lt; 5\times 10^4$，$1 \le q&lt; 3\times 10^4$，$0 \le z \le 10^5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">货车运输</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前的思路是kruskal最大生成树，过程中每并两点，就把问题集合扫一遍，若问题集合中的$x,y$此时相连，那么该问题的答案即为目前加进去的边权值。当然，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,vset[<span class="number">10010</span>],q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dis;</span><br><span class="line">&#125;edge[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.dis&gt;y.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa=find(edge[i].from),fb=find(edge[i].to);</span><br><span class="line"><span class="keyword">if</span>(fa!=fb) vset[fa]=fb;</span><br><span class="line"><span class="keyword">if</span>(find(x)==find(y)) &#123;</span><br><span class="line">ans=edge[i].dis;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">edge[i].from=x;</span><br><span class="line">edge[i].to=y;</span><br><span class="line">edge[i].dis=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;kruskal(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后听说正解是LCA。</p><p>于是最近学了倍增LCA，便A了这题。</p><p>首先还是kruskal最大生成树当然，图若不连通就是森林。</p><p>对于每个问题，先判断其是否在一个树上，然后跑个倍增LCA，记录答案即可。</p><p>主要就是倍增思想。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,vset[N],head[N],tot=<span class="number">0</span>,lg[N],depth[N],f[N][<span class="number">25</span>],v[N][<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graph</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,dis;</span><br><span class="line">&#125;edge_g[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(graph a,graph b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==vset[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> vset[x]=find(vset[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(edge_g+<span class="number">1</span>,edge_g+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vset[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> fa=find(edge_g[i].x),fb=find(edge_g[i].y);</span><br><span class="line"><span class="keyword">if</span>(fa!=fb) &#123;</span><br><span class="line">add(edge_g[i].x,edge_g[i].y,edge_g[i].dis);</span><br><span class="line">add(edge_g[i].y,edge_g[i].x,edge_g[i].dis);</span><br><span class="line">vset[fa]=fb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> now,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">vh[now]=<span class="number">1</span>;</span><br><span class="line">depth[now]=depth[from]+<span class="number">1</span>;</span><br><span class="line">f[now][<span class="number">0</span>]=from;</span><br><span class="line">v[now][<span class="number">0</span>]=value;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lg[depth[now]];i++) &#123;</span><br><span class="line">v[now][i]=min(v[now][i<span class="number">-1</span>],v[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">f[now][i]=f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=from) dfs(now,edge[i].to,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) &#123;</span><br><span class="line">dfs(<span class="number">0</span>,i,INF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(find(x)!=find(y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(depth[x]&lt;depth[y]) swap(x,y);</span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">while</span>(depth[x]&gt;depth[y]) &#123;</span><br><span class="line">ans=min(ans,v[x][lg[depth[x]-depth[y]]]);</span><br><span class="line">x=f[x][lg[depth[x]-depth[y]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lg[depth[x]];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">ans=min(min(v[x][i],v[y][i]),ans);</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min(ans,min(v[x][<span class="number">0</span>],v[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;edge_g[i].x&gt;&gt;edge_g[i].y&gt;&gt;edge_g[i].dis;</span><br><span class="line"></span><br><span class="line">kruskal();</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;LCA(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> NOIP </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#65] triangle</title>
      <link href="/is-zxy.github.io/2020/02/17/%5BNOI-AC-65%5D-triangle/"/>
      <url>/is-zxy.github.io/2020/02/17/%5BNOI-AC-65%5D-triangle/</url>
      
        <content type="html"><![CDATA[<p>一个无限行的数字三角形，第$i$行有$i$个数。第一行的第一个数是$1$，其他的数满足如下关系：如果用$F[i][j]$表示第$i$行的第$j$个数，那么$F[i][j]=A∗F[i−1][j]+B∗F[i−1][j−1]$（不合法的下标的数为$0$）。</p><p>当$A=2,B=3A=2,B=3$时的数字三角形的前$5$行为：</p><p>$1$</p><p>$2\ 3$</p><p>$4\ 12\ 9$</p><p>$8\ 36\ 54\ 27$</p><p>$16\ 96\ 216\ 216\ 81$</p><p>现在有$T$次询问，求$A=a,B=b$时数字三角形的第$n$行第$m$个数的值模$10^9+9$的结果。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$n,T≤100000,1≤m≤n,0≤a,b≤109$。</p><p>Subtask1 ($20\%$) ：$n,T≤100$。</p><p>Subtask2 ($20\%$) ：$n≤10000,T≤1000$。</p><p>Subtask3 ($60\%$) ：无特殊限制。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/65" target="_blank" rel="noopener">#65. triangle</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显，这东西就是求$(ax+by)^{n-1}$的$x^{n-m}y^{m-1}$项的系数。</p><p>根据二项式定理，可以得知答案为</p><script type="math/tex; mode=display">a^{n-m}b^{m-1}C_{n-1}^{n-m}</script><p>卢卡斯快速幂瞎搞即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p)*(y%p))%p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(mul(t,t),x);</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> mul(mul(f[n],quickp(f[m],p<span class="number">-2</span>)),quickp(f[n-m],p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;i++) f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line">ll a,b,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mul(mul(Laucs(n<span class="number">-1</span>,m<span class="number">-1</span>),quickp(a,n-m)),quickp(b,m<span class="number">-1</span>)));</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#66] 求和</title>
      <link href="/is-zxy.github.io/2020/02/17/%5BNOI-AC-66%5D-%E6%B1%82%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/02/17/%5BNOI-AC-66%5D-%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给一个$n$行$t$列的矩阵，矩阵第$i$行第$j$列的元素是$i+j$。</p><p>定义矩阵第$i$行的积为第$i$行所有元素的乘积。</p><p>现在要你求矩阵所有行的积的和。答案可能很大，所以$mod\ \ 1000000007(10^9+7)$输出。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$10\%$, $T≤100$,$n≤1000$</p><p>另$20\%$,$T≤10$,$n≤1e7$</p><p>另$20\%$,$T≤10000$,$n≤1e7$</p><p>另$20\%$,$T≤10000$,$n≤1e8$</p><p>$100\%$,$1≤T≤10000$,$1≤n≤1e10$,$1≤t≤1000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/66" target="_blank" rel="noopener">#66. 求和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>则求</p><script type="math/tex; mode=display">\sum_{i=1}^n\prod_{j=1}^t(i+j)</script><p>易得每行都为连续自然数，则可化为</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n\frac{(i+t)!}{i!}&= \sum_{i=1}^n(C_{i+t}^i\times t!) \\&= t!\times \sum_{i=1}^nC_{i+t}^i \\&= t!\times \sum_{i=1}^nC_{i+t}^t\end{align}</script><p>考虑这种式子：</p><script type="math/tex; mode=display">\sum_{i=1}^nC_{i+t}^t</script><p>根据组合性质，有</p><script type="math/tex; mode=display">\begin{align}C_{n+1}^m &= C_{n}^m+C_{n}^{m-1} \\C_{n}^{m-1} &= C_{n+1}^m-C_n^m \\C_{n}^m &= c_{n+1}^{m+1}-C_n^{m+1}\end{align}</script><p>那么上式可化为</p><script type="math/tex; mode=display">\begin{align}\sum_{i=1}^n(C_{i+t+1}^{t+1}-C_{i+t}^{t+1})&= C_{n+t+1}^{t+1}-C_{t+1}^{t+1} \\&= C_{n+t+1}^{t+1}-1\end{align}</script><p>那么答案即为</p><script type="math/tex; mode=display">t!\times (C_{n+t+1}^{t+1}-1) \mod 1000000007</script><p>预处理出阶乘，然后卢卡斯即可。</p><p>注意卢卡斯求$C_{n+t+1}^{t+1}\mod p$的结果可能为$0$，再减一为负，所以最终答案要加上$p$再模$p$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mul(x,y) (((x%p)*(y%p))%p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,t,T,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) <span class="keyword">return</span> mul(mul(t,t),x);</span><br><span class="line"><span class="keyword">return</span> mul(t,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m=n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=mul(a,n-i);</span><br><span class="line">b=mul(b,i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mul(a,quickp(b,p<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mul(Laucs(n/p,m/p),C(n%p,m%p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N<span class="number">-10</span>;i++) f[i]=mul(f[i<span class="number">-1</span>],i);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line">ll ans=mul(f[t],Laucs(n+t+<span class="number">1</span>,t+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(ans+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> NOI.AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI.AC#605] 约数个数</title>
      <link href="/is-zxy.github.io/2020/02/16/%5BNOI-AC-605%5D-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
      <url>/is-zxy.github.io/2020/02/16/%5BNOI-AC-605%5D-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>$f(n)$表示$n$的约数个数，现在给出$n$，求出$f(1)$到$f(n)$的总和 。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，满足$n≤5000$。 </p><p>对于$100\%$的数据，满足$n≤1000000$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://noi.ac/problem/605" target="_blank" rel="noopener">#605. 约数个数</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥思路。线性筛板子。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,prime[N],v[N],num[N],factor[N],m=<span class="number">0</span>;</span><br><span class="line">ll sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">factor[<span class="number">1</span>]=sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">num[i]=<span class="number">1</span>;</span><br><span class="line">factor[i]=<span class="number">2</span>;</span><br><span class="line">sum+=factor[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]*factor[prime[j]];</span><br><span class="line">num[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">factor[i*prime[j]]=factor[i]/(num[i]+<span class="number">1</span>)*(num[i]+<span class="number">2</span>);</span><br><span class="line">num[i*prime[j]]=num[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=factor[i*prime[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性筛 </tag>
            
            <tag> NOI.AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2016] 征途</title>
      <link href="/is-zxy.github.io/2020/02/15/%5BSDOI2016%5D-%E5%BE%81%E9%80%94/"/>
      <url>/is-zxy.github.io/2020/02/15/%5BSDOI2016%5D-%E5%BE%81%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p>Pine开始了从S地到T地的征途。</p><p>从S地到T地的路可以划分成$n$段，相邻两段路的分界点设有休息站。</p><p>Pine计划用$m$天到达T地。除第$m$天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。</p><p>Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。</p><p>帮助Pine求出最小方差是多少。</p><p>设方差是$v$，可以证明，$v\times m^2$是一个整数。为了避免精度误差，输出结果时输出$v\times m^2$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1 \le n \le 10$</p><p>对于$60\%$的数据，$1 \le n \le 100$</p><p>对于$100\%$的数据，$1 \le n \le 3000$</p><p>保证从 S 到 T 的总路程不超过$30000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4072" target="_blank" rel="noopener">[SDOI2016]征途</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$v$是方差，则$v=\frac{\sum_{i=1}^m(S_i-\frac{sum[n]}{m})^2}{m}$</p><p>则</p><script type="math/tex; mode=display">\begin{align}v\times m^2 &= m\sum_{i=1}^m(S_i-\frac{sum[n]}{m})^2 \\&= m\sum_{i=1}^m(S_i^2-2\times S_i\times \frac{sum[n]}{m}+\frac{sum[n]^2}{m^2}) \\&= m\sum_{i=1}^mS_i^2-2\times sum[n]\sum_{i=1}^mS_i+sum[n]^2 \\&= m\sum_{i=1}^mS_i^2-2\times sum[n]^2+sum[n]^2 \\&= m\sum_{i=1}^mS_i^2-sum[n]^2\end{align}</script><p>于是最小化$m\sum_{i=1}^mS_i^2$即可。</p><p>定义$dp[i][k]$表示前$i$段在第$k$天走到的最小$\sum_{i=1}^kS_i^2$的最小值。</p><p>易得</p><script type="math/tex; mode=display">dp[i][k]=\min\{dp[j][k-1]+m\times (sum[i]-sum[j])^2\},i\in[1,n],k\in[0,i)</script><p>最终答案即为$dp[n][m]-sum[n]^2$</p><p>于是可以得到一个$O(mn^2)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[N],sum[N],dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i][k]=min(dp[i][k],dp[j][k<span class="number">-1</span>]+m*(sum[i]-sum[j])*(sum[i]-sum[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]-sum[n]*sum[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$\min$内的式子单独提出来看看。</p><script type="math/tex; mode=display">\begin{align}dp[j][k-1]+m\times (sum[i]-sum[j])^2 &= dp[j][k-1]+m(sum[i]^2-2\times sum[i]\times sun[j]+sum[j]^2) \\&= dp[j][k-1]+m\times sun[i]^2-2m\times sum[i]\times sum[j]+m\times sum[j]^2\end{align}</script><p>将常量剔除，得</p><script type="math/tex; mode=display">dp[j][k-1]-2m\times sum[i]\times sum[j]+m\times sum[j]^2</script><p>定义$sm[i]=m\times sum[i]^2$，则变为</p><script type="math/tex; mode=display">dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j]</script><p>则原状转方程变为</p><script type="math/tex; mode=display">dp[i][k]=\min\{dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j]\}+sm[i],i\in[1,n],k\in[0,i)</script><p>令$p&lt;j&lt;i$， 若转移决策点$j$比转移决策点$k$更优，则</p><script type="math/tex; mode=display">\begin{align}dp[j][k-1]-2m\times sum[i]\times sum[j]+sm[j] &\le dp[p][k-1]-2m\times sum[i]\times sum[p]+sm[p] \\ \\dp[j][k-1]+sm[j]-(dp[p][k-1]+sm[p]) &\le 2m\times sum[i](sum[j]-sum[p]) \\ \\\frac{dp[j][k-1]+sm[j]-(dp[p][k-1]+sm[p])}{sum[j]-sum[p]} &\le 2m\times sum[i]\end{align}</script><p>看到这式子，明显可以斜率优化，维护下凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q[N];</span><br><span class="line">ll a[N],sum[N],dp[N][N],sm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">sm[i]=m*sum[i]*sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">1</span>]=sm[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=m;k++) &#123;</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]][k<span class="number">-1</span>]+sm[q[head+<span class="number">1</span>]]-(dp[q[head]][k<span class="number">-1</span>]+sm[q[head]])&lt;=<span class="number">2</span>*m*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i][k]=dp[q[head]][k<span class="number">-1</span>]<span class="number">-2</span>*m*sum[i]*sum[q[head]]+sm[q[head]]+sm[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]][k<span class="number">-1</span>]+sm[q[tail]]-(dp[q[tail<span class="number">-1</span>]][k<span class="number">-1</span>]+sm[q[tail<span class="number">-1</span>]]))*(sum[i]-sum[q[tail]])&gt;=(dp[i][k<span class="number">-1</span>]+sm[i]-(dp[q[tail]][k<span class="number">-1</span>]+sm[q[tail]]))*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][m]-sum[n]*sum[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2015] WIL-Wilcze doły</title>
      <link href="/is-zxy.github.io/2020/02/14/%5BPOI2015%5D-WIL-Wilcze-doly/"/>
      <url>/is-zxy.github.io/2020/02/14/%5BPOI2015%5D-WIL-Wilcze-doly/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$n$的序列，你有一次机会选中一段连续的长度不超过$d$的区间，将里面所有数字全部修改为$0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过$p$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=d&lt;=n&lt;=2000000,0&lt;=p&lt;=10^{16})$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3594" target="_blank" rel="noopener">[POI2015]WIL-Wilcze doły</a> </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于每个数都是正数，那么当然修改的越多越好，干脆直接修改长度为$d$的区间。</p><p>枚举选中的连续区间的左右端点和被修改区间的左端点，便可以得到一个$O(n^3)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>;</span><br><span class="line">ull p,a[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-d+<span class="number">1</span>;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=i-d+<span class="number">1</span>;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]-sum[j<span class="number">-1</span>]-(sum[k+d<span class="number">-1</span>]-sum[k<span class="number">-1</span>])&lt;=p) ans=max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种选连续数和不超过一个数值的题型让我想到了挑程上的尺取法。于是便采用了这种方法进行优化，向一个队列中加数，当和大于了$p$，就开始从被选的数列中枚举修改为$0$的区间的左端点，若不存在修改后小于等于$p$的修改区间，则将队头出队。过程中记录最大区间长度即可。时间复杂度$O(n^2)$，还是TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>,l=<span class="number">1</span>;</span><br><span class="line">ull p,a[N],sum[N],s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">s+=a[i];</span><br><span class="line"><span class="keyword">if</span>(i-l+<span class="number">1</span>&lt;=d) &#123;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s&gt;p) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=i-d+<span class="number">1</span>;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s-(sum[j+d<span class="number">-1</span>]-sum[j<span class="number">-1</span>])&lt;=p) &#123;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) s-=a[l++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显， 被修改的长为$d$的区间内的数和越大越好，于是可以在用尺取法的过程中用单调队列维护单调递增的目前尺取的区间内长为$d$的区间和的区间左端点进行优化即可。</p><p>时间复杂度$O(n)$，AC。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,d,ans=<span class="number">0</span>,l=<span class="number">1</span>,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ull p,a[N],sum[N],s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="keyword">if</span>(i&lt;=d) s+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q[head]=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">s+=a[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;sum[i]-sum[i-d]&gt;=sum[q[tail]]-sum[q[tail]-d]) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]-d+<span class="number">1</span>&lt;l) head++;</span><br><span class="line"><span class="keyword">while</span>(s-(sum[q[head]]-sum[q[head]-d])&gt;p) &#123;</span><br><span class="line">s-=a[l++];</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]-d+<span class="number">1</span>&lt;l) head++;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,i-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POI </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 线性动规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1613] 跑路</title>
      <link href="/is-zxy.github.io/2020/02/13/%5B%E6%B4%9B%E8%B0%B7P1613%5D-%E8%B7%91%E8%B7%AF/"/>
      <url>/is-zxy.github.io/2020/02/13/%5B%E6%B4%9B%E8%B0%B7P1613%5D-%E8%B7%91%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑$2^k$千米（$k$是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点$1$，公司为点$n$，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证$1$到$n$至少有一条路径。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$50\%$的数据满足最优解路径长度$&lt;=1000$；</p><p>$100\%$的数据满足$n&lt;=50，m&lt;=10000$，最优解路径长度$&lt;=maxlongint$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1613" target="_blank" rel="noopener">P1613 跑路</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读完题，我就想：这不就是求最短路二进制下$1$的个数吗？</p><p>严重的错误。</p><p>可以绕着一个环一直跑，跑出个长为$2^k$的路出来，这样路程虽长，但只需一秒。</p><p>于是先求出各个点之间是否有长为$2^k$的路，有的话将这两点之间距离变为$1$。</p><p>最后用Floyd跑个最短路即可。$(n\leq 50)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,dis[N][N];</span><br><span class="line"><span class="keyword">bool</span> to[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=N;l++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(to[i][j][l<span class="number">-1</span>]&amp;&amp;to[j][k][l<span class="number">-1</span>]) &#123;</span><br><span class="line">to[i][k][l]=<span class="number">1</span>;</span><br><span class="line">dis[i][k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dis[i][k]=min(dis[i][k],dis[i][j]+dis[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">to[x][y][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">dis[x][y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">Floyd();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF57C] Array</title>
      <link href="/is-zxy.github.io/2020/02/13/%5BCF57C%5D-Array/"/>
      <url>/is-zxy.github.io/2020/02/13/%5BCF57C%5D-Array/</url>
      
        <content type="html"><![CDATA[<p>对于长度为$n$的数组$A$，$A$中只包含从$1$到$n$的整数（可重复）。如果$A$单调不上升或单调不下降，$A$就可称为美丽的。 找出在长度为$n$时，有几个美丽的$A$。 </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF57C" target="_blank" rel="noopener">CF57C Array</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$x_i$表示数组中数字$i$个个数，数字单调不下降的排在一起。</p><p>那么明显，$\sum_{i=1}^nx_i=n$的非负整数解的个数就是单调不下降的序列个数。</p><p>这就是组合数学基础了，可用插板法求出方案数为$C_{2n-1}^n$。</p><p>单调不下降的序列翻转一下就是个单调不上升的序列，那么单调不上升的序列的个数也为$C_{2n-1}^n$。</p><p>两者间的重复方案为整个序列中的所有数相同，即有$n$个。</p><p>故总个数为$2\times C_{2n-1}^n-n$</p><p>卢卡斯求下即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickp</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickp(x,y/<span class="number">2</span>);</span><br><span class="line">t=(t*t)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) t=(t*x)%p;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m=n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=(a*(n-i))%p;</span><br><span class="line">b=(b*(i+<span class="number">1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a*quickp(b,p<span class="number">-2</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (Laucs(n/p,m/p)*C(n%p,m%p))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*Laucs(<span class="number">2</span>*n<span class="number">-1</span>,n)-n)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢卡斯（Lucas）定理学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/11/%E5%8D%A2%E5%8D%A1%E6%96%AF%EF%BC%88Lucas%EF%BC%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/11/%E5%8D%A2%E5%8D%A1%E6%96%AF%EF%BC%88Lucas%EF%BC%89%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>卢卡斯（Lucas）定理可以用来求$C_n^m\ mod\ p$。</p><p>前置知识：乘法逆元。</p><a id="more"></a><h1 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h1><p>令$n=sp+q,m=tp+r,(q,r\le p)$，则有</p><script type="math/tex; mode=display">C_n^m=C_{sp+q}^{tp+r} \equiv C_s^t\times C_q^r(mod\ p)</script><hr><h1 id="简要证明"><a href="#简要证明" class="headerlink" title="简要证明"></a>简要证明</h1><p>定义</p><script type="math/tex; mode=display">n=sp+q,m=tp+r,(q,r\le p)</script><p>组合数定义</p><script type="math/tex; mode=display">C_n^m=\frac{n!}{m!(n-m)!}</script><p>于是易得</p><script type="math/tex; mode=display">C_p^d \equiv 0(mod\ p),d\in(0,p)\ ①</script><p>由二项式定理</p><script type="math/tex; mode=display">(x+y)^n=\sum_{i=0}^nC_n^ix^{n-i}y^i</script><p>于是</p><script type="math/tex; mode=display">(1+x)^n=(1+x)^{sp+q}=(1+x)^q\times[(1+x)^p]^s=(1+x)^q\times[\sum_{i=0}^pC_p^ix^i]^s</script><p>由式①，可得</p><script type="math/tex; mode=display">\begin{align}(1+x)^n &\equiv (1+x)^q\times[\sum_{i=0}^pC_p^ix^i]^s \\ &\equiv (1+x)^q\times (1+x^p)^s\ (mod\ p) \\ &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p)\end{align}</script><p>则</p><script type="math/tex; mode=display">\begin{align}(1+x)^{sp+q} &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p) \\\sum_{k=0}^{sp+q}C_{sp+q}^kx^k &\equiv \sum_{i=0}^qC_q^ix^i\times \sum_{j=0}^sC_s^jx^{jp}\ (mod\ p) \\\end{align}</script><p>两边同时取$x^{sp+r}$项</p><script type="math/tex; mode=display">C_{sp+q}^{tp+r}x^{tp+r} \equiv C_q^rx^r\times C_{s}^{t}x^{tp}\ (mod\ p)</script><p>而$n=sp+q,m=tp+r,(q,r\le p)$，则</p><script type="math/tex; mode=display">\begin{align}C_n^mx^m &\equiv C_q^r\times C_s^tx^{tp+r}\ (mod\ p) \\&\equiv C_q^r\times C_s^tx^m\ (mod\ p)\end{align}</script><p>两边同时消去$x^m$，可得</p><script type="math/tex; mode=display">C_n^m \equiv C_q^r\times C_s^t\ (mod\ p)</script><p>于是得证。</p><hr><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>有了这个定理，于是我们可以递归求解$C_s^t\ mod\ p$，再用乘法逆元求出$C_q^r\ mod\ p$，两者相乘再$mod\ p$即可。</p><p>转化成一个更加易懂的形式，即</p><script type="math/tex; mode=display">s=\lfloor \frac{n}{p} \rfloor,t=\lfloor \frac{m}{p} \rfloor,q=n\ mod\ p,r=m\ mod\ p \\C_n^m \equiv C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times C_{n\ mod\ p}^{m\ mod\ p}\ (mod\ p)</script><p>定义$C_n^m \equiv Lucas(n,m)\ (mod\ p)$</p><p>则递归式为$Lucas(n,m) \equiv Lucas_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times C_{n\ mod\ p}^{m\ mod\ p}\ (mod\ p)$</p><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷P3807-【模板】卢卡斯定理"><a href="#洛谷P3807-【模板】卢卡斯定理" class="headerlink" title="[洛谷P3807] 【模板】卢卡斯定理"></a>[洛谷P3807] 【模板】卢卡斯定理</h2><p>给定$n,m,p(1\le n,m,p\le 10^5)$</p><p>求$C_{n+m}^{m}\ mod\ p$</p><p>保证$P$为$prime$</p><p>$C$表示组合数。</p><p>一个测试点内包含多组数据。</p><!--more--><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3807" target="_blank" rel="noopener">P3807 【模板】卢卡斯定理</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥思路，套板子就好。</p><p>当然乘法逆元也可以用扩欧写。这里我只写了费马小定理的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll n,m,p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickpow(x,y/<span class="number">2</span>);</span><br><span class="line">t=(t*t)%p;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) t=(t*x)%p;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m&gt;n-m) m-n-m;</span><br><span class="line">ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">a=(a*(n-i))%p;</span><br><span class="line">b=(b*(i+<span class="number">1</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (a*quickpow(b,p<span class="number">-2</span>))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Laucs</span><span class="params">(ll n,ll m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (Laucs(n/p,m/p)*C(n%p,m%p))%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Laucs(n+m,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 卢卡斯定理 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 乘法逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU3507] Print Article</title>
      <link href="/is-zxy.github.io/2020/02/10/%5BHDU3507%5D-Print-Article/"/>
      <url>/is-zxy.github.io/2020/02/10/%5BHDU3507%5D-Print-Article/</url>
      
        <content type="html"><![CDATA[<p>给定一个有$n$个数的序列$c$，每次从中取出$[l,r]$内的数的花费为$(\sum_{i=l}^rc[i])+m$，求将序列中所有数取出来的最小花费。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(0 ≤ n ≤ 500000, 0 ≤ M ≤ 1000)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">Print Article</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示前$i$个数已经被取出来的最小花费。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+(sum[i]-sum[j])^2+m\},j\in[0,i)</script><p>于是可得一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m,c[N],sum[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;c[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(sum[i]-sum[j])*(sum[i]-sum[j])+m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微化化</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-2\times sum[i]sum[j]+sum[j]^2\}+sum[i]^2+m</script><p>令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优，则</p><p>$dp[j]-2\times sum[i]sum[j]+sum[j]^2 \le dp[k]-2\times sum[i]sum[k]+sum[k]^2$</p><p>定义$ds[i]=dp[i]+sum[i]^2$，则</p><p>$ds[j]-2\times sum[i]sum[j] \le ds[k]-2\times sum[i]sum[k]$</p><p>$ds[j]-ds[k] \le 2\times sum<a href="sum[j]-sum[k]">i</a>$</p><p>明显$sum$递增，则</p><p>$\frac{ds[j]-ds[k]}{sum[j]-sum[k]} \le 2\times sum[i]$</p><p>明显可以斜率优化，下凸壳，单调队列维护即可，不多解释。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head,tail;</span><br><span class="line">ll m,c[N],sum[N],dp[N],ds[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;c[i]);</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">head=tail=<span class="number">1</span>;</span><br><span class="line">dp[<span class="number">0</span>]=q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;ds[q[head+<span class="number">1</span>]]-ds[q[head]]&lt;=<span class="number">2</span>*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i]=ds[q[head]]<span class="number">-2</span>*sum[i]*sum[q[head]]+sum[i]*sum[i]+m;</span><br><span class="line">ds[i]=dp[i]+sum[i]*sum[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(ds[q[tail]]-ds[q[tail<span class="number">-1</span>]])*(sum[i]-sum[q[tail]])&gt;=(ds[i]-ds[q[tail]])*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> HDU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元学习笔记</title>
      <link href="/is-zxy.github.io/2020/02/10/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/02/10/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><p>定义：若整数$b$，$p$互质，并且$b|a$，则存在一个整数$x$，使得$\frac{a}{b} \equiv ax(mod\ p)$。称$x$为$b$的模$p$乘法逆元，记为$b^{-1} (mod\ p)$。<br><a id="more"></a></p><hr><h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><p>那么该如何求出这个x呢?</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>由定义，$\frac{a}{b} \equiv ax(mod\ p)$</p><p>两边同时乘$\frac{b}{a}$，得$1 \equiv bx(mod\ p)$</p><p>则$bx \equiv 1(mod\ p)$</p><p>这个同余方程可以转化为不定方程$bx+py = 1$（假设$bx=-yp+1$），而$b$与$p$又互质，即$gcd(b,p)=1$，那么就可以用扩展欧几里得算法求出$x$。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>费马小定理：$a^p \equiv a(mod\ p)$   （$p$为质数）</p><p>若$p$为质数，则$b^p \equiv b(mod\ p)$</p><p>两边同时除以$b$，得$b^{p-1} \equiv 1(mod\ p)$，这个式子也可用欧拉定理推出。</p><p>两边同时乘$a$，得$a \equiv ab^{p-1} (mod\ p)$</p><p>两边同时除以b，得$\frac{a}{b} \equiv ab^{p-2} (mod\ p)$</p><p>由定义，此时$x=b^{p-2}$</p><p>则直接求出$b^{p-2}$即可，可用快速幂</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>$1^{-1} \equiv 1(mod\ p)$</p><p>设$p=k*i+r$,$r&lt;i$,$l&lt;i&lt;p$，将此式放到$mod\ p$意义下会得到：$ki+r \equiv 0(mod\ p)$</p><p>两边同时乘$i^{-1}$，$r^{-1}$，可得：</p><p>$k*r^{-1}+i^{-1} \equiv 0 (mod\ p)$</p><p>$i^{-1} \equiv -k*r^{-1} (mod\ p)$</p><p>$i^{-1} \equiv -[p/i]*(p\ mod\ i)^{-1} (mod\ p)$</p><p>由此，假设$A[i]$表示$i$的逆元，则$A[i]=-[p/i]*A[p\ mod\ i]$。</p><hr><h1 id="洛谷P3811-【模板】乘法逆元"><a href="#洛谷P3811-【模板】乘法逆元" class="headerlink" title="[洛谷P3811] 【模板】乘法逆元"></a>[洛谷P3811] 【模板】乘法逆元</h1><p> 给定$n,p$求$1\sim n$中所有整数在模$p$意义下的乘法逆元。 </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P3811" target="_blank" rel="noopener">P3811 【模板】乘法逆元</a></p><h2 id="代码（方法一）"><a href="#代码（方法一）" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h2><p>本题保证了$p$是质数，那么直接就可以用扩展欧几里得算法求出$ix+py=1$的最小正整数解x即可。$(1&lt;=i&lt;=n)$<br>（TLE，$48$分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">EXgcd(i,p);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((x%p)+p)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法二）"><a href="#代码（方法二）" class="headerlink" title="代码（方法二）"></a>代码（方法二）</h2><p>保证$p$是质数了，直接利用快速幂求出$i^{p-2}$即可，求的过程中注意取模p<br>（TLE，$48$分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t=quickpow(x,y/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(y%<span class="number">2</span>) <span class="keyword">return</span> (t*t*x)%p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (t*t)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;quickpow(i,p<span class="number">-2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法三）"><a href="#代码（方法三）" class="headerlink" title="代码（方法三）"></a>代码（方法三）</h2><p>初始化$A[1]=1$，然后递推求解即可<br>（AC）</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">3000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">a[i]=-(p/i)*a[p%i];</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>) a[i]=a[i]%p+p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="洛谷P2613-【模板】有理数取余"><a href="#洛谷P2613-【模板】有理数取余" class="headerlink" title="[洛谷P2613] 【模板】有理数取余"></a>[洛谷P2613] 【模板】有理数取余</h1><p>给出一个有理数$c=\frac{a}{b}$，求$c \bmod 19260817$的值。 </p><p>对于所有数据，$0\leq a,b \leq 10^{10001}$。 </p><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P2613" target="_blank" rel="noopener">P2613 【模板】有理数取余</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数据这么大，高精？</p><p>当然是不必要的。</p><p>对于一个分数取模，自然想到乘法逆元。</p><p>而恰好，$19260817$它是个<strong>质数</strong>。</p><p>因为求的只是一个数的逆元，所以将$a,b$都对$19260817$取模后，套上面的方法一和二即可。</p><p>注意特判$b=0$的情况。</p><h2 id="代码（方法一）-1"><a href="#代码（方法一）-1" class="headerlink" title="代码（方法一）"></a>代码（方法一）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 19260817</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> sa,sb;</span><br><span class="line">ll a=<span class="number">0</span>,b=<span class="number">0</span>,la,lb,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXgcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123;</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">EXgcd(b,a%b);</span><br><span class="line"><span class="keyword">int</span> t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sa;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sb;</span><br><span class="line"></span><br><span class="line">la=sa.size(),lb=sb.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;la;i++) a=(a*<span class="number">10</span>+(sa[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lb;i++) b=(b*<span class="number">10</span>+(sb[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Angry!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">EXgcd(b,p);</span><br><span class="line">x=(x%p+p)%p;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(x*a)%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码（方法二）-1"><a href="#代码（方法二）-1" class="headerlink" title="代码（方法二）"></a>代码（方法二）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 19260817</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> sa,sb;</span><br><span class="line">ll a=<span class="number">0</span>,b=<span class="number">0</span>,la,lb;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll t=quickpow(x,k/<span class="number">2</span>)%p;</span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>) <span class="keyword">return</span> (((t*t)%p)*x)%p;</span><br><span class="line"><span class="keyword">return</span> (t*t)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sa;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sb;</span><br><span class="line"></span><br><span class="line">la=sa.size(),lb=sb.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;la;i++) a=(a*<span class="number">10</span>+(sa[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lb;i++) b=(b*<span class="number">10</span>+(sb[i]-<span class="string">'0'</span>))%p;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Angry!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;(a*quickpow(b,p<span class="number">-2</span>))%p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>乘法逆元的用处在哪呢？</p><p>当在题目中遇到了$\frac{a}{b}$这样的除法算式要求对$p$取模时，便可以根据$a,b,p$的性质，求出使得$\frac{a}{b} \equiv ax(mod\ p)$成立的$x$，这样就可以将原来不好取模的除法转化为好取模的乘法。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 乘法逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2009] HH的项链</title>
      <link href="/is-zxy.github.io/2020/02/09/%5BSDOI2009%5D-HH%E7%9A%84%E9%A1%B9%E9%93%BE/"/>
      <url>/is-zxy.github.io/2020/02/09/%5BSDOI2009%5D-HH%E7%9A%84%E9%A1%B9%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。</p><p>有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答…… 因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$1\le n,m\leq 5000$；<br>对于$40\%$的数据，$1\le n,m\leq 10^5$；<br>对于$60\%$的数据，$1\le n,m\leq 5\times 10^5$；<br>对于$100\%$的数据，$1\le n,m,a_i \leq 10^6$，$1\le l \le r \le n$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1972" target="_blank" rel="noopener">[SDOI2009]HH的项链</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>过于高级的数据结构方法我不会，只会一个离线的树状数组方法。</p><p>对于一段区间内相同类型的贝壳，肯定是看右面的。</p><p>将问题按照$r$递增排序。</p><p>于是用树状数组不断向后维护，当当前维护的贝壳种类在之前出现过时，删掉之前的那个，更新。</p><p>对于每一个问题从其上一个问题的$r$加$1$开始向后维护。</p><p>每次维护到第$i$个问题的$r_i$，维护完毕记录答案$ans_i=sum[r_i]-sum[l_i-1]$</p><p>最终按照序号输出$ans$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],m,c[N],next=<span class="number">1</span>,l[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,id;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.r==y.r) <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line"><span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(x;x&lt;=n;x+=lowbit(x)) c[x]+=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(x;x;x-=lowbit(x)) ans+=c[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].l,&amp;p[i].r);</span><br><span class="line">p[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(p+<span class="number">1</span>,p+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=next;j&lt;=p[i].r;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(l[q[j]]) update(l[q[j]],<span class="number">-1</span>);</span><br><span class="line">update(j,<span class="number">1</span>);</span><br><span class="line">l[q[j]]=j;</span><br><span class="line">&#125;</span><br><span class="line">next=p[i].r+<span class="number">1</span>;</span><br><span class="line">ans[p[i].id]=ask(p[i].r)-ask(p[i].l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> SDOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P6040] 课后期末考试滑溜滑溜补习班</title>
      <link href="/is-zxy.github.io/2020/02/09/%5B%E6%B4%9B%E8%B0%B7P6040%5D-%E8%AF%BE%E5%90%8E%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E6%BB%91%E6%BA%9C%E6%BB%91%E6%BA%9C%E8%A1%A5%E4%B9%A0%E7%8F%AD/"/>
      <url>/is-zxy.github.io/2020/02/09/%5B%E6%B4%9B%E8%B0%B7P6040%5D-%E8%AF%BE%E5%90%8E%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E6%BB%91%E6%BA%9C%E6%BB%91%E6%BA%9C%E8%A1%A5%E4%B9%A0%E7%8F%AD/</url>
      
        <content type="html"><![CDATA[<p>在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。</p><p>补习班上有$n$个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第$i$个学生的问题有一个困难值$a_i$，杀老师回答第$i$个学生的问题需要花费$a_i$的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。</p><p>杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费$k$点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为$k+(q-p-1) \times d$（当前位置为$p$，跳到的位置为$q$）。</p><p>当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过$x-1$个学生，去解决下$x$个学生的问题。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 100\%$的数据，$1 \leq n \leq 10^7$，$0 \leq k,d,a_i \leq 10^9$，$1 \leq x \leq n-1$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P6040" target="_blank" rel="noopener">P6040 课后期末考试滑溜滑溜补习班</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示已经解决到底$i$个同学的花费的最小精力数。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+a[i]+k+d\times(i-j-1)\},j\in[max(1,i-x),i)</script><p>其中初始化$dp[1]=a[1]$。</p><p>于是可以得到一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,tp,Seed;</span><br><span class="line">ll k,d,dp[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">return</span> Seed = ( <span class="number">1L</span>L * Seed * <span class="number">0x66CCFF</span> % MOD + <span class="number">20120712</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;d&gt;&gt;x&gt;&gt;tp;</span><br><span class="line"><span class="keyword">if</span>(!tp) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Seed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=max(i-x,<span class="number">1</span>);j&lt;i;j++) &#123;</span><br><span class="line">dp[i]=min(dp[i],dp[j]+a[i]+k+(i-j<span class="number">-1</span>)*d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将式子中的常量项从$min$中提出来，则得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-d\times j\}+a[i]+k+d\times i-d,j\in[max(1,i-x),i)</script><p>于是便可以用单调队列维护$min$内的东西单调递增即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,tp,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll k,d,dp[N],a[N],Seed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">return</span> Seed = ( <span class="number">1L</span>L * Seed * <span class="number">0x66CCFF</span> % MOD + <span class="number">20120712</span> ) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;d&gt;&gt;x&gt;&gt;tp;</span><br><span class="line"><span class="keyword">if</span>(!tp) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Seed;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>]=a[<span class="number">1</span>],q[head]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;q[head]&lt;max(<span class="number">1</span>,i-x)) head++;</span><br><span class="line">dp[i]=dp[q[head]]+a[i]+k+d*(i-q[head]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[i]-d*i&lt;=dp[q[tail]]-d*q[tail]) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[APIO2010] 特别行动队</title>
      <link href="/is-zxy.github.io/2020/02/09/%5BAPIO2010%5D-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/"/>
      <url>/is-zxy.github.io/2020/02/09/%5BAPIO2010%5D-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>你有一支由$n$名预备役士兵组成的部队，士兵从$1$到$n$编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号<strong>应该连续</strong>，即为形如$(i, i + 1, \cdots i + k)$的序列。所有的队员都应该属于且仅属于一支特别行动队。</p><p>编号为$i$的士兵的初始战斗力为$x_i$，一支特别行动队的初始战斗力$X$为队内士兵初始战斗力之和，即$X = x_i + x_{i+1} + \cdots + x_{i+k}$。</p><p>通过长期的观察，你总结出对于一支初始战斗力为$X$的特别行动队，其修正战斗力$X’= aX^2+bX+c$，其中$a,b,c$是已知的系数$(a &lt; 0)$。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3628" target="_blank" rel="noopener">[APIO2010]特别行动队</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于<strong>同一支特别行动队中队员的编号应该连续</strong>，那么就比较好想了。</p><p>定义$dp[i]$表示前$i$名队员已经分属于各自的行动队，目前所有行动队的修正战斗力之和的最大值。</p><p>于是可以从$[0,i)$队员中枚举$j$，使得第$j+1$名队员到第$i$名队员属于一个行动队。</p><p>那么</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c\},c\in[0,i)</script><p>其中$sum$为$x$的前缀和。初始化$dp[0]=0$，其余均为一个极小的负值。</p><p>于是可以得到一个$O(n^2)$的算法，TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a,b,c,x[N],sum[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll X=(sum[i]-sum[j]);</span><br><span class="line">dp[i]=max(dp[i],dp[j]+a*X*X+b*X+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$max$内的式子单独提出来看看</p><p>$dp[j]+a(sum[i]-sum[j])^2+b(sum[i]-sum[j])+c$</p><p>$=dp[j]+a(sum[i]^2-2sum[i]sum[j]+sum[j]^2)+b(sum[i]-sum[j])+c$</p><p>$=dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]+a\times sum[i]^2+b\times sum[i]+c$</p><p>剔除掉求状态$i$时的常量项，则为</p><p>$dp[j]+a\times sum[j]^2-b\times sum[j]-2a\times sum[i]sum[j]$</p><p>定义$f[i]=a\times sum[i]^2-b\times sum[i]$，则原式可化为</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j]$</p><p>则</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]+f[j]-2a\times sum[i]sum[j]\}+a\times sum[i]^2+b\times sum[i]+c</script><p>将$max$内提出来</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j]$，发现$sum[j]$这一项，其系数为常量。</p><p>于是该式子可以看做一斜率为$2a\times sum[i]$的过点$(sum[j],dp[j]+f[j])$的直线与$y$轴的截距，于是定义决策点$i(sum[i],dp[i]+f[i])$。</p><p>那么问题就转化为求一个最大的截距，于是需要维护一个上凸壳。</p><p>明显$sum$具有单调性。</p><p>于是令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]+f[j]-2a\times sum[i]sum[j] \ge dp[k]+f[k]-2a\times sum[i]sum[k] $</p><p>$dp[j]+f[j]-(dp[k]+f[k]) \ge 2a\times sum[i]\times (sum[j]-sum[k])$</p><p>因为$j&gt;k$且$sum$单调递增，则</p><p>$\frac{dp[j]+f[j]-(dp[k]+f[k])}{sum[j]-sum[k]}\ge 2a\times sum[i]$ 式①</p><p>而若要维护上凸壳，则其具有上凸性，即满足$j_1&lt;j_2&lt;j_3$，则决策点$j_1$与$j_2$之间连线段的斜率大于决策点$j_2$与$j_3$之间的斜率，即</p><p>$\frac{dp[j_2]+f[j_2]-(dp[j_1]+f[j_2])}{sum[j_2]-sum[j_1]}&gt;\frac{dp[j_3]+f[j_3]-(dp[j_2]+f[j_2])}{sum[j_3]-sum[j_2]}$ 式②</p><p>于是用单调队列维护上凸壳，用式①保持队头为最优决策点，用式②维护上凸壳即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll a,b,c,x[N],sum[N],dp[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">f[i]=a*sum[i]*sum[i]-b*sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]]+f[q[head+<span class="number">1</span>]]-dp[q[head]]-f[q[head]]&gt;=<span class="number">2</span>*a*sum[i]*(sum[q[head+<span class="number">1</span>]]-sum[q[head]])) head++;</span><br><span class="line">dp[i]=dp[q[head]]+f[q[head]]<span class="number">-2</span>*a*sum[i]*sum[q[head]]+a*sum[i]*sum[i]+b*sum[i]+c;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]+f[q[tail]]-dp[q[tail<span class="number">-1</span>]]-f[q[tail<span class="number">-1</span>]])*(sum[i]-sum[q[tail]])&lt;=(dp[i]+f[i]-dp[q[tail]]-f[q[tail]])*(sum[q[tail]]-sum[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APIO </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2007] 仓库建设</title>
      <link href="/is-zxy.github.io/2020/02/08/%5BZJOI2007%5D-%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/"/>
      <url>/is-zxy.github.io/2020/02/08/%5BZJOI2007%5D-%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<p>L 公司有$n$个工厂，由高到低分布在一座山上，工厂$1$在山顶，工厂$n$在山脚。</p><p>由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L 公司的总裁 L 先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是 L 先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。</p><p>由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 i<em>i</em> 个工厂目前已有成品$p_i$件，在第$i$个工厂位置建立仓库的费用是$c_i$。</p><p>对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 L 公司产品的对外销售处设置在山脚的工厂$n$，故产品只能往山下运（即<strong>只能运往编号更大的工厂的仓库</strong>），当然运送产品也是需要费用的，一件产品运送一个单位距离的费用是$1$。</p><p>假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p><ul><li>工厂$i$距离工厂$1$的距离$x_i$（其中$x_1=0$）。</li><li>工厂$i$目前已有成品数量$p_i$。</li><li>在工厂$i$建立仓库的费用$c_i$。</li></ul><p>请你帮助 L 公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 20\%$的数据，保证$ n \leq 500$。</p><p>对于$ 40\%$的数据，保证$ n \leq 10^4$。</p><p>对于$ 100\%$的数据，保证$ 1 \leq n \leq 10^6$，$0 \leq x_i,~p_i,~c_i &lt; 2^{31}$。</p><p>对于任意的$ 1 \leq i &lt; n$，保证$ x_i &lt; x_{i + 1}$。</p><p>设答案为$ans$，保证$ ans + \sum\limits_{i = 1}^{n} p_ix_i &lt; 2^{63}$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2120" target="_blank" rel="noopener">[ZJOI2007]仓库建设</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示在工厂$i$建立仓库，并且前$i$个工厂的成品均被送往仓库的最小费用值。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+\sum_{k=j+1}^{i-1}[(x[i]-x[k])\times p[k]]\},j\in[0,i)</script><p>于是便可以得到一个$O(n^3)$的及其暴力的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll x[N],p[N],c[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ll t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;i;k++) t+=(x[i]-x[k])*p[k];</span><br><span class="line">dp[i]=min(dp[i],dp[j]+t+c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将$min$内的式子单独拿出来看看</p><p>$dp[j]+c[i]+\sum_{k=j+1}^{i-1}[(x[i]-x[k])\times p[k]]$</p><p>$=dp[j]+c[i]+\sum_{k=j+1}^{i-1}(x[i]\times p[k])-\sum_{k=j+1}^{i-1}(x[k]\times p[k])$</p><p>$=dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}(x[k]\times p[k])$</p><p>定义$f[i]=x[i]\times p[i]$，则原式又可化为</p><p>$dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}f[k]$</p><p>于是状转方程便变为</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+x[i]\times \sum_{k=j+1}^{i-1}p[k]-\sum_{k=j+1}^{i-1}f[k]\},j\in[0,i)</script><p>即</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+c[i]+x[i]\times(sump[i-1]-sump[j])-(sumf[i-1]-sumf[j])\},j\in[0,i)</script><p>其中$sump$表示$p$的前缀和，$sumf$表示$f$的前缀和。</p><p>则又可以得到一个$O(n^2)$的稍微优化一点的算法，当然，还是TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll x[N],p[N],c[N],dp[N],sump[N],sumf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">sump[i]=sump[i<span class="number">-1</span>]+p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+c[i]+x[i]*(sump[i<span class="number">-1</span>]-sump[j])-(sumf[i<span class="number">-1</span>]-sumf[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将$min$内的式子提出来看看</p><p>$dp[j]+c[i]+x[i]\times(sump[i-1]-sump[j])-(sumf[i-1]-sumf[j])$</p><p>$=dp[j]-x[i]\times sump[j]+sumf[j]+c[i]+x[i]\times sump[i-1]-sumf[i-1]$</p><p>令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]-x[i]\times sump[j]+sumf[j]\le dp[k]-x[i]\times sump[k]+sumf[k]$</p><p>令$ds[i]=dp[i]+sumf[i]$，则又可化为</p><p>$ds[j]-x[i]\times sump[j]\le ds[k]-x[i]\times sump[k]$</p><p>$x[i]\times (sump[k]-sump[j])\le ds[k]-ds[j]$</p><p>而$sump$一定是不下降的，且$k&lt;j$，则（此处排除$sump[k]-sump[j]$的情况，因为实际操作时可用乘法。）</p><p>$x[i]\ge \frac{ds[k]-ds[j]}{sump[k]-sump[j]}$</p><p>定义决策点$q$点坐标为$(sump[q],ds[q])$且斜率有斜率为$x[i]$的直线过$q$点，则该直线与$y$轴交点即为$ds[q]-sump[q]\times x[i]$，即为$min$内的非常量项。</p><p>则可看成量决策点$k(sump[k],ds[k])$，$j(sump[j],ds[j])$，若两点的连线段的斜率小于等于$x[i]$，则转移决策$j$比转移决策$k$更优。</p><p>因为求的是$min$，则为斜率为$x[i]$的过决策点直线在$y$轴的最小截距。则要维护一个下凸壳，由于$sump$与$x$具有单调性，则用单调队列维护下凸性，若队头并非最优决策点则弹出，最后用队头作为被转移的决策点即可。</p><p>那么现在剩余的问题只剩下凸壳的维护。因为具有下凸性，所以对于$j_1&lt;j_2&lt;j_3$，决策点$j_1$与$j_2$之间连线段的斜率要小于决策点$j_2$与$j_3$之间连线段的斜率，即</p><script type="math/tex; mode=display">\frac{ds[j_2]-ds[j_1]}{sump[j_2]-sump[j_1]}<\frac{ds[j_3]-ds[j_2]}{sump[j_3]-sump[j_2]}</script><p>则据此维护凸壳即可。</p><p>状转方程</p><script type="math/tex; mode=display">dp[i]=min\{ds[j]-x[i]\times sump[j]\}+c[i]+x[i]\times sump[i-1]-sumf[i-1]</script><p>每个决策点入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll x[N],p[N],c[N],dp[N],sump[N],sumf[N],ds[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">sump[i]=sump[i<span class="number">-1</span>]+p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;x[i]*(sump[q[head]]-sump[q[head+<span class="number">1</span>]])&lt;=ds[q[head]]-ds[q[head+<span class="number">1</span>]]) head++;</span><br><span class="line">dp[i]=ds[q[head]]-x[i]*sump[q[head]]+c[i]+x[i]*sump[i<span class="number">-1</span>]-sumf[i<span class="number">-1</span>];</span><br><span class="line">ds[i]=dp[i]+sumf[i];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(ds[q[tail]]-ds[q[tail<span class="number">-1</span>]])*(sump[i]-sump[q[tail]])&gt;=(ds[i]-ds[q[tail]])*(sump[q[tail]]-sump[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> ZJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HNOI2008] 玩具装箱TOY</title>
      <link href="/is-zxy.github.io/2020/02/07/%5BHNOI2008%5D-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/"/>
      <url>/is-zxy.github.io/2020/02/07/%5BHNOI2008%5D-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY/</url>
      
        <content type="html"><![CDATA[<p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为$1 \cdots n$的$n$件玩具，第$i$件玩具经过压缩后的一维长度为$C_i$。</p><p>为了方便整理，P教授要求：</p><ul><li>在一个一维容器中的玩具编号是连续的。</li><li>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为$x=j-i+\sum\limits_{k=i}^{j}C_k$。</li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$x$，其制作费用为$(x-L)^2$。其中$L$是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望所有容器的总费用最小。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">[HNOI2008]玩具装箱TOY</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示压缩完前$i$个玩具的最小费用。</p><p>易得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+[i-(j+1)+sum[i]-sum[j]-L]^2\},j\in[0,i)</script><p>于是可以得到一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll c[N],sum[N],L,dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+(i-j<span class="number">-1</span>+sum[i]-sum[j]-L)*(i-j<span class="number">-1</span>+sum[i]-sum[j]-L));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>铁定TLE。</p><p>将这个式子单独提出来看看</p><script type="math/tex; mode=display">dp[j]+[i-(j+1)+sum[i]-sum[j]-L]^2</script><p>发现，其实再此过程中我们还可以维护的是$sum[i]+i$，遍定义$f[i]=sum[i]+i$，于是此式又可化为</p><script type="math/tex; mode=display">dp[j]+[f[i]-f[j]-1-L]^2</script><p>瞬间清爽不少。</p><p>考虑决策更优性，令$k&lt;j&lt;i$，若转移决策$j$比转移决策$k$更优的话，则</p><p>$dp[j]+[f[i]-f[j]-1-L]^2\le dp[k]+[f[i]-f[k]-1-L]^2$</p><p>$dp[j]+f[i]^2-2(f[j]+1+L)f[i]+(f[j]+1+L)^2\le dp[k]+f[i]^2-2(f[k]+1+L)f[i]+(f[k]+1+L)^2$</p><p>$dp[j]-2(f[j]+1+L)f[i]+(f[j]+1+L)^2\le dp[k]-2(f[k]+1+L)f[i]+(f[k]+1+L)^2$</p><p>$2(f[k]+1+L)f[i]-2(f[j]+1+L)f[i]\le dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]$</p><p>$2(f[k]-f[j])f[i]\le dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]$</p><p>而$f$肯定是单调递增的，则</p><p>$2f[i]\ge \frac{dp[k]+(f[k]+1+L)^2-[dp[j]+(f[j]+1+L)^2]}{f[k]-f[j]}$</p><p>方便理解，再进一步化化，令$p[i]=(f[i]+1+L)^2$，则</p><p>$2f[i]\ge \frac{dp[k]+p[k]-(dp[j]+p[j])}{f[k]-f[j]}$</p><p>不等式右面的形式像什么？斜率的求法。</p><p>于是看成两个点，$k(f[k],dp[k]+p[k])$与$j(f[j],dp[j]+p[j])$，这两点的连线段斜率即为不等式右面。</p><p>则说明，相邻的两个决策点$j,k$，$k&lt;j$，若两点连线段的斜率小于$2f[i]$，则转移决策点$j$比转移决策点$k$更优。</p><p>每个决策点都有一个斜率为$2f[i]$的直线穿过，可得此直线与$y$轴交点即为$(0,dp[k]+p[k]-2f[i]p[k])$（以决策点$k$举例）。</p><p>而这个纵坐标就是$min$内的非常量项。</p><p>求的是最小的，则显然是下凸壳的顶点，这样与$y$轴交点才能尽可能小。</p><p>因此我们需要维护这个下凸壳。</p><p>令$j_1&lt;j_2&lt;j_3$，若要满足下凸性，则决策点$j_1$与$j_2$的连线段的斜率要小于决策点$j_2$与决策点$j_3$的斜率，即</p><p>$\frac{dp[j_2]+p[j_2]-(dp[j_1]+p[j_1])}{f[j_2]-f[j_1]}&lt;\frac{dp[j_3]+p[j_3]-(dp[j_2]+p[j_2])}{f[j_3]-f[j_2]}$</p><p>据此用单调队列维护凸壳即可。</p><p>每次再用$2f[i]\ge \frac{dp[k]+p[k]-(dp[j]+p[j])}{f[k]-f[j]}$不断弹出队头，直至队头为最优决策点，然后直接用队头进行转移即可。</p><p>每个决策点只会入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">ll c[N],sum[N],f[N],L,dp[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+c[i];</span><br><span class="line">f[i]=sum[i]+i;</span><br><span class="line">p[i]=(f[i]+<span class="number">1</span>+L)*(f[i]+<span class="number">1</span>+L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>,p[<span class="number">0</span>]=(<span class="number">1</span>+L)*(<span class="number">1</span>+L);</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;<span class="number">2</span>*f[i]*(f[q[head]]-f[q[head+<span class="number">1</span>]])&lt;=dp[q[head]]+p[q[head]]-dp[q[head+<span class="number">1</span>]]-p[q[head+<span class="number">1</span>]]) head++;</span><br><span class="line">dp[i]=dp[q[head]]+(f[i]-<span class="built_in">sqrt</span>(p[q[head]]))*(f[i]-<span class="built_in">sqrt</span>(p[q[head]]));</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]+p[q[tail]]-dp[q[tail<span class="number">-1</span>]]-p[q[tail<span class="number">-1</span>]])*(f[i]-f[q[tail]])&gt;=(dp[i]+p[i]-dp[q[tail]]-p[q[tail]])*(f[q[tail]]-f[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> HNOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2365] 任务安排/[SDOI2012] 任务安排</title>
      <link href="/is-zxy.github.io/2020/02/06/%5B%E6%B4%9B%E8%B0%B7P2365%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%20%5BSDOI2012%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/"/>
      <url>/is-zxy.github.io/2020/02/06/%5B%E6%B4%9B%E8%B0%B7P2365%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%20%5BSDOI2012%5D-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h2 id="洛谷P2365-任务安排"><a href="#洛谷P2365-任务安排" class="headerlink" title="[洛谷P2365] 任务安排"></a>[洛谷P2365] 任务安排</h2><p>$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。</p><p>从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。</p><p>每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。</p><p> 对于$100\%$的数据，$1\le n\le5000$，$0 \le s\le50$，$1\le t_i,f_i \le 100$。 </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2365" target="_blank" rel="noopener">P2365 任务安排</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][j]$表示前$i$个任务被分为$j$批的最小费用值。</p><p>定义$sumt[i]$表示$t$的前缀和，$sumf[i]$表示$f$的前缀和。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=min\{dp[k][j-1]+(sumt[i]+s\times j)(sumf[i]-sumf[k])\},k\in[0,i)</script><p>初始化$dp[0][0]=0$，其余均为一个极大值。</p><p>于是便可以照这个写出一个$O(n^3)$的TLE代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,t[N],f[N],sumt[N],sumf[N],dp[N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">ans=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) &#123;</span><br><span class="line">dp[i][j]=min(dp[i][j],dp[k][j<span class="number">-1</span>]+(sumt[i]+s*j)*(sumf[i]-sumf[k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=min(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察式子，发现$j$的作用仅是为了计算此前个过程中的启动时间和，但事实上，既然这个时间要乘上此后的所有$f$，不如提前加入其中。因为若分完前$j$个任务后，要等待$s$秒，则后续费用一定会加上$(sumf[n]-sumf[j])\times s$，于是可以提前加进去，这样dp数组可以省去一维，状转方程变为</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]+sumt[i]\times (sumf[i]-sumf[j])+s\times (sumf[n]-sumf[j])\},j\in[0,i)</script><p>这样又可以写出一个$O(n^2)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,t[N],f[N],sumt[N],sumf[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) dp[i]=min(dp[i],dp[j]+sumt[i]*(sumf[i]-sumf[j])+s*(sumf[n]-sumf[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再整理，可得</p><script type="math/tex; mode=display">dp[i]=min\{dp[j]-(sumt[i]+s)\times sumf[j]\}+sumt[i]\times sumf[i]+s\times sumf[n],j\in[0,i)</script><p>对于每一个$i$，$min$外都是常量。</p><p>观察$min$内的式子：$dp[j]-(sumt[i]+s)\times sumf[j]$，令$k=sumt[i]+s$，则原式变为$-k\times sumf[j]+dp[j]$。</p><p>这个形式像什么？一次函数。</p><p>将其看做一条斜率为$k$，且过点$(sumf[j],dp[j])$的直线。</p><p>那么其与$y$轴交点即为$(0,dp[j]-k\times sumf[j])$</p><p>这是什么？这就是$min$内的东西。则问题就转化为找最小的截距。</p><p>则对于每个$sumf[j],dp[j],j\in[0,i)$过点$(sumf[j],dp[j])$的直线，最小的截距明显就是下凸壳的顶点。</p><p>令$k&lt;j&lt;i$，如果转移$j$比转移$k$要更优的话，则</p><p>$dp[j]-(sumt[i]+s)\times sumf[j]&lt;dp[k]-(sumt[i]+s)\times sumf[k]$</p><p>$dp[j]-dp[k]&lt;(sumt[i]+s)(sumf[j]-sumf[k])$</p><p>$∵j&gt;k$</p><p>$∴sumf[j]-sumf[k]&gt;0$</p><p>$∴\frac{dp[j]-dp[k]}{sumf[j]-sumf[k]}&lt;sumt[i]+s$</p><p>则相邻两点$j,k,k&lt;j$，若$j$与$k$的连线段的斜率小于$sumt[i]+s$的话，那么$k$不需要了。</p><p>令$j_1&lt;j_2&lt;j_3$，若$j_2$有可能成为最优决策，则其满足下凸性，$j_1$与$j_2$连成线段的斜率要小于$j_2$与$j_3$连成线段的斜率。</p><p>即$\frac{dp[j_2]-dp[j_1]}{sumf[j_2]-sumf[j_1]}&lt;\frac{dp[j_3]-dp[j_2]}{sumf[j_3]-sumf[j_2]}$。</p><p>便可以以此建立单调队列，维护这个下凸壳。</p><p>队头与队头后一个的连线段的斜率小于$sumt[i]+s$的话则直接弹出，因为$sumt[i]+s$具有单调性。队尾在加入$i$后不符合下凸性则弹出队尾，然后将$i$加入队尾。每次状态转移直接用队头即可。</p><p>每个元素只入队一次，时间复杂度$O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,f[N],t[N],sumf[N],sumt[N],dp[N],q[N],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;dp[q[head+<span class="number">1</span>]]-dp[q[head]]&lt;=(sumt[i]+s)*(sumf[q[head+<span class="number">1</span>]]-sumf[q[head]])) head++;</span><br><span class="line">dp[i]=dp[q[head]]-(sumt[i]+s)*sumf[q[head]]+sumt[i]*sumf[i]+s*sumf[n];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]-dp[q[tail<span class="number">-1</span>]])*(sumf[i]-sumf[q[tail]])&gt;=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDOI2012-任务安排"><a href="#SDOI2012-任务安排" class="headerlink" title="[SDOI2012] 任务安排"></a>[SDOI2012] 任务安排</h2><p>$n$个任务排成一个序列在一台机器上等待完成（顺序不得改变），这$n$个任务被分成若干批，每批包含相邻的若干任务。</p><p>从零时刻开始，这些任务被分批加工，第$i$个任务单独完成所需的时间为$t_i$。在每批任务开始前，机器需要启动时间$s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。</p><p>每个任务的费用是它的完成时刻乘以一个费用系数$f_i$。请确定一个分组方案，使得总费用最小。</p><p> 对于$100\%$的数据，$1\le n\le3\times 10^5$，$0 \le s\le2^8$，$|t_i|\le 2^8$，$0\le f_i\le2^8$。</p><!--more--><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5785" target="_blank" rel="noopener">[SDOI2012]任务安排</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题与之前的那道任务安排不同在于数据量增大了，且$t$的值可能为负的。</p><p>因此上面的$O(n^3)$与$O(n^2)$的方法都过不了。</p><p>斜率优化？</p><p>而因为$t$值可能为负，所以$sumt[i]+s$不再具有单调性，那么上面的保存相邻两点连线段斜率大于$sumt[i]+s$的方法便不再适用。</p><p>因此不能弹出队头，而是要维护整个凸壳。所维护的凸壳具有下凸性，因此最优的决策点一定是左侧的线段斜率小于$sumt[i]+s$，右侧的线段斜率大于$sumt[i]+s$，所以便可以用二分查找，来寻找这个最优的决策点。</p><p>队尾的操作维护下凸性与上题相同，保持不变即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,s,head=<span class="number">1</span>,tail=<span class="number">1</span>,q[N];</span><br><span class="line">ll f[N],t[N],sumf[N],sumt[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==tail) <span class="keyword">return</span> q[head];</span><br><span class="line"><span class="keyword">int</span> l=head,r=tail;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[q[mid+<span class="number">1</span>]]-dp[q[mid]]&lt;=(sumt[i]+s)*(sumf[q[mid+<span class="number">1</span>]]-sumf[q[mid]])) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> q[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;f[i];</span><br><span class="line">sumf[i]=sumf[i<span class="number">-1</span>]+f[i];</span><br><span class="line">sumt[i]=sumt[i<span class="number">-1</span>]+t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">q[head]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p=binary_search(i);</span><br><span class="line">dp[i]=dp[p]-(sumt[i]+s)*sumf[p]+sumt[i]*sumf[i]+s*sumf[n];</span><br><span class="line"><span class="keyword">while</span>(head&lt;tail&amp;&amp;(dp[q[tail]]-dp[q[tail<span class="number">-1</span>]])*(sumf[i]-sumf[q[tail]])&gt;=(dp[i]-dp[q[tail]])*(sumf[q[tail]]-sumf[q[tail<span class="number">-1</span>]])) tail--;</span><br><span class="line">q[++tail]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POI2014] PTA-Little Bird</title>
      <link href="/is-zxy.github.io/2020/02/06/%5BPOI2014%5D-PTA-Little-Bird/"/>
      <url>/is-zxy.github.io/2020/02/06/%5BPOI2014%5D-PTA-Little-Bird/</url>
      
        <content type="html"><![CDATA[<p>有$n$棵树，每棵树都有其高度。</p><p>有$q$只鸟，每只鸟从第一棵树开始跳，跳到比其矮的树不耗费体力，反之则耗费$1$点体力。</p><p>每只鸟$i$都有其最多能跳跃的树的棵树$k_i$，即鸟$i$在树$j$上时可以跳到第$[i+1,i+k_i]$中任意一棵树上。</p><p>求每只鸟耗费的最少体力。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(2\le n\le 1\ 000\ 000)$ </p><p>$(1\le d_i\le 10^9)$</p><p>$(1\le q\le 25)$</p><p>$ (1\le k_i\le n-1)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3572" target="_blank" rel="noopener">[POI2014]PTA-Little Bird</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i]$表示到第$i$棵树上的最少体力。</p><p>明显</p><script type="math/tex; mode=display">dp[i]=min\{a[i]<a[j]?dp[j]:dp[j]+1\},j\in[max(1,i-k),i-1]</script><p>直接写$O(nqk)$是超时的（此处$k=\sum_{i=1}^qk_i$)。</p><p>但是明显能单调队列优化。</p><p>当一棵树$i$与另一棵树$j$，$i&gt;j$，$a[i]&gt;a[j]$且$dp[i]=dp[j]$，那么第$i$棵树肯定是比第$j$棵树要优的。</p><p>于是维护一个单调递增的单调队列，每次状转用队头即可。</p><p>本题卡STL，数组模拟deque可以过。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],q,dp[N];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q) &#123;</span><br><span class="line">q--;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k); </span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">que.clear();</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!que.empty()&amp;&amp;((a[i<span class="number">-1</span>]&gt;=a[que.back()]&amp;&amp;dp[i<span class="number">-1</span>]==dp[que.back()])||dp[i<span class="number">-1</span>]&lt;dp[que.back()])) que.pop_back();</span><br><span class="line">que.push_back(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty()&amp;&amp;que.front()&lt;max(i-k,<span class="number">1</span>)||que.front()&gt;i<span class="number">-1</span>) que.pop_front();</span><br><span class="line">dp[i]=(a[que.front()]&gt;a[i])?dp[que.front()]:dp[que.front()]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POI </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P5858] 「SWTR-03」Golden Sword</title>
      <link href="/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P5858%5D-%E3%80%8CSWTR-03%E3%80%8DGolden-Sword/"/>
      <url>/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P5858%5D-%E3%80%8CSWTR-03%E3%80%8DGolden-Sword/</url>
      
        <content type="html"><![CDATA[<p>制造一把金宝剑需要$n$种原料，编号为$1$到$n$，编号为$i$的原料的坚固值为$a_i$。</p><p>炼金是很讲究放入原料的顺序的，因此小$E$必须按照$1$到$n$的顺序依次将这些原料放入炼金锅。</p><p>但是，炼金锅的容量非常有限，它最多只能容纳$w$个原料。</p><p>所幸的是，每放入一个原料之前，小$E$可以从中取出一些原料，数量不能超过$s$个。</p><ul><li>我们定义第$i$种原料的耐久度为：放入第$i$种原料时锅内的原料总数$\times a_i$，则宝剑的耐久度为<strong>所有原料</strong>的耐久度之和。</li></ul><p>小$E$当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。</p><p>注：这里的”放入第$i$种原料时锅内的原料总数“<strong>包括正在放入锅中的原料</strong>，详细信息请见样例。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5858" target="_blank" rel="noopener">P5858 「SWTR-03」Golden Sword</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][j]$表示放入第$i$中原料时<strong>锅内的原料总数</strong>有$j$种的最大耐久值。</p><p>易得</p><script type="math/tex; mode=display">dp[i][j]=max\{d[i-1][k]+a[i]\times j\},k\in[j-1,min(j+s-1,w)]</script><p>于是可得一个$O(nws)$的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,s;</span><br><span class="line">ll a[N],dp[N][N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">ans=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(i,w);j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&lt;=min(j+s<span class="number">-1</span>,w);k++) dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][k]+a[i]*j);</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=max(dp[i][j],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状转方程可以将$a[i]\times j$提出来，即</p><script type="math/tex; mode=display">dp[i][j]=max\{d[i-1][k]\}+a[i]\times j,k\in[j-1,min(j+s-1,w)]</script><p>于是便可以用单调队列优化了。</p><p>但细节较多，且$i=1$的情况需特判。</p><p>时间复杂度$O(nw)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w,s;</span><br><span class="line">ll a[N],dp[N][N],ans=LONG_LONG_MIN;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">q.clear();</span><br><span class="line"><span class="keyword">if</span>(i&gt;w) q.push_back(w);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=min(i,w);j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">1</span>&amp;&amp;!q.empty()&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;=dp[i<span class="number">-1</span>][q.back()]) q.pop_back();</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>) q.push_back(j<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;(q.front()&lt;j<span class="number">-1</span>||q.front()&gt;min(j+s<span class="number">-1</span>,w))) q.pop_front();</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][q.front()]+a[i]*j;</span><br><span class="line"><span class="keyword">if</span>(i==n) ans=max(ans,dp[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2627] 修剪草坪/[洛谷2034] 选择数字</title>
      <link href="/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P2627%5D-%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA-%5B%E6%B4%9B%E8%B0%B72034%5D-%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%97/"/>
      <url>/is-zxy.github.io/2020/02/05/%5B%E6%B4%9B%E8%B0%B7P2627%5D-%E4%BF%AE%E5%89%AA%E8%8D%89%E5%9D%AA-%5B%E6%B4%9B%E8%B0%B72034%5D-%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>给定一行$n$个非负整数$a[1]..a[n]$。现在你可以选择其中若干个数，但不能有超过$k$个连续的数字被选择。你的任务是使得选出的数字的和最大。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1 &lt;= N &lt;= 100,000) $</p><p>$ (0 &lt;= a_i &lt;= 1,000,000,000) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2627" target="_blank" rel="noopener">P2627 修剪草坪</a></p><p><a href="https://www.luogu.com.cn/problem/P2034" target="_blank" rel="noopener">P2034 选择数字</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[i][pos]$，当$pos$等于$0$时表示$a[i]$不选时前$i$个数的最大和，当$pos$等于$1$时表示$a[i]$选时前$i$个数的最大和。</p><p>对于第$i$个数，可以从$[i-k,i-1]$中枚举断点$j$，即$j$不选。</p><p>则易得</p><script type="math/tex; mode=display">dp[i][pos]=\left\{\begin{aligned}max(dp[i-1][0],dp[i-1][1])\ \  && pos=0 \\max\{dp[j]+sum[i]-sum[j]\} && pos=1 \\\end{aligned}\right.</script><p>而在过程中$sum[i]$为定值，所以可以提出来</p><script type="math/tex; mode=display">dp[i][pos]=\left\{\begin{aligned}max(dp[i-1][0],dp[i-1][1])\ \  && pos=0 \\max\{dp[j]-sum[j]\}-sum[i] && pos=1 \\\end{aligned}\right.</script><p>因此可以用维护一个递减的$dp[j]-sum[j]$单调队列，每次转移状态直接用队头减$sum[i]$即可。</p><p>当然，线段树也是可以的，但不是目前学习的重点，此处不再赘述。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">ll a[N],dp[N][<span class="number">2</span>],sum[N];</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(q.empty()) &#123;</span><br><span class="line">q.push_back(i<span class="number">-1</span>);</span><br><span class="line">dp[i][<span class="number">1</span>]=sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;q.front()&lt;i-k) q.pop_front();</span><br><span class="line">dp[i][<span class="number">1</span>]=dp[q.front()][<span class="number">0</span>]-sum[q.front()]+sum[i];</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;dp[i][<span class="number">0</span>]-sum[i]&gt;dp[q.back()][<span class="number">0</span>]-sum[q.back()]) q.pop_back();</span><br><span class="line">q.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max(dp[n][<span class="number">0</span>],dp[n][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2422] 良好的感觉</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P2422%5D-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%84%9F%E8%A7%89/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P2422%5D-%E8%89%AF%E5%A5%BD%E7%9A%84%E6%84%9F%E8%A7%89/</url>
      
        <content type="html"><![CDATA[<p>kkk做了一个人体感觉分析器。每一天，人都有一个感受值$A_i$，$A_i$越大，表示人感觉越舒适。在一段时间$[i, j]$内，人的舒适程度定义为$[i, j]$中最不舒服的那一天的感受值$*[i, j]$中每一天感受值的和。现在给出kkk在连续$N$天中的感受值，请问，在哪一段时间，kkk感觉最舒适？ </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1&lt;=N&lt;=100$</p><p>对于$70\%$的数据，$1&lt;=N&lt;=2000$</p><p>对于$100\%$的数据，$1&lt;=N&lt;=100000$，$1&lt;=感受值&lt;=1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2422" target="_blank" rel="noopener">P2422 良好的感觉</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>标签是单调队列，然而正规来讲应该是单调栈。</p><p>定义$f[i]$表示$a[i]$为最小感受值得最大舒适程度。</p><p>易得$f[i]=(sum[r_i]-sum[l_i])*a[i]$。</p><p>其中$r_i$表示$a[i]$右面第一个比$a[i]$小的数的下标，$l_i$同理。</p><p>并没有什么前置要求，因此是个单向操作，于是就不需要用双端队列（单调队列）了，单调栈即可。</p><p>维护一个单调递增的单调栈，栈顶为最小值，当入栈的数$i$比栈顶$j$小时，说明$i$就是$j$右面的第一个比$j$小的数，$j$左面的第一个比$j$小的数即为栈顶下面的数；若栈只有一层，则$j$为当前所有入过栈元素的最小值。维护答案，$j$弹出栈顶，$i$入栈。</p><p>当每个元素都操作后，需要再次检验栈是否为空，若不为空，则再次进行上述操作，直至栈为空。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[N],sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;a[i]&lt;a[s.top()]) &#123;</span><br><span class="line">ll p=a[s.top()],t;</span><br><span class="line">s.pop();</span><br><span class="line">t=s.empty()?<span class="number">0</span>:s.top();</span><br><span class="line">ans=max(ans,(sum[i<span class="number">-1</span>]-sum[t])*p);</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">ll p=a[s.top()],t;</span><br><span class="line">s.pop();</span><br><span class="line">t=s.empty()?<span class="number">0</span>:s.top();</span><br><span class="line">ans=max(ans,(sum[n]-sum[t])*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1725] 琪露诺</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1725%5D-%E7%90%AA%E9%9C%B2%E8%AF%BA/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1725%5D-%E7%90%AA%E9%9C%B2%E8%AF%BA/</url>
      
        <content type="html"><![CDATA[<p>给定一长度为 $n+1$的数列$A$, 第$1$项为$0$。<br>以第一项为起点 , 对于当前的位置$i$<br>可以转移到：$(i+l,i+r)$中任意一位置<br>并且获得当前位置上 数的价值 .</p><p>求 : 当位置$≥n+1$时可以取得的 最大价值和</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$60\%$的数据：$N &lt;= 10,000$</p><p>对于$100\%$的数据：$N &lt;= 200,000$</p><p>对于所有数据$-1,000 &lt;= A[i] &lt;= 1,000$且$1 &lt;= L &lt;= R &lt;= N$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1725" target="_blank" rel="noopener">P1725 琪露诺</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大概交了个二三十遍，彻底自闭。</p><p>定义$dp[i]$表示到达位置$i$所得到的的最大的价值，易得</p><script type="math/tex; mode=display">dp[i]=max\{dp[j]\}+a[i]</script><p>其中$j\in[i-l,i-j]$</p><p>所以$[1,l)$内的位置都是无法走到的，于是从$l$开始。</p><p>这个RMQ其实也可以用树状数组、线段树、ST表啥的来求。这里不再赘述。</p><p>明显，具有单调性，可用单调队列优化。于是从$l$开始每次将$i-l$入队，然后不符合要求的出队，过程中要保证队列不为空。然后直接用$dp[i]$加上队头和本处的价值，若此时队列为空则continue。</p><p>交了二三十遍的原因就在于刚开始时我先转移状态再入队$i-l$，而事实上$i-l$这个状态也是可能为队头的，因此不全面，导致错误。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,l,r,a[N],dp[N],ans=-INF;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;dp[i-l]&gt;=dp[q.back()]) q.pop_back();</span><br><span class="line">q.push_back(i-l);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;(q.front()&lt;i-r||q.front()&gt;i-l)) q.pop_front();</span><br><span class="line"><span class="keyword">if</span>(q.empty()) <span class="keyword">continue</span>;</span><br><span class="line">dp[i]=dp[q.front()]+a[i];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n-r+<span class="number">1</span>) ans=max(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1886] 滑动窗口/【模板】单调队列</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1886%5D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1886%5D-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p><p>例如：</p><p>The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。</p><p><a href="https://postimg.cc/bS1Dk494" target="_blank" rel="noopener"><img src="https://i.postimg.cc/sxNYdrQf/688.jpg" alt="688.jpg"></a></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 50\%$的数据，$1 \le n \le 10^5$；<br>对于$100\%$的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">P1886 滑动窗口 /【模板】单调队列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>单调队列板子。</p><p>不太好解释。理解就好。</p><p>队列一般储存两个值：数组下标和动规状态值。</p><p>本题明显具有单调性。</p><p>维护单调性即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(i-k+<span class="number">1</span>&gt;q[head].id&amp;&amp;head&lt;=tail) head++;</span><br><span class="line"><span class="keyword">while</span>(a[i]*p&lt;q[tail].v&amp;&amp;head&lt;=tail) tail--;</span><br><span class="line">q[++tail].v=a[i]*p;</span><br><span class="line">q[tail].id=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;q[head].v*p&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">work(<span class="number">1</span>);</span><br><span class="line">work(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1714] 切蛋糕</title>
      <link href="/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1714%5D-%E5%88%87%E8%9B%8B%E7%B3%95/"/>
      <url>/is-zxy.github.io/2020/02/04/%5B%E6%B4%9B%E8%B0%B7P1714%5D-%E5%88%87%E8%9B%8B%E7%B3%95/</url>
      
        <content type="html"><![CDATA[<p>给定一长$n$的序列，求其中长度不超过$m$的最大连续子序列和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对$20\%$的数据，$N≤100$。</p><p>对$100\%$的数据，$N≤500000$，$|Pi|≤500$。 答案保证在$2^{31}-1$之内。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1714" target="_blank" rel="noopener">P1714 切蛋糕</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前缀和+单调队列，$O(n)$。</p><p>求的是最大连续子序列和，因此维护单调递增的单调队列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> n,m,s[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>,ans=~INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(q[head].id&lt;i-m&amp;&amp;head&lt;=tail) head++;</span><br><span class="line">ans=max(ans,s[i]-q[head].v);</span><br><span class="line"><span class="keyword">while</span>(s[i]&lt;q[tail].v&amp;&amp;head&lt;=tail) tail--;</span><br><span class="line">q[++tail].v=s[i];</span><br><span class="line">q[tail].id=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P5788] 【模板】单调栈</title>
      <link href="/is-zxy.github.io/2020/02/03/%5B%E6%B4%9B%E8%B0%B7P5788%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/is-zxy.github.io/2020/02/03/%5B%E6%B4%9B%E8%B0%B7P5788%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>给出项数为$n$的整数数列$a_{1 \dots n}$。</p><p>定义函数$f(i)$代表数列中第$i$个元素之后第一个大于$a_i$ 的元素的<strong>下标</strong>。若不存在，则$f(i)=0$。</p><p>试求出$f(1\dots n)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据，$n\leq 100$；</p><p>对于$ 60\%$的数据，$n\leq 5 \times 10^3$；</p><p>对于$ 100\%$的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">P5788 【模板】单调栈</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>单调栈板子。</p><p>维护一个单调递减的单调栈。</p><p>依次入栈，若比栈顶大，弹出栈顶，栈顶的$f$值即为当前入栈的下标。</p><p>入完栈后，最终栈内剩下的$f$值均为$0$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N],f[N];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;a[s.top()]&lt;a[i]) &#123;</span><br><span class="line">f[s.top()]=i;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">f[s.top()]=<span class="number">0</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,f[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ZJOI2007] 时态同步</title>
      <link href="/is-zxy.github.io/2020/02/03/%5BZJOI2007%5D-%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
      <url>/is-zxy.github.io/2020/02/03/%5BZJOI2007%5D-%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字$1,2,3$进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。</p><p>在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。</p><p>激励电流在导线上的传播是需要花费时间的，对于每条边$e$，激励电流通过它需要的时间为$t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小Q​有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用多少次道具才可使得所有的“终止节点”时态同步？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$40\%$的数据，$N ≤ 1000$</p><p>对于$100\%$的数据，$N ≤ 500000$</p><p>对于所有的数据，$t_e ≤ 1000000$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1131" target="_blank" rel="noopener">[ZJOI2007]时态同步</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不算难的一题。</p><p>定义$dp[root]$表示以$root$为根的子树的道具最少使用次数。</p><p>显然要用道具补到与最长链相同。</p><p>于是</p><script type="math/tex; mode=display">dp[root]=\sum_{j\in son_{root}}dp[j]+cnt*maxn[root]-sum</script><p>其中$maxn[i]$表示以$i$为根的子树从根到叶的最大距离。</p><p>$sum=\sum_{j\in son_{root}}(maxn[j]+edge[j])$</p><p>$cnt$表示$root$的儿子个数。</p><p>过程中维护好$maxn[root]$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,s,head[N&lt;&lt;<span class="number">1</span>],tot=<span class="number">0</span>;</span><br><span class="line">ll dp[N],maxn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">ll cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to==fa) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line">dfs(edge[i].to,root);</span><br><span class="line">dp[root]+=dp[edge[i].to];</span><br><span class="line">maxn[root]=max(maxn[edge[i].to]+edge[i].w,maxn[root]);</span><br><span class="line">sum+=maxn[edge[i].to]+edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line">dp[root]+=cnt*maxn[root]-sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;t;</span><br><span class="line">add(a,b,t);</span><br><span class="line">add(b,a,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(s,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[s]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> ZJOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO07JAN] 平衡的阵容Balanced Lineup</title>
      <link href="/is-zxy.github.io/2020/02/02/%5BUSACO07JAN%5D-%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%98%B5%E5%AE%B9Balanced-Lineup/"/>
      <url>/is-zxy.github.io/2020/02/02/%5BUSACO07JAN%5D-%E5%B9%B3%E8%A1%A1%E7%9A%84%E9%98%B5%E5%AE%B9Balanced-Lineup/</url>
      
        <content type="html"><![CDATA[<p>每天,农夫 John的$N$$(1 &lt;= N &lt;= 50,000)$头牛总是按同一序列排队. 有一天, John 决定让一些牛们玩一场飞盘比赛. 他准备找一群在对列中为置连续的牛来进行比赛. 但是为了避免水平悬殊,牛的身高不应该相差太大. John 准备了$Q (1 &lt;= Q &lt;= 200,000)$ 个可能的牛的选择和所有牛的身高 $(1 &lt;= 身高 &lt;= 1,000,000)$. 他想知道每一组里面最高和最低的牛的身高差别. </p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2880" target="_blank" rel="noopener">[USACO07JAN]平衡的阵容Balanced Lineup</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显的RMQ问题。</p><p>ST表、线段树、树状数组不解释。</p><h3 id="代码（ST表）"><a href="#代码（ST表）" class="headerlink" title="代码（ST表）"></a>代码（ST表）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,h[MAXN],lg[MAXN],fi[MAXN][N],fa[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) &#123;</span><br><span class="line">fi[i][j]=min(fi[i][j<span class="number">-1</span>],fi[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">fa[i][j]=max(fa[i][j<span class="number">-1</span>],fa[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p=lg[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(fa[l][p],fa[r-(<span class="number">1</span>&lt;&lt;p)+<span class="number">1</span>][p])-min(fi[l][p],fi[r-(<span class="number">1</span>&lt;&lt;p)+<span class="number">1</span>][p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(fi,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(fi));</span><br><span class="line"><span class="built_in">memset</span>(fa,<span class="number">0</span>,<span class="keyword">sizeof</span>(fa));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">fi[i][<span class="number">0</span>]=fa[i][<span class="number">0</span>]=h[i];</span><br><span class="line">lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（线段树）"><a href="#代码（线段树）" class="headerlink" title="代码（线段树）"></a>代码（线段树）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segtree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,minn,maxn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minn(x) tree[x].minn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn(x) tree[x].maxn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;minn(p);</span><br><span class="line">maxn(p)=minn(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">minn(p)=min(minn(ls),minn(rs));</span><br><span class="line">maxn(p)=max(maxn(ls),maxn(rs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxn_ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> maxn(p);</span><br><span class="line"><span class="keyword">return</span> max(maxn_ask(ls,l,r),maxn_ask(rs,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minn_ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> minn(p);</span><br><span class="line"><span class="keyword">return</span> min(minn_ask(ls,l,r),minn_ask(rs,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn_ask(<span class="number">1</span>,l,r)-minn_ask(<span class="number">1</span>,l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码（树状数组）"><a href="#代码（树状数组）" class="headerlink" title="代码（树状数组）"></a>代码（树状数组）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,h[N],ci[N],ca[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> h[l];</span><br><span class="line"><span class="keyword">if</span>(r-lowbit(r)+<span class="number">1</span>&gt;l) <span class="keyword">return</span> min(ci[r],ask_min(l,r-lowbit(r)));</span><br><span class="line"><span class="keyword">return</span> min(h[r],ask_min(l,r<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_max</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> h[l];</span><br><span class="line"><span class="keyword">if</span>(r-lowbit(r)+<span class="number">1</span>&gt;l) <span class="keyword">return</span> max(ca[r],ask_max(l,r-lowbit(r)));</span><br><span class="line"><span class="keyword">return</span> max(h[r],ask_max(l,r<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">ca[i]=ci[i]=h[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;lowbit(i);j++) &#123;</span><br><span class="line">ci[i]=min(ci[i],ci[i-j]);</span><br><span class="line">ca[i]=max(ca[i],ca[i-j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask_max(l,r)-ask_min(l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> RMQ </tag>
            
            <tag> ST表 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3694] 邦邦的大合唱站队</title>
      <link href="/is-zxy.github.io/2020/02/02/%5B%E6%B4%9B%E8%B0%B7P3694%5D-%E9%82%A6%E9%82%A6%E7%9A%84%E5%A4%A7%E5%90%88%E5%94%B1%E7%AB%99%E9%98%9F/"/>
      <url>/is-zxy.github.io/2020/02/02/%5B%E6%B4%9B%E8%B0%B7P3694%5D-%E9%82%A6%E9%82%A6%E7%9A%84%E5%A4%A7%E5%90%88%E5%94%B1%E7%AB%99%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>$N$个偶像排成一列，他们来自$M$个不同的乐队。每个团队至少有一个偶像。</p><p>现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。</p><p>请问最少让多少偶像出列？</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$N\le 20, M=2$</p><p>对于$40\%$的数据，$N\le 100, M\le 4$</p><p>对于$70\%$的数据，$N\le 2000, M\le 10$</p><p>对于全部数据，$1\le N\le 10^5, M\le 20$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3694" target="_blank" rel="noopener">P3694 邦邦的大合唱站队</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$m$较小，考虑状压。</p><p>用二进制数表示状态，若第$i$位为$1$则表示第$i$个团队在队列中（从$0$开始）。</p><p>定义$dp[i]$表示状态$i$下最少让偶像出列的个数。</p><p>定义$sum[i][j]$表示原队伍中前$i$个人中属于$j$团队的人的个数。</p><p>定义$num[i]$表示$i$团队的总人数。</p><p>可得</p><script type="math/tex; mode=display">dp[i]=min\{dp[i\ xor2^j]+num[j]-(sum[l][j]-sum[l-num[j]][j])\}</script><p>其中$l$表示该状态下的总人数，即$l=\displaystyle\sum_{2^j\&amp;i==1}num[j]$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;m)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,id[MAXN],sum[MAXN][N],num[N],dp[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id[i];</span><br><span class="line">id[i]--;</span><br><span class="line">num[id[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) sum[i][j]+=(id[i]==j)?<span class="number">1</span>+sum[i<span class="number">-1</span>][j]:sum[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) l+=((<span class="number">1</span>&lt;&lt;j)&amp;i)?num[j]:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i) &#123;</span><br><span class="line">dp[i]=min(dp[i],dp[i^(<span class="number">1</span>&lt;&lt;j)]+num[j]-(sum[l][j]-sum[l-num[j]][j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[tot<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO08NOV] 奶牛混合起来Mixed Up Cows</title>
      <link href="/is-zxy.github.io/2020/02/01/%5BUSACO08NOV%5D-%E5%A5%B6%E7%89%9B%E6%B7%B7%E5%90%88%E8%B5%B7%E6%9D%A5Mixed-Up-Cows/"/>
      <url>/is-zxy.github.io/2020/02/01/%5BUSACO08NOV%5D-%E5%A5%B6%E7%89%9B%E6%B7%B7%E5%90%88%E8%B5%B7%E6%9D%A5Mixed-Up-Cows/</url>
      
        <content type="html"><![CDATA[<p>约翰家有$N$头奶牛，第i头奶牛的编号是$S_i$，每头奶牛的编号都是唯一的。这些奶牛最近在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队伍中，相邻奶牛的编号之差均超过$K$。比如当$K=1$时，$1,3,5,2,6,4$就是一支混乱的队伍， 而$1,3,6,5,2,4$不是，因为$6$和$5$只差$1$。请数一数，有多少种队形是混乱的呢？ </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (4 &lt;= N &lt;= 16) $</p><p>$(1 &lt;= K &lt;= 3400) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2915" target="_blank" rel="noopener">[USACO08NOV]奶牛混合起来Mixed Up Cows</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$n$较小，考虑状压。</p><p>有些像Travelling那题。</p><p>令二进制数中，第$i$位为$1$表示第$i$只奶牛在队伍中，反之则不在。</p><p>定义$dp[i][j]$表示在状态$i$下，队尾为第$j$只奶牛的队伍数。</p><p>易得（$check(j)$表示$2^j$对于$i$是一个合法状态。）</p><script type="math/tex; mode=display">dp[i+2^l][l]=\sum_{check(j)\&\&i\&2^j==1}dp[i][j]</script><p>最终答案即为$\sum_{i=0}^{n-1}dp[2^n-1][i]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,id[N],bits[N];</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;N][N],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;id[i];</span><br><span class="line"></span><br><span class="line">bits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i) bits[i]=bits[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(bits[j]&amp;i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>((bits[l]&amp;i)||<span class="built_in">abs</span>(id[j]-id[l])&lt;=k) <span class="keyword">continue</span>;</span><br><span class="line">dp[i+bits[l]][l]+=dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans+=dp[tot<span class="number">-1</span>][i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通] 皇宫看守</title>
      <link href="/is-zxy.github.io/2020/02/01/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E7%9A%87%E5%AE%AB%E7%9C%8B%E5%AE%88/"/>
      <url>/is-zxy.github.io/2020/02/01/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E7%9A%87%E5%AE%AB%E7%9C%8B%E5%AE%88/</url>
      
        <content type="html"><![CDATA[<p>太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。</p><p>皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状，某些宫殿间可以互相望见。大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。</p><p>可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。</p><p>帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。 </p><p><a href="https://postimg.cc/r0XqxsZF" target="_blank" rel="noopener"><img src="https://i.postimg.cc/k4DDrtx8/aaaabba2.png" alt="aaaabba2.png"></a></p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$0&lt;n\le1500$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/10157" target="_blank" rel="noopener">「一本通 5.2 例 5」皇宫看守</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与战略游戏和没有上司的舞会差不多。刚看这题时交了个战略游戏代码上去，当然错了233。</p><p>战略游戏是看路，而本题是看点。</p><p>路，可被连接的两点给看到。</p><p>而点，则有三种状态，一是被它父节点给看到，二是被自己看到，三是被子节点看到。</p><p>于是定义$dp[root][p]$表示以$root$为根的状态，其中</p><p>$dp[root][0]$表示$root$被其父节点看到的最小花费。</p><p>$dp[root][1]$表示$root$处就有看守的最小花费。</p><p>$dp[root][2]$表示$root$被其子节点看到的最小花费。</p><p>于是</p><script type="math/tex; mode=display">dp[root][0]=\sum_{v\in son_{root}}min(dp[v][1],dp[v][2])  \\dp[root][1]=\sum_{v\in son_{root}}min\{dp[v][0],dp[v][1],dp[v][2]\}+cost[root] \\dp[root][2]=\sum_{v\in son_{root}}min(dp[v][1],dp[v][2])+d</script><p>其中$d=\min_{v\in son_{root}}(dp[v][1]-min(dp[v][1],dp[v][2]))$ 。</p><p>这个$d$的用途很大。因为对于$dp[root][2]$，必须要选取一个子节点上放看守，否则状态$dp[root][2]$就不成立了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,cost[N],root=<span class="number">0</span>,dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=son[root].size();</span><br><span class="line"><span class="keyword">int</span> d=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v=son[root][i];</span><br><span class="line">dfs(v);</span><br><span class="line">dp[root][<span class="number">0</span>]+=min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]);</span><br><span class="line">dp[root][<span class="number">1</span>]+=min(dp[v][<span class="number">0</span>],min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]));</span><br><span class="line">dp[root][<span class="number">2</span>]+=min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]);</span><br><span class="line">d=min(d,dp[v][<span class="number">1</span>]-min(dp[v][<span class="number">1</span>],dp[v][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line">dp[root][<span class="number">1</span>]+=cost[root];</span><br><span class="line">dp[root][<span class="number">2</span>]+=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id,m,fee;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id&gt;&gt;fee&gt;&gt;m;</span><br><span class="line">cost[id]=fee;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">vh[x]=<span class="number">1</span>;</span><br><span class="line">son[id].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(vh[++root]);</span><br><span class="line">dfs(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[root][<span class="number">1</span>],dp[root][<span class="number">2</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通] 涂抹果酱</title>
      <link href="/is-zxy.github.io/2020/01/31/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/"/>
      <url>/is-zxy.github.io/2020/01/31/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/</url>
      
        <content type="html"><![CDATA[<p> Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个$N\times M$的矩形，它被划分成$N\times M$个边长为$1\times 1$的小正方形区域（可以把蛋糕当成$N$行$M$列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为$1,2,3$ 。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 $K$行的果酱，且无法修改。<br>现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数$mod\ 10^6$ 。若不存在满足条件的方案，请输出$0$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$1\le N\times M \le 20$；</p><p>对于$60\%$的数据，$1\le N\le 1000,1\le M \le 3$；</p><p>对于$100\%$的数据，$1\le N \le 10000,1\le M \le 5$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/10172" target="_blank" rel="noopener">「一本通 5.4 练习 1」涂抹果酱</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三种果酱，且$m$较小，则考虑三进制状压。</p><p>先判断其给的第$K$行涂抹的果酱是否合法，不合法直接输出$0$。</p><p>定义$dp[i][j]$表示第$i$行状态为$j$的方案数，则易得（其中$check(l)$表示$l$是一个合法方案。）</p><script type="math/tex; mode=display">dp[i][j]=\sum_{l}^{check(l)}dp[i-1][l]</script><p>当$i-1=k$或$i=k$的情况需要单独考虑。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y) x=(x+y)%mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,zk=<span class="number">0</span>,dp[N][<span class="number">310</span>],w[<span class="number">310</span>][<span class="number">10</span>],ans=<span class="number">0</span>,tot;</span><br><span class="line"><span class="keyword">bool</span> vh[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tot=<span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> b=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">w[i][j]=b%<span class="number">3</span>;</span><br><span class="line">b/=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(j&amp;&amp;w[i][j]==w[i][j<span class="number">-1</span>]) vh[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[i]) <span class="keyword">continue</span>;</span><br><span class="line">dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[<span class="number">1</span>][zk]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span>(w[x][i]==w[y][i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">zk=zk*<span class="number">3</span>+(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">if</span>(!vh[zk]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]||!check(j,zk)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][zk],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>==k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]||!check(j,zk)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][zk]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=k&amp;&amp;i<span class="number">-1</span>!=k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[l]||!check(j,l)) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][l]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) add(ans,dp[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> 三进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU3001] Travelling</title>
      <link href="/is-zxy.github.io/2020/01/31/%5BHDU3001%5D-Travelling/"/>
      <url>/is-zxy.github.io/2020/01/31/%5BHDU3001%5D-Travelling/</url>
      
        <content type="html"><![CDATA[<p>有$n$个城市，$m$个道路，走每一个道路都需要一定费用，每个城市最多经过$2$次，求经过每个城市的最小费用值，若不能经过每个城市则输出$-1$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=n&lt;=10)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3001" target="_blank" rel="noopener">Travelling</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每个城市可能经过$0$次，$1$次，$2$次，那么可以想到三进制状压。</p><p>定义$dp[i][j]$表示在状态$i$下，最后一个到达的城市为$j$的最小费用值。</p><p>定义$bits[k]$表示$3^k$，即到达$k$城市一次。</p><p>那么易得$dp[i+bits[k]][k]=min\{dp[i][j]+cost[j][k]\}$，前提是$dp[i][j]$已被处理出来，$j,k$间有道路相连，且到达$k$的次数小于$2$。</p><p>于是可以初始化$dp$数组为一个极大值，$cost$数组也为一个极大值，输入时覆盖掉。到达一个城市的次数，可以用一个二维数组记录一个数的三进制下的每一位的数字。</p><p>当$dp$过程中发现有一次每一个城市走过了时，便可以从该状态中获得答案，当然可能该状态并没有被拓展过，于是答案也初始化为一个极大值，最终判断是否为该极大值，若是的话，输出$-1$，反之输出答案值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 60010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,bits[N],visit[MAXN][N],cost[N][N],dp[MAXN][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) bits[i]=bits[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bits[<span class="number">10</span>];i++) &#123;</span><br><span class="line"><span class="keyword">int</span> b=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">visit[i][j]=b%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> b/=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line"><span class="built_in">memset</span>(cost,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(cost));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cost[a<span class="number">-1</span>][b<span class="number">-1</span>]=cost[b<span class="number">-1</span>][a<span class="number">-1</span>]=min(c,cost[a<span class="number">-1</span>][b<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[bits[i]][i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bits[n];i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[i][j]) flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]==INF) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(cost[j][k]==INF||visit[i][k]==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">dp[i+bits[k]][k]=min(dp[i+bits[k]][k],dp[i][j]+cost[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) ans=min(ans,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((ans==INF)?<span class="number">-1</span>:ans)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDU </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 三进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1273] 有线电视网</title>
      <link href="/is-zxy.github.io/2020/01/30/%5B%E6%B4%9B%E8%B0%B7P1273%5D-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91/"/>
      <url>/is-zxy.github.io/2020/01/30/%5B%E6%B4%9B%E8%B0%B7P1273%5D-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。</p><p>从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。</p><p>现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。</p><p>写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$2≤N≤3000,1≤M≤N-1$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1273" target="_blank" rel="noopener">P1273 有线电视网</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[root][i]$表示以$root$为根，有$i$个用户的赚钱数。</p><p>则对于每个根，将其子节点所附带的用户数看成一个个物品组，跑分组背包。</p><p>边界$dp[root][0]=0$，其余都初始化为一个极小的负值。</p><p>本题用邻接表较好操作。</p><p>物品组的数量可利用函数返回值来求。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> n,m,head[N],tot=<span class="number">0</span>,v[N],dp[N][N],js[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root&gt;n-m) &#123;</span><br><span class="line">dp[root][<span class="number">1</span>]=v[root];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i;i=edge[i].next) &#123;</span><br><span class="line"><span class="keyword">int</span> js=dfs(edge[i].to);</span><br><span class="line">sum+=js;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(j,js);k++) &#123;</span><br><span class="line">dp[root][j]=max(dp[root][j],dp[root][j-k]+dp[edge[i].to][k]-edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++tot].to=v;</span><br><span class="line">edge[tot].w=w;</span><br><span class="line">edge[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,~<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> a,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;c;</span><br><span class="line">add_edge(i,a,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 背包 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF484A] Bits</title>
      <link href="/is-zxy.github.io/2020/01/30/%5BCF484A%5D-Bits/"/>
      <url>/is-zxy.github.io/2020/01/30/%5BCF484A%5D-Bits/</url>
      
        <content type="html"><![CDATA[<ul><li><p>$n$组询问，每次给出一个区间$l, r$，你需要输出在这个区间内二进制表示中$1$的个数最多的数</p></li><li><p>如有多个答案，输出最小的那个</p></li><li><p>$(n \leq10^4, 0\leq l, r \leq10^{18})$</p></li></ul><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF484A" target="_blank" rel="noopener">CF484A Bits</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于是在$[l,r]$区间内，即需要大于等于$l$且小于等于$r$，则可以直接在$l$上进行操作。</p><p>从$l$的二进制最低位开始，每一位都$|1$，直到再$|1$就比$r$大了为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll l,r,t=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">while</span>((l|t)&lt;=r) &#123;</span><br><span class="line">l=l|t;</span><br><span class="line">t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[NOI2001] 炮兵阵地</title>
      <link href="/is-zxy.github.io/2020/01/29/%5BNOI2001%5D-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/"/>
      <url>/is-zxy.github.io/2020/01/29/%5BNOI2001%5D-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<p>司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个$N \times M$的地图由$N$行$M$列组成，地图的每一格可能是山地（用“$H$” 表示），也可能是平原（用“$P$”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><p><a href="https://postimg.cc/XXgC8BMP" target="_blank" rel="noopener"><img src="https://i.postimg.cc/tRKN9FB9/1881.jpg" alt="1881.jpg"></a></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$N≤100,M≤10$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2704" target="_blank" rel="noopener">[NOI2001]炮兵阵地</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>状压。</p><p>每个方案都与上两行有关。</p><p>定义$dp[i][j][k]$表示第$i$行状态为$j$，$i-1$行状态为$k$时最多摆放的炮兵部队数量。</p><p>易得（其中$check(l)$表示第$i-2$行状态为$l$对于此方案是可行的。$sum[j]$表示状态$j$的炮兵数量，即二进制中$1$的个数。）</p><script type="math/tex; mode=display">dp[i][j][k]=max_{l}^{check(l)}\{dp[i-1][k][l]\}+sum[j]</script><p>但是这样的话，$dp$数组就要开到$dp[100][2^{10}][2^{10}]$，明显会爆空间。</p><p>然而并不是每一个状态都是可行的，相邻两个位置不能同时摆炮兵，据此可大略算出$10$列的话可行状态不超过$100$。因此后两维开到$100$，并用另一个数组记录可行状态，再进行$DP$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,p[N],dp[N][N][N],sum[N*<span class="number">10</span>],a[N],js=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(x&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i&amp;(i&gt;&gt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">1</span>))||(i&amp;(i&lt;&lt;<span class="number">2</span>))||(i&amp;(i&gt;&gt;<span class="number">2</span>))) <span class="keyword">continue</span>;</span><br><span class="line">a[++js]=i;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">sum[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=js;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=js;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[i],a[j])||!check(a[i],p[<span class="number">2</span>])||!check(a[j],p[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">dp[<span class="number">2</span>][i][j]=sum[a[i]]+sum[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> t=(s[i][j]==<span class="string">'P'</span>)?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">p[i]=(p[i]&lt;&lt;<span class="number">1</span>)+t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=js;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(p[i],a[j])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=js;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[j],a[k])||!check(p[i<span class="number">-1</span>],a[k])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=js;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(a[l],a[k])||!check(a[j],a[l])||!check(a[l],p[i<span class="number">-2</span>])) <span class="keyword">continue</span>;</span><br><span class="line">maxn=max(maxn,dp[i<span class="number">-1</span>][k][l]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j][k]=max(maxn+sum[a[j]],dp[i][j][k]);</span><br><span class="line">ans=max(ans,dp[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> NOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO06NOV] 玉米田Corn Fields</title>
      <link href="/is-zxy.github.io/2020/01/26/%5BUSACO06NOV%5D-%E7%8E%89%E7%B1%B3%E7%94%B0Corn-Fields/"/>
      <url>/is-zxy.github.io/2020/01/26/%5BUSACO06NOV%5D-%E7%8E%89%E7%B1%B3%E7%94%B0Corn-Fields/</url>
      
        <content type="html"><![CDATA[<p>农场主$John$新买了一块长方形的新牧场，这块牧场被划分成$M$行$N$列$(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)$，每一格都是一块正方形的土地。$John$打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p><p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是$John$不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p><p>$John$想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1 ≤ M ≤ 12,1 ≤ N ≤ 12) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1879" target="_blank" rel="noopener">[USACO06NOV]玉米田Corn Fields</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与互不侵犯多少有些相似。</p><p>定义$dp[i][j]$表示第$i$行的状态为$j$时的方案数，易得</p><script type="math/tex; mode=display">dp[i][j]=sum_{k}^{check(k)}dp[i-1][k]</script><p>边界$dp[0][0]=1$。</p><p>其中$check(k)$表示$k$为一个合法状态，前提也保证$j$为一个合法状态。</p><p>不相邻$\&amp; $一下就好，问题在于如何保证种的地方可以种。</p><p>还是$\&amp; $，若是合法，则$\&amp; $后应返回原值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y) x=(x+y)%MOD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,g[<span class="number">15</span>],dp[<span class="number">15</span>][<span class="number">5010</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;(i&lt;&lt;<span class="number">1</span>)||i&amp;(i&gt;&gt;<span class="number">1</span>)) p[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">g[i]=(g[i]&lt;&lt;<span class="number">1</span>)+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((j&amp;g[i])!=j||(p[j])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(j,k)||(k&amp;g[i<span class="number">-1</span>])!=k||p[k]) <span class="keyword">continue</span>;</span><br><span class="line">add(dp[i][j],dp[i<span class="number">-1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) add(ans,dp[n][i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题还让我认识到了运算符的优先级，位运算符优先级要小于等于与不等于，因此要加括号。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CQOI2005] 珠宝</title>
      <link href="/is-zxy.github.io/2020/01/23/%5BCQOI2005%5D-%E7%8F%A0%E5%AE%9D/"/>
      <url>/is-zxy.github.io/2020/01/23/%5BCQOI2005%5D-%E7%8F%A0%E5%AE%9D/</url>
      
        <content type="html"><![CDATA[<p> 有一棵 $n$ 个结点的树，给每个点安排一个正整数编号，使得相邻点具有不同的编号，编号的总和尽量小。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$20\%$的数据，$n\le 10$；</p><p>对于$40\%$的数据，$n\le 1000$；</p><p>对于$100\%$的数据，$1\le n\le 50000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5765" target="_blank" rel="noopener">[CQOI2005]珠宝</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>明显具有无后效性，于是树形DP。</p><p>定义$dp[root][x]$表示以$root$为根且$root$上数字为$x$的子树的最小编号总和。</p><p>于是易得（令$root$有$m$个儿子$son_{1\cdots m}$）</p><script type="math/tex; mode=display">dp[root][x]=min_{i=1}^m\{dp[son_i][k]\}+x\ ,\  k!=x</script><p>由于本题数据较小，$k$的枚举到$10$左右即可，不放心可开大些。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">15</span>],n,ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vh[g[root][i]]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> minn=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">10</span>;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j==k) <span class="keyword">continue</span>;</span><br><span class="line">minn=min(dp[g[root][i]][k],minn);</span><br><span class="line">&#125;</span><br><span class="line">dp[root][j]+=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) dp[root][i]+=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">g[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) ans=min(dp[<span class="number">1</span>][i],ans);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CQOI </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SCOI2005] 互不侵犯</title>
      <link href="/is-zxy.github.io/2020/01/21/%5BSCOI2005%5D-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"/>
      <url>/is-zxy.github.io/2020/01/21/%5BSCOI2005%5D-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/</url>
      
        <content type="html"><![CDATA[<p> 在$n\times n$的棋盘里面放$k$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到他周围的八个格子。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1 &lt;=N &lt;=9,0 &lt;= K &lt;= N^2)$</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1896" target="_blank" rel="noopener">SCOI2005 互不侵犯</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>刚学状压。</p><p>$1&lt;=n&lt;=9$，$0&lt;=k&lt;=n^2$，明显$dfs$过不了。</p><p>这时候状态压缩DP就出现了。</p><p>可以用$0$和$1$表示一个格子放没放国王，放了为$1$。</p><p>定义$dp[i][j][s]$表示前$i$行，上一行状态为$j$，这一行共放了$s$个国王的方案数。其中状态即为一二进制数的十进制表示，该二进制下的$0$和$1$即为状态。</p><p>令$j$的二进制下有$sum[j]$个$1$，即$sum[j]$个国王。</p><p>则$dp[i][j][sum[j]+p]=\sum_{p=0}^{k-sum[j]}dp[i-1][l][p]$，其中$l$为符合条件且不与$j$冲突的状态。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tot (1&lt;&lt;n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">1</span>&lt;&lt;N][N*N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,sum[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;y||(x&gt;&gt;<span class="number">1</span>)&amp;y||(x&lt;&lt;<span class="number">1</span>)&amp;y||x&amp;(x&lt;&lt;<span class="number">1</span>)||x&amp;(x&gt;&gt;<span class="number">1</span>)||y&amp;(y&lt;&lt;<span class="number">1</span>)||y&amp;(y&gt;&gt;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j) &#123;</span><br><span class="line">sum[i]++;</span><br><span class="line">j-=lowbit(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&lt;=k) dp[<span class="number">1</span>][i][sum[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;tot;l++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!check(j,l)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=k-sum[j];s++) &#123;</span><br><span class="line">dp[i][j][sum[j]+s]+=dp[i<span class="number">-1</span>][l][s];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++) ans+=dp[n][i][k];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然有些麻烦，还可以提前预处理出符合条件的状态，这里懒得写了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
            <tag> SCOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1122] 最大子树和</title>
      <link href="/is-zxy.github.io/2020/01/20/%5B%E6%B4%9B%E8%B0%B7P1122%5D-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%A0%91%E5%92%8C/"/>
      <url>/is-zxy.github.io/2020/01/20/%5B%E6%B4%9B%E8%B0%B7P1122%5D-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%A0%91%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：</p><p>一株奇怪的花卉，上面共连有$N$朵花，共有$N-1$条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p><p>老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$60\%$的数据，有$N≤1000$；</p><p>对于$100\%$的数据，有$N≤16000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1122" target="_blank" rel="noopener">P1122 最大子树和</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$dp[root]$表示以$root$为根的最大子树和。</p><p>易得（其中令$root$有$m$个儿子$son_{1\cdots m}$，$root$的美丽指数为$b_{root}$)</p><script type="math/tex; mode=display">dp[root]=\sum_{i=1}^mmax(0,dp[son_i])+b_{root}</script><p>上述与$0$比较的原因是美丽值可能为负。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"><span class="keyword">int</span> n,dp[N],b[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>,dp[root]=b[root];</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[g[root][i]]) &#123;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line">dp[root]+=max(dp[g[root][i]],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,dp[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].push_back(y);</span><br><span class="line">g[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[一本通] 数字转换</title>
      <link href="/is-zxy.github.io/2020/01/20/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
      <url>/is-zxy.github.io/2020/01/20/%5B%E4%B8%80%E6%9C%AC%E9%80%9A%5D-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p> 如果一个数$x$的约数和 $y$（不包括他本身）比他本身小，那么$x$可以变成$y$，$y$也可以变成$x$。$4$例如 可以变为$3$，$1$可以变为$7$。限定所有数字变换在不超过$n$的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$100\%$的数据，$1\le n \le 50000$。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/10155" target="_blank" rel="noopener">「一本通 5.2 例 3」数字转换</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很明显数字间的变化关系为森林。</p><p>那么本题其实就是求这个森林内每棵树的最长链的最大值。</p><p>大数一定是小数的儿子，于是倒着推即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,factor[N],dp[N][<span class="number">2</span>],ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n/i;j++) factor[i*j]+=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(factor[i]&lt;i) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][<span class="number">0</span>]+<span class="number">1</span>&gt;dp[factor[i]][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[factor[i]][<span class="number">1</span>]=dp[factor[i]][<span class="number">0</span>];</span><br><span class="line">dp[factor[i]][<span class="number">0</span>]=dp[i][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dp[i][<span class="number">0</span>]+<span class="number">1</span>&gt;dp[factor[i]][<span class="number">1</span>]) dp[factor[i]][<span class="number">1</span>]=dp[i][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(dp[i][<span class="number">0</span>]+dp[i][<span class="number">1</span>],ans);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2016] 战略游戏</title>
      <link href="/is-zxy.github.io/2020/01/19/%5B%E6%B4%9B%E8%B0%B7P2016%5D-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/is-zxy.github.io/2020/01/19/%5B%E6%B4%9B%E8%B0%B7P2016%5D-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p><p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p><p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p><p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (0&lt;n&lt;=1500) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2016" target="_blank" rel="noopener">P2016 战略游戏</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与没有上司的舞会那题有些类似。</p><p>定义$dp[root][f]$，当$f=0$时表示$root$处不放士兵的以$root$为根的子树符合条件时的最少士兵数，当$f=1$时即为$root$处放士兵。</p><p>当$root$处不放士兵，那么它所有的儿子必须放。当$root$处放士兵，那么它儿子放不放都行。</p><p>于是可得状态转移方程（其中假设$root$有$m$个儿子$son_{1\cdots m}$</p><script type="math/tex; mode=display">dp[root][f]=\left\{\begin{aligned}\sum_{i=1}^mdp[son_i][1]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  && f=0 \\\sum_{i=1}^mmin(dp[son_i][1],dp[son_i][0]) && f=1\end{aligned}\right.</script><p>其中初值：$dp[root][0]=0,dp[root][1]=1$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1510</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>;</span><br><span class="line">dp[root][<span class="number">1</span>]=<span class="number">1</span>,dp[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=g[root].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[g[root][i]]) &#123;</span><br><span class="line">dfs(g[root][i]);</span><br><span class="line">dp[root][<span class="number">0</span>]+=dp[g[root][i]][<span class="number">1</span>];</span><br><span class="line">dp[root][<span class="number">1</span>]+=min(dp[g[root][i]][<span class="number">0</span>],dp[g[root][i]][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id,s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;id&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++) &#123;</span><br><span class="line"><span class="keyword">int</span> sid;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sid;</span><br><span class="line">g[sid].push_back(id);</span><br><span class="line">g[id].push_back(sid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1352] 没有上司的舞会</title>
      <link href="/is-zxy.github.io/2020/01/18/%5B%E6%B4%9B%E8%B0%B7P1352%5D-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/"/>
      <url>/is-zxy.github.io/2020/01/18/%5B%E6%B4%9B%E8%B0%B7P1352%5D-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<p> 某大学有$N$个职员，编号为$1-N$。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$，但是呢，如果某个职员的<strong>直接</strong>上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 </p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1&lt;=N&lt;=6000) $</p><p>$ (-128&lt;=Ri&lt;=127) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">P1352 没有上司的舞会</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树形DP的入门题。</p><p>定义状态$dp[root][f]$表示以$root$为根的状态，若$f=0$表示$root$不选，若$f=1$表示$root$选。</p><p>那么易得状态转移方程（其中$son_i$表示$root$的儿子，设$root$有$m$个儿子）</p><script type="math/tex; mode=display">dp[root][f]=\left\{\begin{aligned}\sum_{i=1}^mmax(dp[son_i][0],dp[son_i][1]) && f=0 \\(\sum_{i=1}^mdp[son_i][0])+r[root]\ \ \ \ \ \ \ \ \ \ \ \  && f=1\end{aligned}\right.</script><p>最后比较输出两种方案的最大者即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,r[N],dp[N][<span class="number">2</span>],rt,vh[N];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=son[root].size();</span><br><span class="line"><span class="keyword">if</span>(!cnt) <span class="keyword">return</span> dp[root][<span class="number">1</span>]=r[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">dfs(son[root][i]);</span><br><span class="line"><span class="keyword">int</span> j=son[root][i];</span><br><span class="line">dp[root][<span class="number">0</span>]=max(dp[root][<span class="number">0</span>],max(dp[root][<span class="number">0</span>]+dp[j][<span class="number">0</span>],dp[root][<span class="number">0</span>]+dp[j][<span class="number">1</span>]));</span><br><span class="line">dp[root][<span class="number">1</span>]=dp[root][<span class="number">1</span>]+dp[j][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[root][<span class="number">1</span>]+=r[root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;r[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">vh[x]=<span class="number">1</span>;</span><br><span class="line">son[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) &#123;</span><br><span class="line">rt=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;max(dp[rt][<span class="number">1</span>],dp[rt][<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2015] 二叉苹果树</title>
      <link href="/is-zxy.github.io/2020/01/17/%5B%E6%B4%9B%E8%B0%B7P2015%5D-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/"/>
      <url>/is-zxy.github.io/2020/01/17/%5B%E6%B4%9B%E8%B0%B7P2015%5D-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>有一颗苹果树，如果树枝有分叉，一定是分$2$叉（就是说没有只有一个儿子的结点）</p><p>这棵树共有$n$个结点（叶子点或者树枝分叉点），编号为$1-n$，树根编号一定是$1$。</p><p>现在这棵树枝条太多了，需要剪枝，但是一些树枝上长有苹果。</p><p>给定需要保留的树枝的数量$q$，求出最多能留住多少苹果。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ (1&lt;=Q&lt;= N,1&lt;N&lt;=100) $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2015" target="_blank" rel="noopener">P2015 二叉苹果树</a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>今天才学的树形$DP$例题。</p><p>定义$dp[i][j]$表示以第$i$ 号结点为根，保留$j$个树枝的最多能留住的苹果数量。</p><p>那么最终答案即为$dp[1][q]$。</p><p>先把$dp$数组初值赋为$-1$。</p><p>然后利用分治(?)思想，对每个结点的左右子结点进行操作。</p><p>若该结点$i$为叶子结点，则直接$dp[i][0]=0$，然后跳出该层搜索，因为以该结点为根的没有树枝。</p><p>若不为，则对其左右子结点进行操作，然后将两个子节点的状态更新至该结点上。</p><p>即若$dp[son][j]!=-1$的话，那么$dp[i][j+1]=max(dp[i][j+1],dp[son][j]+value[son])$，即增加这个连接该儿子的树枝。（其中$value$为边权值，即苹果数量。）</p><p>同理，需要讨论连接两个儿子的数枝都增加的情况，即若$dp[son_{left}][j]!=-1$并且$dp[son_{right}][k]!=-1$的话，那么<script type="math/tex">dp[i][j+k+2]=max(dp[i][j+k+2],dp[son_{left}][j]+dp[son_{right}][k]+value[son_{left}]+value[son_{right}])</script></p><p>于是据此从根向下搜索然后向上上传状态最后输出$dp[1][q]$即可。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> vh[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;node&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">vh[root]=<span class="number">1</span>,dp[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=edge[root].size(),ln,rn,lid=<span class="number">0</span>,rid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[edge[root][i].t]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!lid) &#123;</span><br><span class="line">ln=edge[root][i].num;</span><br><span class="line">lid=edge[root][i].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">rn=edge[root][i].num;</span><br><span class="line">rid=edge[root][i].t;</span><br><span class="line">&#125;</span><br><span class="line">dfs(edge[root][i].t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!lid) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[lid][i]!=<span class="number">-1</span>) dp[root][i+<span class="number">1</span>]=dp[lid][i]+ln;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[rid][i]!=<span class="number">-1</span>) dp[root][i+<span class="number">1</span>]=max(dp[root][i+<span class="number">1</span>],dp[rid][i]+rn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i+j+<span class="number">2</span>&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[lid][i]!=<span class="number">-1</span>&amp;&amp;dp[rid][j]!=<span class="number">-1</span>) dp[root][i+j+<span class="number">2</span>]=max(dp[root][i+j+<span class="number">2</span>],dp[lid][i]+dp[rid][j]+ln+rn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">node p;</span><br><span class="line">p.t=y,p.num=z;</span><br><span class="line">edge[x].push_back(p);</span><br><span class="line">p.t=x;</span><br><span class="line">edge[y].push_back(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][q]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还可以把边权化为点权，过程与上面差不多，但略微简单了些。但是还是上面的好理解一些。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,g[N][N],l[N],r[N],value[N],dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(g[root][i]!=<span class="number">-1</span>&amp;&amp;!l[root]) &#123;</span><br><span class="line">value[i]=g[root][i];</span><br><span class="line">l[root]=i;</span><br><span class="line">g[root][i]=g[i][root]=<span class="number">-1</span>;</span><br><span class="line">son(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g[root][i]!=<span class="number">-1</span>&amp;&amp;l[root]) &#123;</span><br><span class="line">value[i]=g[root][i];</span><br><span class="line">r[root]=i;</span><br><span class="line">g[root][i]=g[i][root]=<span class="number">-1</span>;</span><br><span class="line">son(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[root][k]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[root][k];</span><br><span class="line"><span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!l[root]&amp;&amp;!r[root]) <span class="keyword">return</span> value[root];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;i++) &#123;</span><br><span class="line">dp[root][k]=max(dp[root][k],dfs(l[root],i)+dfs(r[root],k-i<span class="number">-1</span>)+value[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[root][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">-1</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">g[x][y]=g[y][x]=z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dfs(<span class="number">1</span>,q+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>细节较多，需格外注意，如树枝上可能没有苹果。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P2568] GCD</title>
      <link href="/is-zxy.github.io/2020/01/08/%5B%E6%B4%9B%E8%B0%B7P2568%5D-GCD/"/>
      <url>/is-zxy.github.io/2020/01/08/%5B%E6%B4%9B%E8%B0%B7P2568%5D-GCD/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，求$1&lt;=x,y&lt;=n$且$gcd(x,y)$为质数的数对$(x,y)$有多少对。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$ 1&lt;=N&lt;=10^7 $</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2568" target="_blank" rel="noopener">P2568 GCD</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设一组满足条件的$(x,y)$，$gcd(x,y)=p$，$p$为质数。</p><p>易得$gcd(\frac{x}{p},\frac{y}{p})=1$。</p><p>那么对于一个质数$p$只需求$1&lt;=\frac{x}{p},\frac{y}{p}&lt;=n$且$gcd(\frac{x}{p},\frac{y}{p})=1$的对数就行了。</p><p>互质的数的个数，便可以转化为欧拉函数。</p><p>由欧拉函数的定义，$[1,n]$内互质的数的对数可由$\sum_{i=1}^n\varphi(i)-1$求得。</p><p>于是对于一个质数$p$，其$[1,n]$内$gcd(x,y)=p$的对数即为$2\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\varphi(i)-1$，乘$2$是因为求的是对数，减$1$是因为去掉了$x=y$的情况。</p><p>于是便可以$O(n)$处理处欧拉函数，然后前缀和优化，接着枚举$p$进行累加即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>,euler[N],prime[N],v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||i*prime[j]&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[i*prime[j]]=euler[i]*euler[prime[j]];</span><br><span class="line"><span class="keyword">else</span> euler[i*prime[j]]=euler[i]*prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>]+euler[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">primes(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans+=<span class="number">2</span>*sum[n/prime[i]]<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3373] 【模板】线段树2/[AHOI2009]维护序列</title>
      <link href="/is-zxy.github.io/2020/01/07/%5B%E6%B4%9B%E8%B0%B7P3373%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%912-AHOI2009-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97/"/>
      <url>/is-zxy.github.io/2020/01/07/%5B%E6%B4%9B%E8%B0%B7P3373%5D-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%912-AHOI2009-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一有$n$个元素的序列，输入$m$个命令，其中</p><p>$1\ x\ y\ k$表示将区间$[x,y]$内每个数乘上$k$。</p><p>$2\ x\ y\ k$表示将区间$[x,y]$内每个数加上$k$。</p><p>$3\ x\ y$输出区间$[x,y]$内每个数的和对$P$取模的值。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 30\%$的数据：$n \le 8$，$m \le 10$<br>对于$ 70\%$的数据：$n \le 10^3$，$m \le 10^4$<br>对于$100\%$的数据：$n \le 10^5$，$m \le 10^5$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3373" target="_blank" rel="noopener">P3373 【模板】线段树 2</a></p><p><a href="https://www.luogu.com.cn/problem/P2023" target="_blank" rel="noopener">[AHOI2009]维护序列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>增加了一个区间乘的操作。</p><p>总体思想与线段树$1$差不多，延迟标记的运用，本题需要两个，一个乘，一个加。</p><p>但本题难点在于加与乘的顺序。</p><p>可以每次区间乘$k$的同时将加延迟标记也乘$k$，然后更新时乘上乘延迟标记再加上加延迟标记乘区间长度即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll mod;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,tag_add,tag_mul;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ta(x) tree[x].tag_add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tm(x) tree[x].tag_mul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r,ta(p)=<span class="number">0</span>,tm(p)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sum(p);</span><br><span class="line">sum(p)%=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ta(ls)=(ta(p)+(ta(ls)*tm(p))%mod)%mod,ta(rs)=(ta(p)+(ta(rs)*tm(p))%mod)%mod;</span><br><span class="line">tm(ls)=(tm(p)*tm(ls))%mod,tm(rs)=(tm(p)*tm(rs))%mod;</span><br><span class="line"></span><br><span class="line">sum(ls)=((sum(ls)*tm(p))%mod+ta(p)*(r(ls)-l(ls)+<span class="number">1</span>))%mod;</span><br><span class="line">sum(rs)=((sum(rs)*tm(p))%mod+ta(p)*(r(rs)-l(rs)+<span class="number">1</span>))%mod;</span><br><span class="line"></span><br><span class="line">ta(p)=<span class="number">0</span>;</span><br><span class="line">tm(p)=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=(sum(p)+k*(r(p)-l(p)+<span class="number">1</span>)%mod)%mod;</span><br><span class="line">ta(p)=(ta(p)+k)%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">change_add(ls,l,r,k);</span><br><span class="line">change_add(rs,l,r,k);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_mul</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)=(sum(p)*k)%mod;</span><br><span class="line">ta(p)=(ta(p)*k)%mod;</span><br><span class="line">tm(p)=(tm(p)*k)%mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">change_mul(ls,l,r,k);</span><br><span class="line">change_mul(rs,l,r,k);</span><br><span class="line">sum(p)=(sum(ls)+sum(rs))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;r||r(p)&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ((ask(ls,l,r)%mod)+(ask(rs,l,r)%mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line">ll k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">switch</span>(ins) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change_mul(<span class="number">1</span>,x,y,k);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change_add(<span class="number">1</span>,x,y,k);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题细节较多，我调了一个多小时。</p><p>第一，标记都不能直接更改，而是在原来的基础上进行加或乘。</p><p>第二，标记下传的时候，子节点的加延迟标记也要乘父节点的乘延迟标记（就是这个让我查了贼长时间）。</p><p>细节需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CQOI2006] 简单题</title>
      <link href="/is-zxy.github.io/2020/01/05/%5BCQOI2006%5D-%E7%AE%80%E5%8D%95%E9%A2%98/"/>
      <url>/is-zxy.github.io/2020/01/05/%5BCQOI2006%5D-%E7%AE%80%E5%8D%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>给定一有$n$个元素的数组，初始每个元素都为$0$。</p><p>输入$m$条指令，其中</p><p>$1\ x\ y$表示将区间$[x,y]$内的数反转（$0$变$1$，$1$变$0$）。</p><p>$2\ x$表示查询第$x$个元素的值。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$50\%$的数据，$1 ≤ n ≤ 10^{3}$,$1 ≤ m ≤ 10^4$；</p><p>对于$100\%$的数据，$1 ≤ n ≤ 10^5$,$1 ≤ m ≤ 5 × 10^5$，保证$L ≤ R$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P5057" target="_blank" rel="noopener">[CQOI2006]简单题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然，一个位置如果被反转过奇数次则为$1$，反之则为$0$。</p><p>针对每个反转指令维护差分，查询则直接查询差分的前缀和$\&amp; 1$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(x;x&lt;=n;x+=lowbit(x)) a[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(x;x;x-=lowbit(x)) ans+=a[x];</span><br><span class="line"><span class="keyword">return</span> ans&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">if</span>(t&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">update(x,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(y&lt;n) update(y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CQOI </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SP1716] GSS3 - Can you answer these queries III</title>
      <link href="/is-zxy.github.io/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/"/>
      <url>/is-zxy.github.io/2020/01/03/%5BSP1716%5D-GSS3-Can-you-answer-these-queries-III/</url>
      
        <content type="html"><![CDATA[<p>$n$个数，$q$次操作。</p><p>操作$0\ x\ y$表示吧$A_x$修改为$y$。</p><p>操作$1\ l\ r$询问区间$[l,r]$的最大子段和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(N &lt;= 50000)$</p><p>$(M &lt;= 50000)$</p><p>$ (|y|&lt;=10000)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/SP1716" target="_blank" rel="noopener">SP1716 GSS3 - Can you answer these queries III</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线段树维护，维护区间和$sum$,区间最大子段和$dat$，紧靠左端的最大子段和$lmax$，紧靠右端的最大子段和$rmax$。</p><p>然后$build$与$change$的过程中维护这些即可。</p><p>节点$p$的最大子段和为左节点的最大子段和、右节点则最大子段和、左节点的紧靠右端的最大子段和加右节点的紧靠左端的最大子段和，这三者的最大值。</p><p>节点$p$的紧靠左端的最大子段和为左节点的紧靠左端的最大子段和，左节点的区间和加右节点的紧靠左端的最大子段和，这二者的最大值。</p><p>节点$p$的紧靠右端的最大子段和为右节点的紧靠右端的最大子段和，右节点的区间和加左节点的紧靠右端的最大子段和，这二者的最大值。</p><p>最后的$ask$，需要控制其子段为连续的，仍遵循上面的方法查询即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum,lmax,rmax,dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(x) tree[x].lmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(x) tree[x].rmax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line">&#125;tree[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=lm(p)=rm(p)=dat(p)=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">lm(p)=max(lm(p*<span class="number">2</span>),sum(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rm(p)=max(rm(p*<span class="number">2</span>+<span class="number">1</span>),sum(p*<span class="number">2</span>+<span class="number">1</span>)+rm(p*<span class="number">2</span>));</span><br><span class="line">dat(p)=max(dat(p*<span class="number">2</span>),max(dat(p*<span class="number">2</span>+<span class="number">1</span>),rm(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">sum(p)=lm(p)=rm(p)=dat(p)=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=x) change(p*<span class="number">2</span>,x,k);</span><br><span class="line"><span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">lm(p)=max(lm(p*<span class="number">2</span>),sum(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">rm(p)=max(rm(p*<span class="number">2</span>+<span class="number">1</span>),sum(p*<span class="number">2</span>+<span class="number">1</span>)+rm(p*<span class="number">2</span>));</span><br><span class="line">dat(p)=max(dat(p*<span class="number">2</span>),max(dat(p*<span class="number">2</span>+<span class="number">1</span>),rm(p*<span class="number">2</span>)+lm(p*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Segment_Tree <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=r) <span class="keyword">return</span> ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;l) <span class="keyword">return</span> ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Segment_Tree ls,rs,ans;</span><br><span class="line">ls=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line">rs=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">ans.dat=max(ls.dat,max(rs.dat,ls.rmax+rs.lmax));</span><br><span class="line">ans.lmax=max(ls.lmax,ls.sum+rs.lmax);</span><br><span class="line">ans.rmax=max(rs.rmax,rs.sum+ls.rmax);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(ins) <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y).dat&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> change(<span class="number">1</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPOJ </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树学习笔记</title>
      <link href="/is-zxy.github.io/2020/01/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2020/01/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线段树是一种以分治为主体思想的数据结构，主要对区间进行操作。</p><p>与之前所学习的树状数组相比，其好处在于更加通用，易扩展，不过码量较大。</p><a id="more"></a><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>正如其名，线段树是一个二叉树形结构，其每个点其实是一个区间。</p><p>根节点保存的区间为$[1,n]$，编号为$1$，其左节点编号为$1\times2=2$，保存区间为$[1,\lfloor\frac{1+n}{2}\rfloor]$；右节点编号为$1\times2+1=3$，保存区间为$[\lfloor\frac{1+n}{2}\rfloor,n]$。以此类推，直到区间长度为$1$为止(除法全部向下取整)。</p><p>根据此建立规则，发现编号最大可能到$4n$，所以数组至少要到$4n$。</p><p>建立、修改、查询之类的一系列操作均递归实现。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>给定一个有$n$个数的序列，对其进行$m$个操作。</p><p>输入$1\ x\ k$时，将第$x$个数加上$k$。</p><p>输入$2\ x\ y$时，输出区间$[x,y]$每个数的和。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">P3374 【模板】树状数组 1</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线段树维护区间和即可。</p><p>本题线段树过不了，主要为了熟悉线段树写法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">&#125;tree[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">sum(p)=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)==r(p)) &#123;</span><br><span class="line">sum(p)+=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=x) add(p*<span class="number">2</span>,x,k);</span><br><span class="line"><span class="keyword">else</span> add(p*<span class="number">2</span>+<span class="number">1</span>,x,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(ins%<span class="number">2</span>) add(<span class="number">1</span>,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是求区间的最大/最小值，或是其他奇奇怪怪的具有可加性的东西，则分析分析修改修改即可。这里就显示出了线段树的易扩展性。</p><h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>给定一个有$n$个数的序列，对其进行$m$个操作。</p><p>输入$1\ x\ y\ k$时，表示将区间$[x,y]$内每个数加上$k$。</p><p>输入$2\ x\ y$时，输出区间$[x,y]$的和。</p><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对区间$[l,r]$进行修改，若是朴素算法，则为$O(n)$，那线段树就没啥意义了。</p><p>想想之前学过的树状数组，树状数组的区间修改是利用差分思想，将区间修改转化为其擅长的单点修改，于是对于线段树，一种叫做“延迟标记”(lazy tag)的东西诞生了。</p><p>针对区间$[l,r]$进行修改，若是将其每个点都进行了修改，那么之后的查询若是没有查询到$[l,r]$的子区间的话，那么更新其每个点显然是不必要的。因此可以先只对$[l,r]$进行修改，将其加上一个标记，之后的查询过程中若是查到了子区间，先进行“标记下传”，即将修改的值传递到其子区间，然后再进行查询。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">ll sum,lazy;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazy(x) tree[x].lazy</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l(p)=l,r(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;sum(p);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazy(p)) &#123;</span><br><span class="line">sum(p*<span class="number">2</span>)+=lazy(p)*(r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">sum(p*<span class="number">2</span>+<span class="number">1</span>)+=lazy(p)*(r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">lazy(p*<span class="number">2</span>)+=lazy(p);</span><br><span class="line">lazy(p*<span class="number">2</span>+<span class="number">1</span>)+=lazy(p);</span><br><span class="line">lazy(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) &#123;</span><br><span class="line">sum(p)+=(r(p)-l(p)+<span class="number">1</span>)*k;</span><br><span class="line">lazy(p)+=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) change(p*<span class="number">2</span>,l,r,k);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">sum(p)=sum(p*<span class="number">2</span>)+sum(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r) <span class="keyword">return</span> sum(p);</span><br><span class="line"><span class="keyword">int</span> mid=l(p)+r(p)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">spread(p);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ins,x,y,k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">if</span>(!(ins&amp;<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">change(<span class="number">1</span>,x,y,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间的范围之类的细节值得注意，特别是如此繁长的线段树代码。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p><a href="https://www.luogu.com.cn/problem/SP1716" target="_blank" rel="noopener">SP1716 GSS3 - Can you answer these queries III</a>（单点修改求区间最大连续子段和）。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P1835] 素数密度</title>
      <link href="/is-zxy.github.io/2020/01/01/%5B%E6%B4%9B%E8%B0%B7P1835%5D-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/"/>
      <url>/is-zxy.github.io/2020/01/01/%5B%E6%B4%9B%E8%B0%B7P1835%5D-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>给定区间$[L,R],(L\le R\le 2147483647,R-L\le 1000000)$，计算出区间内素数的个数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P1835" target="_blank" rel="noopener">P1835 素数密度</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>$L,R$很大，于是直接处理素数肯定是不行的。</p><p>发现，$R-L$的值在可承受的范围内，于是可以先线性筛处理处$\sqrt{2147483647}$以内的所有素数，再用筛法把区间内的合数标记，最后扫一遍记录素数个数即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll l,r,prime[N+<span class="number">10</span>],v[N+<span class="number">10</span>],m=<span class="number">0</span>,ans=<span class="number">0</span>,vh[<span class="number">20</span>*N+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">primes(N);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">l=(l==<span class="number">1</span>?<span class="number">2</span>:l);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[i]&gt;<span class="built_in">sqrt</span>(r)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=max(<span class="number">2l</span>l,(l<span class="number">-1</span>)/prime[i]+<span class="number">1</span>);j&lt;=r/prime[i];j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[i]*j&gt;=l&amp;&amp;prime[i]*j&lt;=r) vh[prime[i]*j-l+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vh[i]) ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线性筛 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF546D] Soldier and Number Game</title>
      <link href="/is-zxy.github.io/2020/01/01/%5BCF546D%5D-Soldier-and-Number-Game/"/>
      <url>/is-zxy.github.io/2020/01/01/%5BCF546D%5D-Soldier-and-Number-Game/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，接下来有$n$组$a,b$，求$a!/b!$的质因子个数。</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF546D" target="_blank" rel="noopener">CF546D Soldier and Number Game</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$sum[x]$表示$x$的质因子个数。</p><p>易得$sum[xy]=sum[x]+sum[y]$。</p><p>那么就可以用线性筛求出$1$到$5000000$的$sum$值，阶乘的话，根据上面的式子，$sum[!x]=\sum_{i=1}^xsum[i]$，于是求前缀和即可。</p><p>最后针对每组$a,b$，前缀和相减。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>,prime[N],v[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">sum[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]*i&gt;n||prime[j]&gt;v[i]) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">sum[prime[j]*i]=sum[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">init(N);</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum[a]-sum[b]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性筛与积性函数学习笔记</title>
      <link href="/is-zxy.github.io/2019/12/29/%E7%BA%BF%E6%80%A7%E7%AD%9B%E4%B8%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/is-zxy.github.io/2019/12/29/%E7%BA%BF%E6%80%A7%E7%AD%9B%E4%B8%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>线性筛法是一种$O(n)$的筛质数算法。</p><p>然而最近我才知道，线性筛不仅仅是用来筛质数的，还能用来求积性函数。</p><a id="more"></a><h1 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h1><p>首先，之前学过的埃氏筛法是将合数标记的算法。</p><p>但是埃氏筛法会将重复的合数标记，这就造成了效率不够高。</p><p>而线性筛法就是不会重复标记合数的算法，因此使得效率由埃氏筛法的$O(n\log \log n)$变为$O(n)$。</p><p>主题思想为，在生成一个需要标记的合数时，每次只向现有的数乘上一个质因子，并且让它是这个合数的最小质因子。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其中$v[i]$表示数$i$的最小质因子，$prime[i]$表示第$i$个质数，$m$代表质数个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],m=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这便是在我写下这笔记之前的对线性筛的全部认知。</p><p>然而最近看到了线性筛求积性函数。</p><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>首先，积性函数的定义是：</p><p>一个积性函数$f(x)$，满足互质的两数$a,b$，$f(ab)=f(a)f(b)$。</p><p>“互质”这个条件，便可以想到线性筛了。</p><p>举几个积性函数的例子。</p><p>定义$v[i]$表示$i$的最小质因子。</p><p>定义$prime[i]$表示第$i$个质数。</p><p>定义$num[x]$表示$x$的最小质因子$p_i$对于因数个数的贡献，即$c_i$。</p><p>定义$factor[x]$表示$x$的因子个数。</p><p>定义$sum[x]$表示$x$的因子和。</p><p>定义$pow_{sum}[x]$表示$x$的最小质因子$p_i$对于因数和的贡献，即$\sum_{i=0}^{c_i}p_i^j$。</p><p>定义$euler[x]=\varphi(x)$。</p><h2 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h2><p>由算术基本定理，任意一个大于$1$的正整数都可以分解为有限个质数的乘积。</p><p>则$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$factor[x]=\prod_{i=1}^m (c_i+1)$，这个式子便是后面实现的关键所在。</p><p>关于$factor[x]$为积性函数，显然，证明略。</p><p>那么，就可以在用线性筛筛质数的过程中“顺便”求个积性函数了。</p><p>根据上面的线性筛写法，进行分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，因子个数为$1+1=2$,此时$num[i]=1$。</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">factor[i*prime[j]]=factor[i]/(num[i]+1)*(num[i]+2)</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">num[i*prime[j]]=num[i]+1</script></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">factor[i*prime[j]]=factor[i]* factor[prime[j]]</script><p>由于$prime[j]$即为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">num[i*prime[j]]=1</script></li></ul><p>完成。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],num[<span class="number">1000010</span>],<span class="built_in">factor</span>[<span class="number">1000010</span>],m=<span class="number">0</span>;</span><br><span class="line">void <span class="built_in">primes</span>(int n) &#123;</span><br><span class="line">memset(v,<span class="number">0</span>,sizeof(v));</span><br><span class="line"><span class="built_in">factor</span>[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">2</span>;<span class="built_in">i</span>&lt;=n;<span class="built_in">i</span>++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[<span class="built_in">i</span>]) &#123;</span><br><span class="line">v[<span class="built_in">i</span>]=<span class="built_in">i</span>;</span><br><span class="line">prime[++m]=<span class="built_in">i</span>;</span><br><span class="line">num[<span class="built_in">i</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">factor</span>[<span class="built_in">i</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">1</span>;<span class="built_in">j</span>&lt;=m;<span class="built_in">j</span>++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[<span class="built_in">j</span>]&gt;v[<span class="built_in">i</span>]||prime[<span class="built_in">j</span>]*<span class="built_in">i</span>&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[<span class="built_in">i</span>*prime[<span class="built_in">j</span>]]=prime[<span class="built_in">j</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span><span class="comment">%prime[j]) &#123;</span></span><br><span class="line"><span class="built_in">factor</span>[<span class="built_in">i</span>*prime[<span class="built_in">j</span>]]=<span class="built_in">factor</span>[<span class="built_in">i</span>]*<span class="built_in">factor</span>[prime[<span class="built_in">j</span>]];</span><br><span class="line">num[<span class="built_in">i</span>*prime[<span class="built_in">j</span>]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">factor</span>[<span class="built_in">i</span>*prime[<span class="built_in">j</span>]]=<span class="built_in">factor</span>[<span class="built_in">i</span>]/(num[<span class="built_in">i</span>]+<span class="number">1</span>)*(num[<span class="built_in">i</span>]+<span class="number">2</span>);</span><br><span class="line">num[<span class="built_in">i</span>*prime[<span class="built_in">j</span>]]=num[<span class="built_in">i</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="因数和"><a href="#因数和" class="headerlink" title="因数和"></a>因数和</h2><p>同上，$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$sum[x]=\prod_{i=1}^m(\sum_{j=0}^{c_i}p_i^{j})$，这个式子为后面实现的关键所在，同样，这玩意也是个积性函数。</p><p>那么，同上，线性筛，分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，因数和为$i+1$，此时$pow_{sum}[i]=i+1$。</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">sum[i*prime[j]]=sum[i]/pow_{sum}[i]*(pow_{sum}[i]*prime[j]+1)</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">pow_{sum}[i*prime[j]]=pow_{sum}[i]*prime[j]+1</script></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">sum[i*prime[j]]=sum[i]*sum[prime[j]]</script><p>因为$prime[j]$为$i*prime[j]$的最小质因子</p><p>则</p><script type="math/tex; mode=display">pow_{sum}[i*prime[j]]=prime[j]+1</script></li></ul><p>完成。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],sum[<span class="number">1000010</span>],pow_sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">pow_sum[i]=i+<span class="number">1</span>;</span><br><span class="line">sum[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]*sum[prime[j]];</span><br><span class="line">pow_sum[i*prime[j]]=prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]/pow_sum[i]*(pow_sum[i]*prime[j]+<span class="number">1</span>);</span><br><span class="line">pow_sum[i*prime[j]]=pow_sum[i]*prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数$\varphi(x)$表示对于正整数$x$，小于或等于$x$的正整数中与$x$互质的数的个数，其中$\varphi(1)=1$。</p><p>同上，$x=\prod_{i=1}^m {p_i}^{c_i}$，其中$c_i$都是正整数，$p_i$都是质数且严格递增。</p><p>$\varphi(x)=x\prod_{i=1}^m(1-\frac{1}{p_i})$，这个式子是后面实现的关键。这玩意依旧是个积性函数。</p><p>令$euler[x]=\varphi(x)$。</p><p>同上，线性筛，分类讨论。</p><ul><li>当$i$的最小质因子为$0$，即$i$为质数时，显然，小于其的正整数均小于它，则$euler[i]=i-1$</li></ul><p>然后进入下面的枚举$j$。</p><ul><li><p>当$i\% prime[j]=0$，即$i$与$prime[j]$不互质时</p><p>此时</p><script type="math/tex; mode=display">euler[i*prime[j]]=eular[i]*prime[j]</script><p>(可由定义式推出)</p></li><li><p>当$i\% prime[j]!=0$，即$i$与$prime[j]$互质时</p><p>此时</p><script type="math/tex; mode=display">euler[i*prime[j]]=euler[i]*euler[prime[j]]</script></li></ul><p>完成。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,prime[<span class="number">40010</span>],v[<span class="number">40010</span>],euler[<span class="number">40010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">v[prime[j]*i]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]) euler[prime[j]*i]=euler[prime[j]]*euler[i];</span><br><span class="line"><span class="keyword">else</span> euler[prime[j]*i]=prime[j]*euler[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是举了几个积性函数的例子，以后遇到其他的积性函数要灵活运用，貌似还有个啥狄利克雷卷积啥的东西，那便是之后的事了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P3708] koishi的数学题</title>
      <link href="/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P3708%5D-koishi%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P3708%5D-koishi%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数$n$。</p><p>设$f(x)=\sum_{i=1}^nx\mod i$，输出$f(1),f(2),……,f(n)$。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$ 20\%$的数据，$n \le 1000$。<br>对于$ 60\%$的数据，$n \le 10^5$。<br>对于$100\%$的数据，$1 \le n \le 10^6$。 </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P3708" target="_blank" rel="noopener">P3708 koishi的数学题</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>也就是$1-n$的剩余系依次相加。</p><p>每次向答案中加$n$，表示每个数的剩余系都向后移动了一个。</p><p>但是一定会有一些数加上$1$后大于其所对应剩余系的最大值。</p><p>这些数实质上也就是$n$的因子。</p><p>因此再减去$n$的因子和。</p><p>而因为因子和是积性函数，所以考虑线性筛。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll n,sum[<span class="number">1000010</span>],v[<span class="number">1000010</span>],prime[<span class="number">1000010</span>],pow_sum[<span class="number">1000010</span>],pow_low[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">v[i]=i;</span><br><span class="line">prime[++m]=i;</span><br><span class="line">sum[i]=i+<span class="number">1</span>;</span><br><span class="line">pow_sum[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">v[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(!(i%prime[j])) &#123;</span><br><span class="line">sum[i*prime[j]]=sum[i]/pow_sum[i]*(pow_sum[i]*prime[j]+<span class="number">1</span>);</span><br><span class="line">pow_sum[i*prime[j]]=pow_sum[i]*prime[j]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum[i*prime[j]]=sum[i]*sum[prime[j]];</span><br><span class="line">pow_sum[i*prime[j]]=prime[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ans=ans+n-sum[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来翻了翻题解，发现一个贼神奇的做法。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fem6gw95.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/fem6gw95.png"></p><p>妙啊。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4868] Preprefix sum</title>
      <link href="/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P4868%5D-Preprefix-sum/"/>
      <url>/is-zxy.github.io/2019/12/28/%5B%E6%B4%9B%E8%B0%B7P4868%5D-Preprefix-sum/</url>
      
        <content type="html"><![CDATA[<p>给定一个序列$a$，有两种操作：</p><ol><li>$Modify\ \  i\ \ x$：把$a_i$改为$x$</li><li>$Query\ \ i$：查询前缀和$S[i]$的前缀和$SS[i]$，并输出。</li></ol><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1&lt;=N,M&lt;=100000$,且在任意时刻$0&lt;=A_i&lt;=100000$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4868" target="_blank" rel="noopener">P4868 Preprefix sum</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>易得$SS[n]=\sum_{i=1}^n(n-i+1)a_i=\sum_{i=1}^n(n+1)a_i-\sum_{i=1}^ni*a_i$</p><p>那么维护两个树状数组$sum_1$与$sum_2$即可。其中</p><p>$sum_1[n]=\sum_{i=1}^n a_i$</p><p>$sum_2[n]=\sum_{i=1}^n i*a_i$</p><p>每次$Modify$更新。</p><p>$Query$查询$i$时，用$(i+1)*sum_1[i]-sum_2[i]$即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[<span class="number">100010</span>],sum_1[<span class="number">100010</span>],sum_2[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,ll y)</span> </span>&#123;</span><br><span class="line">ll ty=y*x;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) &#123;</span><br><span class="line">sum_1[x]+=y;</span><br><span class="line">sum_2[x]+=ty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=x+<span class="number">1</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=lowbit(x)) ans+=t*sum_1[x]-sum_2[x];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">update(i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="built_in">string</span> ins;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ins;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">ll y;</span><br><span class="line"><span class="keyword">if</span>(ins==<span class="string">"Modify"</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">update(x,y-a[x]);</span><br><span class="line">a[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ask(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF630C] Lucky Numbers</title>
      <link href="/is-zxy.github.io/2019/12/27/%5BCF630C%5D-Lucky-Numbers/"/>
      <url>/is-zxy.github.io/2019/12/27/%5BCF630C%5D-Lucky-Numbers/</url>
      
        <content type="html"><![CDATA[<p>给定$n$，求不超过$n$位的只有数字$7$和$8$组成的数字有多少个。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p> $(1&lt;=n&lt;=55)$  </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF630C" target="_blank" rel="noopener">CF630C Lucky Numbers</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把$7$和$8$看作是$0$和$1$，那么其实$n$位的个数就是$2^n$个。</p><p>总方案数也就是$\sum_{i=1}^n2^i=2^{n+1}-2$。</p><p>本以为是个好题，看来又是恶意评分啊。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ull n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((ull)<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)-(ull)<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CF702B] Powers of Two</title>
      <link href="/is-zxy.github.io/2019/12/26/%5BCF702B%5D-Powers-of-Two/"/>
      <url>/is-zxy.github.io/2019/12/26/%5BCF702B%5D-Powers-of-Two/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$n$的序列$a$，从中选取$a_i$，$a_j$，使得$a_i+a_j=2^x$，$(x∈N^+,i&lt;j)$。求序列中有多少对这样的数。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p> $(1&lt;=n&lt;=10^{5})$ </p><p> $(1&lt;=a_{i}&lt;=10^{9})$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF702B" target="_blank" rel="noopener">CF702B Powers of Two</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对序列从小到大排序，去重，并令原序列中中数$i$的个数为$js[i]$，那么</p><p>当$a_i&lt;2^{x-1}$时，根据乘法原理，对数即为$js[a_i]*js[2^x-a_i]$。</p><p>当$a_{i}<script type="math/tex">=</script>2^{x-1}$时，则对数为$C_{js[a_i]}^{2}$，即为$\frac{js[a_i]\times(js[a_i]-1)}{2}$。</p><p>当$a_i&gt;2^{x-1}$无须考虑，与第一种情况重复。</p><p>范围$10^9$，则只需要到$2^{30}$，时间复杂度约为$O(30n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,t[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>,ll&gt; js;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> maxn)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++) &#123;</span><br><span class="line"><span class="keyword">if</span>(*it&gt;maxn) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(maxn==*it) ans+=(js[*it]*(js[*it]<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> ans+=js[*it]*js[maxn*<span class="number">2</span>-*it];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">t[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) t[i]=t[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">a.insert(x);</span><br><span class="line">js[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++) work(t[i]/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[USACO09DEC] 牛收费路径</title>
      <link href="/is-zxy.github.io/2019/12/25/%5BUSACO09DEC%5D-%E7%89%9B%E6%94%B6%E8%B4%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/is-zxy.github.io/2019/12/25/%5BUSACO09DEC%5D-%E7%89%9B%E6%94%B6%E8%B4%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>给定$n$个点，$m$个双向边，点有点权，边有边权。有$k$个询问，要求$s_i$到$t_i$的最小费用，其中费用定义为经过所有边权和与经过所有点的点权最大值之和。</p><a id="more"></a><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$(1 &lt;= N &lt;= 250)$</p><p>$ (1 &lt;= M &lt;= 10000) $</p><p>$ (1 &lt;= A_j &lt;= N,1 &lt;= B_j &lt;= N) $</p><p>$(1 &lt;= L_j &lt;= 100,000)$</p><p>$(1 &lt;= C_i &lt;= 100000) $</p><p>$ (1 &lt;= K &lt;= 10,000) $</p><p>$ (1 &lt;= s_i &lt;= N; 1 &lt;= t_i &lt;= N; s_i != t_i)$ </p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P2966" target="_blank" rel="noopener">[USACO09DEC]牛收费路径</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>范围很小，$250$，便考虑$Floyd$。</p><p>本题难点就在于点权$value$的处理。可以在跑$Floyd$的同时对点权最大进行处理。</p><p>目前在求$i$到$j$以$k$为中继点的最短路径$d[i][j]$，那么此时$i$到$j$的最小费用$ans[i][j]$便可表为</p><p>$min(ans[i][j],d[i][j]+max(value[i],value[j],value[k]))$。</p><p>为了保证此时$value[i]$、$value[j]$、$value[k]$中有$i$到$j$的最小费用路径中的最大点权，可以将各点按照点权值从小到大排序，这样$Floyd$一遍，然后针对每个询问输出解即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,t[<span class="number">310</span>],d[<span class="number">310</span>][<span class="number">310</span>],ans[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value,id;</span><br><span class="line">&#125;p[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.value==y.value) <span class="keyword">return</span> x.id&lt;y.id;</span><br><span class="line"><span class="keyword">return</span> x.value&lt;y.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">ans[i][j]=min(ans[i][j],d[i][j]+max(p[i].value,max(p[j].value,p[k].value)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;p[i].value,p[i].id=i;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t[p[i].id]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">x=t[x],y=t[y];</span><br><span class="line">d[x][y]=d[y][x]=min(z,d[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Floyd();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">x=t[x],y=t[y];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USACO </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
